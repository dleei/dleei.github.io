<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试高频的事件循环</title>
      <link href="/2023/08/09/javasript%E9%87%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/08/09/javasript%E9%87%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h1><p><code>JavaScript</code>是一门单线程的语言,在同一时间只能做一件事,js里面的代码要按照顺序逐行执行代码?比如说我们浏览新闻想要获取新闻图片,如果网络卡顿,获取了很长时间,难道就这样干等着吗?那肯定是不会的,给到用户的体验也是不好的</p><p>在js里所有的任务可以被分为<strong>同步任务</strong>和<strong>异步任务</strong>,异步任务里又有<strong>微任务</strong>和<strong>宏任务</strong>,</p><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aedf3a792af248d28100b3e15e98c3b7~tplv-k3u1fbpfcp-watermark.image" alt="Snipaste_2023-08-09_21-11-15.png"></p><p>事件循环运行机制</p><p>这种事件循环机制是由 JavaScript 的宿主环境来实现的，在浏览器运行环境中由浏览器内核引擎实现，而在 <code>NodeJS</code> 中则由 <a href="https://github.com/libuv/libuv">libuv</a> 引擎实现。</p><p>主线程运行时候，产生堆（<code>Heap</code>）和栈（<code>Stack</code>），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件。只要栈中的代码执行完毕，主线程就会通过事件循环机制读取任务队列，依次执行那些事件所对应的回调函数。</p><p>运行机制：</p><ol><li>所有同步任务都在主线程上执行，形成一个 <strong>执行栈</strong>（Execution Context Stack）</li><li>主线程之外，还存在一个 <strong>任务队列</strong>（Task Queue）。只要异步任务有了运行结果，就在 <strong>任务队列</strong> 之中放置一个事件</li><li>一旦 <strong>执行栈</strong> 中的所有同步任务执行完毕，系统就会读取 <strong>任务队列</strong>，看看里面有哪些待执行事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步</li></ol><h2 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed6acfacae542078630f975acb5e23d~tplv-k3u1fbpfcp-watermark.image" alt="1633593121990_图片1.png"></p><p><code>JavaScript</code> 的异步任务根据事件分类分为两种：宏任务（<code>MacroTask</code>）和微任务（<code>MicroTask</code>）</p><p>  微任务:一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p><p>   常见的微任务有：</p><pre><code>*   Promise.then*   MutaionObserver*   Object.observe（已废弃；Proxy 对象替代）*   process.nextTick（Node.js）</code></pre><p>  宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p><p>   常见的宏任务有：</p><pre><code>*   setTimeout/setInterval*   UI rendering/UI事件*   postMessage、MessageChannel*   setImmediate、I/O（Node.js）</code></pre><p>微任务与宏任务的区别</p><p>宏任务与微任务的区别在于队列中事件的执行优先级。进入整体代码（宏任务）后，开始首次事件循环，当执行上下文栈清空后，事件循环机制会优先检测微任务队列中的事件并推至主线程执行，当微任务队列清空后，才会去检测宏任务队列中的事件，再将事件推至主线程中执行，而当执行上下文栈再次清空后，事件循环机制又会检测微任务队列，如此反复循环。</p><p><strong>宏任务与微任务的优先级</strong></p><ul><li>宏任务的优先级高于微任务</li><li>每个宏任务执行完毕后都必须将当前的微任务队列清空</li><li>第一个 <code>&lt;script&gt;</code> 标签的代码是第一个宏任务</li><li><code>process.nextTick</code> 优先级高于 <code>Promise.then</code></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e335654c152d40cabc2ffc8c1888d17f~tplv-k3u1fbpfcp-watermark.image" alt="Snipaste_2023-08-09_22-19-19.png"><br>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>); <span class="comment">// 2 4 3 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li><li>遇到<code>console.log()</code>，立即执行。</li><li>好啦，整体代码<code>script</code>作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务<code>Event Queue</code>中<code>setTimeout</code>对应的回调函数，立即执行。</li><li>结束。</li></ul><h2 id="async与awite"><a href="#async与awite" class="headerlink" title="async与awite"></a>async与awite</h2><p>async关键字是asynchronous(异步)的简写,用来声明一个函数是异步函数,写在函数的最前面,他会返回一个<code>promise</code>对象</p><p><code>awite</code>可以理解为asynchronous waite(等待异步),他会等待一个异步任务返回的结果</p><p>下面这两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>awite</p><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise </code>对象，返回该对象的结果。如果不是 <code>Promise </code>对象，就直接返回对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1 fn2 3 2 </span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async </code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax入门</title>
      <link href="/2023/08/07/ajax/"/>
      <url>/2023/08/07/ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="什么是ajax"><a href="#什么是ajax" class="headerlink" title="什么是ajax?"></a>什么是ajax?</h2><p>AJAX 代表异步的 JavaScript 和 XML（<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML）。简单点说，就是使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 对象与服务器通信。它可以使用 JSON、XML、HTML 和文本文件等格式发送和接收数据。AJAX 最吸引人的就是它的“异步”特性，也就是说它可以在不重新刷新页面的情况下与服务器通信，交换数据，或更新页面</p><p>简单来说</p><p>AJAX 最大的优点是在<strong>不重新加载整个页面的情况下</strong>，可以<strong>与服务器交换数据并更新部分网页内容</strong>。</p><p>AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行</p><p><strong>XMLHttpRequest 只是实现 Ajax 的一种方式</strong></p><p><strong>AJAX 不是新的编程语言</strong>，而是一种使用现有标准的新方法</p><p>是⼀个 <strong>默认异步</strong>执⾏机制的功能,AJAX分为同步（async &#x3D; false）和异步（async &#x3D; true）</p><p> <strong>什么是同步请求？(false)</strong></p><blockquote><p> 同步请求是指当前发出请求后，浏览器什么都不能做，<br> 必须得等到请求完成返回数据之后，才会执行后续的代码，<br> 相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。<br> 也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态，<br> 当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态</p></blockquote><p><strong>什么是异步请求？(默认:true)</strong></p><blockquote><p>默认异步：异步请求就当发出请求的同时，浏览器可以继续做任何事，<br>Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。<br>一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，<br>无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。</p></blockquote><h2 id="ajax的使用"><a href="#ajax的使用" class="headerlink" title="ajax的使用"></a>ajax的使用</h2><p>ajax实现的基本步骤</p><ol><li>创建XMLHttpRequest对象,即创建一个异步调用对象.</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li><li>设置响应HTTP请求状态变化的函数.</li><li>发送HTTP请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新.</li></ol><h3 id="1、创建XMLHttpRequest对象"><a href="#1、创建XMLHttpRequest对象" class="headerlink" title="1、创建XMLHttpRequest对象"></a>1、创建<code>XMLHttpRequest</code>对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttpRequest = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><h3 id="2、创建HTTP请求"><a href="#2、创建HTTP请求" class="headerlink" title="2、创建HTTP请求"></a>2、创建HTTP请求</h3><p> 创建了<code>XMLHttpRequest</code>对象之后，必须为<code>XMLHttpRequest</code>对象创建HTTP请求，用于说明<code>XMLHttpRequest</code>对象要从哪里获取数据。通常可以是网站中的数据,也可以是本地中其他文件中的数据。</p><p><code>open()</code>语法</p><p> 创建HTTP请求可以使用<code>XMLHttpRequest</code>对象的<code>open</code>()方法,其语法代码如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XMLHttpRequest</span>.<span class="title function_">open</span>(method,<span class="variable constant_">URL</span>,flag,name,password);</span><br></pre></td></tr></table></figure><table><thead><tr><th>method</th><th>指定HTTP的请求方法,常用的方法为<code>get</code>和<code>post</code></th></tr></thead><tbody><tr><td>URL</td><td>HTTP请求的URL地址</td></tr><tr><td>flag</td><td>指定是否使用异步方式。true表示异步、false表示同步，默认为true(可选)</td></tr><tr><td>name</td><td>用于输入用户名。如果服务器需要验证，则必须使用该参数(可选)</td></tr><tr><td>password</td><td>用于输入密码。若服务器需要验证，则必须使用该参数(可选)</td></tr></tbody></table><p><code>send()</code> 方法</p><ul><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法，将客户端页面的数据发送给服务端</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>([body])  <span class="comment">//body: 在 XHR 请求中要发送的数据体，如果不传递数据则为 null</span></span><br></pre></td></tr></table></figure><blockquote><p>如果使用<code>GET</code>请求发送数据的时候，需要注意如下：</p><ul><li>将请求数据添加到<code>open()</code>方法中的<code>url</code>地址中</li><li>发送请求数据中的<code>send()</code>方法中参数设置为<code>null</code></li></ul></blockquote></li></ul><p><strong>配置链接信息</strong></p><p><img src="/./assets/202308061317975.png"></p><h3 id="3、设置响应HTTP请求状态变化的函数"><a href="#3、设置响应HTTP请求状态变化的函数" class="headerlink" title="3、设置响应HTTP请求状态变化的函数"></a>3、设置响应HTTP请求状态变化的函数</h3><p>创建完HTTP请求之后，应该就可以将HTTP请求发送给Web服务器了。然而，发送HTTP请求的目的是为了接收从服务器中返回的数据。从创建XMLHttpRequest对象开始，到发送数据、接收数据、XMLHttpRequest对象一共会经历以下5中状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readyState === 0 : 表示未初始化完成，也就是 open 方法还没有执行 </span><br><span class="line">readyState === 1 : 表示配置信息已经完成，也就是执行完 open 之后 </span><br><span class="line">readyState === 2 : 表示 send 方法已经执行完成</span><br><span class="line">readyState === 3 : 表示正在解析响应内容</span><br><span class="line">readyState === 4 : 表示响应内容已经解析完毕，可以在客户端使用了</span><br></pre></td></tr></table></figure><blockquote><p> 一个最基本的 ajax 请求就是上面三步 但是光有上面的三个步骤，我们确实能把请求发送到服务端<br> 如果服务端正常的话，响应也能回到客户端 但是我们拿不到响应<br> 如果想要拿到响应，我们需要有两个前提条件</p><ol><li>本次 HTTP 请求是成功的，也就是我们下面要说的 http 状态码为 200 ~ 299</li><li>ajax 对象也有自己的状态码，用来表示本次 ajax 请求中各个阶段</li></ol></blockquote><p> 在通过Ajax的异步调用获得服务器端数据之后，可以使用JavaScript或DOM来将网页中的数据进行局部更新。</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="axios是什么"><a href="#axios是什么" class="headerlink" title="axios是什么?"></a>axios是什么?</h3><p>[Axios](<a href="http://axios-js.com/zh-cn/docs/index.html">axios中文文档|axios中文网 | axios (axios-js.com)</a>) 是一个基于 <em><a href="https://javascript.info/promise-basics">promise</a></em> 网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a> 和浏览器中。 它是 <em><a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><p><strong>本质上就是对XMLHttpRequest()对象的封装</strong></p><h3 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h3><p>1.引入axios.js文件</p><p>2.使用axios( )函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;请求数据的地址&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">//使用.then()方法接收请求到的结果,对服务器接收到的数据进行后续处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p><strong>统一资源定位符</strong>（英语：<strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ocator，缩写：<strong>URL</strong>，或称<strong>统一资源定位器</strong>、<strong>定位地址</strong>、<strong>URL地址</strong>[<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6#cite_note-1">1]</a>）俗称网页地址，简称<strong>网址</strong>，是<a href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91">因特网</a>上标准的资源的地址（Address），如同在网络上的门牌。它最初是由<a href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E">蒂姆·伯纳斯-李</a>发明用来作为<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>的地址，现在它已经被<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F">万维网联盟</a>编制为因特网标准<a href="https://tools.ietf.org/html/rfc1738">RFC 1738</a>。</p><p>url组成</p><p>以“<a href="https://zh.wikipedia.org/w/index.php?title=Special:%E9%9A%A8%E6%A9%9F%E9%A0%81%E9%9D%A2"><em>https://zh.wikipedia.org:443/w/index.php?title=随机页面</em></a>”为例，其中：</p><ol><li><strong>https</strong>，是协议；</li><li><strong>zh.wikipedia.org</strong>，是服务器；</li><li><strong>443</strong>，是服务器上的网络端口号；</li><li><strong>&#x2F;w&#x2F;index.php</strong>，是路径；</li><li><strong>?title&#x3D;Special:随机页面</strong>，是查询参数。</li></ol><h3 id="aixos查询参数"><a href="#aixos查询参数" class="headerlink" title="aixos查询参数"></a>aixos查询参数</h3><p>参数就是和后台交互的时候给他的一些信息</p><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p>axios的params方法会把接收到的参数以字符串的形式拼接到请求地址的后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;www.baidu.com&#x27;</span>,  axios内部处理后会以 www.<span class="property">baidu</span>.<span class="property">com</span>?a=<span class="number">100</span>&amp;b=<span class="number">200</span> 的形式给服务器发送请求获取数据<span class="comment">// 在地址后面加一个 ?，然后以 key=value 的形式传递 // 两个数据之间以 &amp; 分割</span></span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        参数名<span class="number">1</span>:参数值<span class="number">1</span>,<span class="comment">//a:100,</span></span><br><span class="line">        参数名<span class="number">2</span>:参数值<span class="number">2</span><span class="comment">//b:200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样服务端就能接受到两个参数 一个是 a，值是 100，一个是 b，值是 200</p><h4 id="post-请求"><a href="#post-请求" class="headerlink" title="post 请求"></a>post 请求</h4><p>post 请求的参数是携带在请求体中的，所以<strong>不需要在url 后面拼接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;www.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">       参数名<span class="number">1</span>:参数值<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//接收请求到的数据并做后续的处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>但是携带<strong>参数 <code>get</code> 和 <code>post</code>两个方式还是有区别的</strong></li></ul><h3 id="GET-还是-POST？"><a href="#GET-还是-POST？" class="headerlink" title="GET 还是 POST？"></a>GET 还是 POST？</h3><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>然而，在以下情况中，请使用 POST 请求：</p><ul><li>不愿使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><p>常用请求方法</p><table><thead><tr><th>get(默认请求)</th><th>获取数据</th></tr></thead><tbody><tr><td>post</td><td>数据提交</td></tr><tr><td>put</td><td>修改数据(全部)</td></tr><tr><td>delete</td><td>删除数据</td></tr><tr><td>patch</td><td>修改数据(部分)</td></tr></tbody></table><p>axios错误处理</p><p>语法:在then( )方法的后面调用.catch( )方法捕获错误,传入回调函数并定义形参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="http-请求报文"><a href="#http-请求报文" class="headerlink" title="http 请求报文"></a>http 请求报文</h3><p><img src="/./assets/202308061429046.png"></p><p>http的请求报文由四个部分组成</p><p>1.请求行</p><p>2.请求头</p><p>3.请求空行</p><p>4.请求体</p><p><strong>请求行</strong></p><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔</p><p><strong>请求头</strong></p><p>请求头由<strong>关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔</strong>。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：</p><p>User-Agent：产生请求的浏览器类型。</p><p>Accept：客户端可识别的内容类型列表。</p><p>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</p><p><strong>请求空行</strong></p><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p><p><strong>请求体</strong></p><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>概念:服务器按照http协议要求的格式,返回给浏览器的内容</p><p>和请求报文也是一样也是有四个部分组成</p><p>1.响应行（状态行）：协议、HTTP 响应状态码、状态信息</p><p>2.响应头：以键值对的格式携带的附加信息，比如：Content-Type</p><p>3.响应空行：分隔响应头，空行之后的是服务器返回的资源</p><p>4.响应体：返回的资源</p><p>http<strong>响应码</strong></p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td>消息响应</td></tr><tr><td>2xx</td><td>成功响应</td></tr><tr><td>3xx</td><td>重定向</td></tr><tr><td>4xx</td><td>客户端错误</td></tr><tr><td>5xx</td><td>服务端错误</td></tr></tbody></table><p>常见http响应码</p><p>200———请求成功</p><p>301——— 资源（网页等）被永久转移到其它URL</p><p>404———请求的资源（网页等）不存在</p><p>500———内部服务器错误,无法完成请求</p><h3 id="表单信息收集插件"><a href="#表单信息收集插件" class="headerlink" title="表单信息收集插件"></a>表单信息收集插件</h3><p>form-serialize</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title function_">serialize</span>(form, &#123; <span class="attr">hash</span>: <span class="literal">true</span>, <span class="attr">empty</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p>参数1: 表单元素对象</p><p>参数2: 配置对象</p><ul><li><p>hash: true 将收集到的数据封装成对象, false 将收集到的数据封装成查询字符串</p></li><li><p>empty: 如果用户没有输入指定的内容, 也获取</p></li></ul><blockquote><p>一般不用管他全部默认设置为true,后面好方便操作</p></blockquote><h2 id="深入axios实现原理"><a href="#深入axios实现原理" class="headerlink" title="深入axios实现原理"></a>深入axios实现原理</h2><p>xhr使用步骤</p><ol><li><p>创建xhr对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br></pre></td></tr></table></figure></li><li><p>调用open方法，设置url和请求方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://hmajax.itheima.net/api/province&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>监听loadend事件，接受结果，</p></li></ol><blockquote><p>会在调用xhr.send方法发送请求后，不管成功与否都会执行loadend事件里面的回调函数</p></blockquote>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;loadend&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// xhr.response 就是响应的结果</span></span><br><span class="line">    <span class="comment">//默认接收过来的是字符串，需要转换为对象方便使用</span></span><br><span class="line">      <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">response</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><ol start="4"><li><p>调用send方法，向服务器发起请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><p><strong>get请求</strong></p><p><code>URLSearchParams</code>转换查询参数</p><p>使用步骤：</p><p>创建<code>URLSearchParams</code> 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(&#123;</span><br><span class="line">  参数名<span class="number">1</span>:参数值<span class="number">1</span>,</span><br><span class="line">  参数名<span class="number">2</span>:参数值<span class="number">2</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>生成至指定格式的查询参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = paramsObj.<span class="title function_">toString</span>(params)</span><br></pre></td></tr></table></figure><p>post<strong>请求</strong></p></li></ol><p>请求头设置 Contnet -Type：application&#x2F;json</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br></pre></td></tr></table></figure><p>发送请求携带json字符串数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>概念：**<code>Promise</code>** 对象表示异步操作最终的完成（或失败）以及其结果值</p><p>这是引用MDN上面的概念，十分的晦涩难懂,简单来说，所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息</p><h3 id="promise基本使用"><a href="#promise基本使用" class="headerlink" title="promise基本使用"></a>promise基本使用</h3><p>Promise对象是一个构造函数，用来生成promise实例</p><p>下面的代码是一个最基本简单的Promise实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 2. 开启异步任务, 并将结果传递出去</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 异步任务只有两种结果: 成功 / 失败</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="string">&#x27;这是一秒后的结果&#x27;</span></span><br><span class="line">    <span class="comment">// return result // 带不出去</span></span><br><span class="line">    <span class="comment">// resolve(result) // 带到 p.then 中去</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;失败了&#x27;</span>)) <span class="comment">// 带到 p.catch 中去</span></span><br><span class="line">    <span class="comment">// 总结: resolve 会触发 .then() 回调函数的执行, reject 会触发 .catch() 回调函数的执行</span></span><br><span class="line">    <span class="comment">// 如果成功了就调用 resolve, 失败了就调用 reject</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  Promise对象接收一个函数作为参数: 回调函数, 该函数会立即执行</p><p>  里面的回调函数有两个参数:（由 JavaScript 引擎提供，不用自己部署）</p><p>  参数1: resolve 函数,将Promise 表示从发送请求时的pending状态变为resolve，会在异步操作成功时调用，并将结果作为参数传递出去</p><p>  参数2: reject 函数, 将Promise 表示从发送请求时的pending状态变为reject，会在异步操作失败时调用，并将结果作为参数传递出去</p><p>Promise实例对象还有一个then方法和catch方法他是定义在原型对象身上的</p><h4 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h4><p>在回调函数内执行 resolve 就会把结果带到这里</p><p>下面是一个小例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;随便什么数据&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">runAsync</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="comment">//后面可以用传过来的数据做些其他操作</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><h3 id="then链式调用"><a href="#then链式调用" class="headerlink" title="then链式调用"></a>then链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务1执行完成&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;随便什么数据1&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务2执行完成&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;随便什么数据2&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runAsync3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步任务3执行完成&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;随便什么数据3&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">runAsync1</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">runAsync2</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">runAsync3</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/./assets/202308072234438.png" alt="image-20230807223356135"></p><p>在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">runAsync1</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">runAsync2</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;直接返回数据&#x27;</span>;  <span class="comment">//这里直接返回数据</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/./assets/202308072237457.png" alt="image-20230807223718475"></p><p>一个任务（即一个 <code>Promise</code> 对象）可以被多次使用 <code>.then()</code> 方法进行链式调用。</p><p>在 <code>Promise</code> 链中，每次调用 <code>.then()</code> 方法都会返回一个新的 <code>Promise</code> 对象，这个新的 <code>Promise</code> 对象会在上一个 <code>Promise</code> 成功并返回数据时被解析</p><h4 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h4><p>在回调函数内执行 reject就会把结果带到这里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNumber</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> num = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">10</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="title function_">resolve</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">&#x27;数字大于5,失败了&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getNumber</span>()</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="keyword">function</span>(<span class="params">reason, data</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。</p><p>多次运行我们只会得到两种结果,要么是小于5,要么是大于5,失败了</p><p>这时候就会用到catch方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getNumber</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getNumber</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了</p><h4 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h4><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">all</span>([<span class="title function_">runAsync1</span>(), <span class="title function_">runAsync2</span>(), <span class="title function_">runAsync3</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：</p><h4 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a>race的用法</h4><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样</p><p>假如我们的异步任务1延时1秒后执行,异步任务2和3都是延时2秒后执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">race</span>([<span class="title function_">runAsync1</span>(), <span class="title function_">runAsync2</span>(), <span class="title function_">runAsync3</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了</p><p><img src="/./assets/202308072302597.png" alt="image-20230807230234058"></p><p>在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，才会输出</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">        img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;图片请求超时&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">race</span>([<span class="title function_">requestImg</span>(), <span class="title function_">timeout</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js里的垃圾回收机制</title>
      <link href="/2023/08/02/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/08/02/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾回收机制是什么"><a href="#垃圾回收机制是什么" class="headerlink" title="垃圾回收机制是什么?"></a>垃圾回收机制是什么?</h2><p>垃圾回收机制(Garbage Collection) 简称 GC</p><p>JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存</p><p>当代码执行完毕的时候，JS引擎也会自动地将你的程序，所占用的内存清理掉</p><p>所谓垃圾回收机制就是<strong>清理内存的方式</strong></p><h2 id="垃圾回收机制是怎样进行的"><a href="#垃圾回收机制是怎样进行的" class="headerlink" title="垃圾回收机制是怎样进行的?"></a>垃圾回收机制是怎样进行的?</h2><p>可达性</p><p>简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的,是存在的。就不会被清除，反之就会被垃圾回收机制清除掉</p><p>那么它是如何找到“垃圾”，并且把它清除掉的呢？</p><p>主要有两种内存回收策略</p><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h3><p>它的策略是跟踪记录每个变量值被使用的次数</p><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><ul><li><p>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</p></li><li><p>如果同一个值又被赋给另一个变量，那么引用数加 1</p></li><li><p>如果该变量的值被其他的值覆盖了，则引用次数减 1</p></li><li><p>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = o; <span class="comment">// o2 变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>; <span class="comment">// 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oa = o2.<span class="property">a</span>; <span class="comment">// 引用“这个对象”的 a 属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">&quot;yo&quot;</span>; <span class="comment">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span></span><br><span class="line"><span class="comment">// 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a 属性的那个对象现在也是零引用了</span></span><br><span class="line"><span class="comment">// 它可以被垃圾回收了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是无法解决对象之间的循环引用,会导致内存泄漏</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123; <span class="comment">// fn引用次数为1，因为window.fn = fn，会在window=null即浏览器关闭时回收</span></span><br><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// A: 1</span></span><br><span class="line"><span class="keyword">let</span> B = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// B: 1</span></span><br><span class="line">A.<span class="property">b</span> = B <span class="comment">// B: 2</span></span><br><span class="line">B.<span class="property">a</span> = A <span class="comment">// A: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A对象中引用了B，B对象中引用了A，两者引用计数都不为0，永远不会被回收。</span></span><br><span class="line"><span class="comment">// 若执行无限多次fn，那么内存将会被占满，程序宕机</span></span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">// 还有就是这种方法需要一个计数器，这个计数器可能要占据很大的位置，因为我们无法知道被引用数量的多少。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-标记清除法-mark-and-sweep"><a href="#2-标记清除法-mark-and-sweep" class="headerlink" title="2.标记清除法(mark-and-sweep)"></a>2.标记清除法(mark-and-sweep)</h3><ul><li>从2012年起，所有浏览器都使用了标记清除法。</li><li>目前主流浏览器都是使用标记清除式的垃圾回收策略，只不过收集的间隔有所不同。</li></ul><p>也解决了引用计数无法清除循环引用导致的内存泄漏</p><p>该策略分为<strong>Mark（标记）</strong>和<strong>Sweep（清除）</strong>两个阶段。</p><p><strong>Mark阶段：</strong></p><ul><li>运行时，将内存中的所有变量标记为0（垃圾）</li><li>从各个根对象遍历，将非垃圾变量标记为1</li></ul><p><strong>Sweep阶段：</strong></p><ul><li>将所有标记为0的变量的内存释放</li></ul><p>定期执行以下“垃圾回收”步骤：</p><ul><li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li><li>然后它遍历并“标记”来自它们的所有引用。</li><li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li><li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li><li>没有被标记的对象都会被删除。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308022258349.png"></p><p>我们可以清楚地看到右侧有一个“无法到达的岛屿”。现在我们来看看“标记和清除”垃圾收集器如何处理它。</p><p>第一步标记所有的根：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308022258559.png"></p><p>然后，我们跟随它们的引用标记它们所引用的对象：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308022258176.png"></p><p>……如果还有引用的话，继续标记：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308022258132.png"></p><p>现在，无法通过这个过程访问到的对象被认为是不可达的，并且会被删除。</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308022258400.png"></p><p>我们还可以将这个过程想象成从根溢出一大桶油漆，它流经所有引用并标记所有可到达的对象。然后移除未标记的。</p><h2 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收?"></a>为什么要进行垃圾回收?</h2><p>解决动态内存管理的问题，确保程序在运行时能够高效地分配和释放内存资源，从而避免内存泄漏和内存碎片化，提高程序的稳定性和性能</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><blockquote><ul><li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li><li>当对象是可达状态时，它一定是存在于内存中的。</li><li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达，正如我们在上面的例子中看到的那样。</li></ul></blockquote><p>该博客为个人前端学习过程中的个人总结,难免会有一些错误和一些没有注意到的一些疏漏,欢迎指正错误!</p><p>参考文章</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">MDN-垃圾回收机制</a></p><p><a href="https://zh.javascript.info/garbage-collection">JavaScript现代教程-垃圾回收</a></p><p><a href="https://www.cnblogs.com/luckest/p/16895686.html">js的垃圾回收机制</a></p><p><a href="https://juejin.cn/post/6981588276356317214">「硬核JS」你真的了解垃圾回收机制吗</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript对象数组常用方法总结</title>
      <link href="/2023/07/29/JavaScript%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/29/JavaScript%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307292055131.png"></p><p><code>pop</code></p><p>数组尾部删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;西瓜&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>,<span class="string">&#x27;芒果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>]</span><br><span class="line">fruits.<span class="title function_">pop</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291558417.png" alt="image-20230729155806391"></p><p><code>push</code></p><p>数组尾部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;西瓜&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>,<span class="string">&#x27;芒果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>]</span><br><span class="line">fruits.<span class="title function_">push</span>(<span class="string">&#x27;榴莲&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291559018.png" alt="image-20230729155859991"></p><p><code>unshift</code></p><p>数组头部添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;西瓜&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>,<span class="string">&#x27;芒果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>]</span><br><span class="line"> fruits.<span class="title function_">unshift</span>(<span class="string">&#x27;樱桃&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291600164.png" alt="image-20230729160000141"></p><p><code>shift</code></p><p>数组头部删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;西瓜&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>,<span class="string">&#x27;芒果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>]</span><br><span class="line"> fruits.<span class="title function_">shift</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291600431.png" alt="image-20230729160036406"></p><p><code>forEach</code></p><p>语法:<code>forEach</code>(item,index)</p><p>参数一: 当前循环的元素</p><p>参数二: 当前循环的索引</p><p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数(回调函数)</p><ol><li>函数没有返回值，即 <code>underfined</code>；</li><li>不对原数组产生影响。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = [<span class="string">&#x27;rongxing&#x27;</span>, <span class="string">&#x27;aniu&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>]</span><br><span class="line">str.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">//rongxing,aniu,zhangsan,lisi</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">//0,1,2,3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>sort</code></p><p>排序</p><p>正序排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = [<span class="number">15</span>, <span class="number">51</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">24</span>, <span class="number">13</span>]</span><br><span class="line"><span class="keyword">const</span> sortNum = num.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortNum);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortNum = num.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortNum);</span><br></pre></td></tr></table></figure><p><code>splice</code></p><p>删除数组任意位置元素</p><p><code>splice</code>(删除元素对应位置的索引,删除的个数[不填默认从头部开始删除],新增的元素)</p><p>返回值:删除的元素数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;西瓜&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>,<span class="string">&#x27;芒果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>]</span><br><span class="line"> fruits.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);<span class="comment">//[&#x27;西瓜&#x27;,&#x27;哈密瓜&#x27;,&#x27;芒果&#x27;,&#x27;香蕉&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>map</code></p><p><code>map</code>(回调函数(item,index) { })</p><ol><li><code>map</code> 的返回值是一个新数组 </li><li>新数组中的元素, 由回调函数的返回值决定, 返回的元素就会加入到新数组中</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291806340.png" alt="image-20230729180648312"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>]</span><br><span class="line">     <span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>]</span><br><span class="line">    <span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> item + <span class="string">&#x27;颜色&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//[&#x27;red颜色&#x27;, &#x27;blue颜色&#x27;, &#x27;green颜色&#x27;, &#x27;purple颜色&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>join</code></p><p><code>join()</code> 方法将数组中的所有元素连接成一个字符串</p><p><code>join(‘ ’)</code>分隔符手动指定,若不需要则留空</p><p>1.把数组转换为字符串</p><p>2.默认以 <code>,</code> 作为分隔符拼接成字符串</p><p><code>filter</code></p><ol><li><p>返回一个新数组, 里面存储着所有符合条件的元素    </p></li><li><p>特点同 map &#x2F; forEach, 都会遍历数组中每一个元素   </p></li><li><p>传入的回调函数中, 返回值(布尔值)表示当前遍历的元素是否符合条件 </p><p>其实这个方法就是一个过滤方法，前面那个 every 方法，只判断不过滤，filter 会过滤掉一些不符合条件的，并返回新数组。</p><ol><li>返回一个满足过滤条件的新数组；</li><li>不会改变原数组。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291803403.png" alt="image-20230729180350356"></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">    <span class="keyword">const</span> newArr = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> item &gt; <span class="number">20</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)<span class="comment">//[30,40]</span></span><br></pre></td></tr></table></figure><p><code>every</code></p><p>检测元素是否满足条件, 返回布尔型.所有数组元素都满足条件则返回 <code>true</code>, 只要有一个不满足条件就返回 <code>false</code></p><p><code>arr.every(callback)</code> 会对每一个元素都执行 callback 方法，直到 callback 返回 false。有时候 every 方法会和 <code>forEach</code> 方法相比较，因为 <code>forEach</code> 无法停止，而 <code>every</code> 方法返回 flase 时可以中途停止。</p><ol><li>若全部通过测试，函数返回值 true，中途退出，返回 false；</li><li>不对原数组产生影响。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291809182.png" alt="image-20230729180950158"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//只要找到不满足条件的元素, 立马就会停止</span></span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">5</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>some</code></p><p>只要有 1 个数组元素满足条件则返回 <code>true</code>, 都不满足则返回 <code>false</code></p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291810710.png" alt="image-20230729181026686"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只要找到满足条件的元素了, 立马就会停止</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">15</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>find</code></p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291812354.png" alt="image-20230729181208329"></p><p> <code>find</code>  查找满足条件的元素, 返回第一个满足条件的元素, 找不到则返回<code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> goods = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小米&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">1999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;华为&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">4999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">9999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">8888</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;黄瓜&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">8888</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;雪梨&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">8888</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> result = goods.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> === <span class="string">&#x27;苹果&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">//&#123;name: &#x27;苹果&#x27;, price: 9999&#125;</span></span><br></pre></td></tr></table></figure><p><code>findIndex</code></p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291811574.png" alt="image-20230729181134551"></p><p><code>findIndex</code> 查找满足条件的元素的索引号, 找不到则返回-1</p><p> 该方法用法和 <code>find</code> 完全一样, 区别是 find 返回元素, 而 <code>findIndex</code> 返回索引</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> goods = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小米&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">1999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;华为&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">4999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">9999</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;苹果&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">8888</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;黄瓜&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">8888</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;雪梨&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">8888</span></span><br><span class="line">  &#125;</span><br><span class="line">] </span><br><span class="line"><span class="keyword">const</span> result2 = goods.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">name</span> === <span class="string">&#x27;黄瓜&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2)<span class="comment">//4</span></span><br></pre></td></tr></table></figure><p><code>concat</code></p><p>数组合并</p><p><code>concat</code> 方法将创建一个新数组，然后将调用它的对象(this 指向的对象，即原数组)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组。concat 方法并不修改原数组和参数数组，而且对非数组对象同样有效果。</p><ol><li>返回拼接的新数组；</li><li>不修改原数组和参数数组；</li><li>参数可以是非数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">30</span>,<span class="number">54</span>,<span class="number">12</span>]</span><br><span class="line">arr2 = [<span class="number">14</span>,<span class="number">26</span>,<span class="number">30</span>,<span class="number">57</span>,<span class="number">82</span>]</span><br><span class="line">arr3 = arr2.<span class="title function_">concat</span>(arr1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">//[14,26,30,57,82,10,2,30,54,12]</span></span><br></pre></td></tr></table></figure><p><code>fill</code></p><p>填充数组</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291810415.png" alt="image-20230729181059388"></p><p>　<code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。返回修改后的原始数组，不创建新数组。</p><p>　　使用语法：<code>fill( value ,start ,end)</code>，其中 ：</p><p>　　　　<code>value</code> 用来填充数组元素的值，必填。</p><p>　　　　<code>start</code> 可选起始索引，默认值为0。</p><p>　　　　<code>end</code> 可选终止索引，默认值为 <code>this.length</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当传入单个参数的时候，该方法会用该参数的值填充整个数组</span></span><br><span class="line">    <span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="title function_">fill</span>(<span class="number">1</span>)); <span class="comment">//[1,1,1,1,1]</span></span><br><span class="line">    <span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr2.<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">//[0,0,0,0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当传入两个参数的时候，第一个参数为填充的元素，第二个为填充元素的起始位置</span></span><br><span class="line">    <span class="keyword">var</span> arr3 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr3.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">//[0,1,2,1,1,1,1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当传入三个参数的时候，第一个参数为填充的元素，第二个参数和第三个参数分别指填充元素的起始和终止位置，不修改终止位置元素</span></span><br><span class="line">    <span class="keyword">var</span> arr4 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr4.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)); <span class="comment">//[0,1,2,1,1,5]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果提供的起始位置或结束位置为负数，则他们会被加上数组的长度来算出最终的位置，例如 起始位置为-1 就相当于array.length-1</span></span><br><span class="line">    <span class="keyword">var</span> arr5 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr5.<span class="title function_">fill</span>(<span class="number">1</span>, -<span class="number">3</span>));<span class="comment">//[0,1,2,1,1,1]</span></span><br><span class="line">    <span class="keyword">var</span> arr6 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr6.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">3</span>, -<span class="number">2</span>));<span class="comment">//[0,1,2,1,4,5]</span></span><br></pre></td></tr></table></figure><p><code>reverse</code></p><p>数组翻转</p><p>这样同样也可以实现数组的倒序排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> arr = num.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">//[5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><p><code>reduce</code></p><p>数组求和</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291807635.png" alt="image-20230729180753609"></p><p><code>reduce</code> 是一个合并的过程，从左到右，直到把所有元素合并到一起，并返回最终的结果。它接受两个参数，第一个参数是一个回掉函数，第二个参数是一个初始值，表示处理第一个元素时的前一个值。这个回掉函数接受四个参数，依次是 <code>accumulator</code>（上次处理的结果），<code>currentValue</code>（当前元素的值），<code>index</code>（当前元素索引），<code>array</code>（调用 <code>reduce</code> 的数组）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 回调函数的参数:</span></span><br><span class="line">      <span class="comment">// 1. 上一次的结果, 第一次拿到的是初始值</span></span><br><span class="line">      <span class="comment">// 2. 当前遍历的元素</span></span><br><span class="line">      <span class="comment">// 回调函数的返回值, 作为下一次循环的第一个参数 (结果)</span></span><br><span class="line">      <span class="comment">// console.log(prev, item)</span></span><br><span class="line">      <span class="keyword">return</span> prev + item</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sum)</span><br></pre></td></tr></table></figure><p><code>Array.from</code></p><p>转换为真数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 转换为真数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 1. 得到伪数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(divs)<span class="comment">//伪数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 2. 转换为真数组 Array.from() 返回真数组, 不会影响原来的伪数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 传入一个伪数组, 返回一个真数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> result = <span class="title class_">Array</span>.<span class="title function_">from</span>(divs)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    result.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      item.<span class="property">tagName</span> === <span class="string">&#x27;DIV&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//真数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307291537615.png" alt="image-20230729153706442"></p><p><code>slice</code></p><p><code>slice()</code> 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。</p><p>slice 的参数包括拷贝的初识位置，结束位置（左闭右开），与 splice 有区别。由于不会改变原数组，这个数组可以用于前拷贝，比如经常看别人使用：<code>arr.slice(0)</code>，表示拷贝数组。</p><ol><li>返回浅拷贝后的新数组；</li><li>不会改变原数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> a2 = a1.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">a1 <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">a2 <span class="comment">//[2, 3]</span></span><br></pre></td></tr></table></figure><p><code>assign</code></p><p><code>Object.assign(target, sources)</code></p><ul><li><code>target</code>：目标对象，即要将属性复制到的对象。</li><li><code>sources</code>：一个或多个源对象，即要从中复制属性的对象。可以传递多个源对象，按顺序依次复制属性到目标对象中。</li></ul><p>返回目标对象，也就是复制属性后的目标对象</p><p>如果多个源对象具有相同的属性名，后面的属性会覆盖前面的属性。这意味着在复制过程中，如果有冲突的属性名，后面的源对象的属性值会覆盖之前的源对象属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源对象</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">c</span>: <span class="number">5</span>, <span class="attr">d</span>: <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性从源对象复制到目标对象</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, obj1, obj2, obj3);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target); <span class="comment">// 输出：&#123; a: 1, b: 3, c: 5, d: 6 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串方法</p><p><code>split</code></p><p>字符串拆分成数组</p><p>将字符串翻转过来,字符串不支持reverse()方法,只能支持数组的翻转,如果想要实现字符串的翻转则需要使用一些小手段,把字符串拆分成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;键盘敲烂 月薪过万&#x27;</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//万过薪月 烂敲盘键</span></span><br></pre></td></tr></table></figure><p><code>trim</code></p><p>去除字符串首尾空格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> str = <span class="string">&#x27; 蓝翔高级技工学校 &#x27;</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">trim</span>()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//蓝翔高级技工学校</span></span><br><span class="line"> <span class="comment">// 一般用于去除注册时用户不小心输入的空格</span></span><br></pre></td></tr></table></figure><p><code>startsWith</code></p><p>  检测是否以某个字符开头, 返回布尔值</p><p>startsWith(检测字符, [检测位置])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">startsWith</span>(<span class="string">&#x27;键&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">startsWith</span>(<span class="string">&#x27;键盘&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">startsWith</span>(<span class="string">&#x27;键盘鼠标&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">startsWith</span>(<span class="string">&#x27;月薪&#x27;</span>, <span class="number">4</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> <code>endsWith</code></p><p> <code>endsWith</code>(检测字符, [字符串长度])</p><p>检测是否以某个字符结尾, 返回布尔值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">endsWith</span>(<span class="string">&#x27;万&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">endsWith</span>(<span class="string">&#x27;过万&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">endsWith</span>(<span class="string">&#x27;奥利给&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">endsWith</span>(<span class="string">&#x27;过万&#x27;</span>, <span class="number">6</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>includes</code></p><p> <code>includes</code>(搜索的字符, [检测位置])</p><p>includes() 方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。</p><p>该函数接受两个参数，第二个参数表示开始查找位置，起始位置为 0。这个方法与 indexOf 方法最大的区别不仅在于返回值一个是索引，一个是布尔值，indexOf 方法使用的是 <code>===</code> 来判断，无法判断 NaN 情况，而 includes 可以判断。</p><ol><li>返回 true 或 false；</li><li>不会改变原数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> str1 = <span class="string">&quot;To be, or not to be, that is the question.&quot;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">includes</span>(<span class="string">&#x27;not to be&#x27;</span>))<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">includes</span>(<span class="string">&#x27;not&#x27;</span>))<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">includes</span>(<span class="string">&#x27;n&#x27;</span>))<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1.<span class="title function_">includes</span>(<span class="string">&#x27;NOT&#x27;</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>keys</code></p><p>数组的 <code>keys()</code> 方法返回一个数组索引的迭代器。</p><p>这个方法会返回一个数组索引的迭代器，迭代器在 ES6 中有特殊的用途。</p><ol><li>函数返回一个迭代器对象；</li><li>不会改变原数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(user) = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure><p><code>values</code></p><p>返回一个包含该对象所有的值的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(user) = [<span class="string">&quot;John&quot;</span>, <span class="number">30</span>]</span><br></pre></td></tr></table></figure><p><code>entries</code></p><p>返回一个包含该对象所有 [key, value] 键值对的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(user) = [ [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;John&quot;</span>], [<span class="string">&quot;age&quot;</span>,<span class="number">30</span>] ]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员提高效率的 10 个方法</title>
      <link href="/2023/07/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%2010%20%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%2010%20%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ol><li>早上不要开会 📅<br>每个人一天是 24 小时，时间是均等的，但是时间的价值却不是均等的，早上 1 小时的价值是晚上的 4 倍。为什么这么说？<br>因为早晨是大脑的黄金时间，经过一晚上的睡眠，大脑经过整理、记录、休息，此时的状态是最饱满的，适合专注度高的工作，比如编程、学习外语等，如果把时间浪费在开会、刷手机等低专注度的事情上，那么就会白白浪费早上的价值。</li><li>不要使用番茄钟 🍅<br>有时候在专心编程的时候，会产生“心流”，心流是一种高度专注的状态，当我们专注的状态被打破的时候，需要 15 分钟的时候才能重新进入状态。<br>有很多人推荐番茄钟工作法，设定 25 分钟倒计时，强制休息 5 分钟，之后再进入下一个番茄钟。本人在使用实际使用这种方法的时候，经常遇到的问题就是刚刚进入“心流”的专注状态，但番茄钟却响了，打破了专注，再次进入这种专注状态需要花费 15 分钟的时间。<br>好的替换方法是使用秒表，它跟番茄钟一样，把时间可视化，但却是正向计时，不会打破我们的“心流”，当我们编程专注度下降的时候中去查看秒表，确定自己的休息时间。</li><li>休息时间不要玩手机 📱<br>大脑处理视觉信息需要动用 90% 的机能，并且闪烁的屏幕也会让大脑兴奋，这就是为什么明明休息了，但是重新回到工作的时候却还是感觉很疲惫的原因。<br>那么对于休息时间内，我们应该阻断视觉信息的输入，推荐：</li></ol><p>闭目养神 😪<br>听音乐 🎶<br>在办公室走动走动 🏃‍♂️<br>和同事聊会天 💑<br>扭扭脖子活动活动 💁‍♂️<br>冥想 or 正念 🧘</p><ol start="4"><li>不要在工位上吃午饭 🥣<br>大脑经过一早上的编程劳累运转之后，此时的专注度已经下降 40%~50%，这个时候我们需要去重启我们的专注度，一个好的方法是外出就餐，外出就餐的好处有：</li></ol><p>促进血清素分泌：我们体内有一种叫做血清素的神经递质，它控制着我们的睡眠和清醒，外出就餐可以恢复我们的血清素，让我们整个人神经气爽：</p><p>日光浴：外出的时候晒太阳可以促进血清素的分泌<br>有节奏的运动：走路是一种有节奏的运动，同样可以促进血清素分泌</p><p>激发场所神经元活性：场所神经元是掌控场所、空间的神经细胞，它存在于海马体中，外出就餐时场所的变化可以激发场所神经元的活性，进而促进海马体活跃，提高我们的记忆力<br>激活乙酰胆碱：如果外出就餐去到新的餐馆、街道，尝试新的事物的话，可以激活我们体内的乙酰胆碱，它对于我们的“创作”和“灵感”起到非常大的作用。</p><ol start="5"><li>睡午觉 😴<br>现在科学已经研究表现，睡午觉是非常重要的一件事情，它可以：</li></ol><p>恢复我们的身体状态：26 分钟的午睡，可以让下午的工作效率提升 34%，专注力提升 54%。<br>延长寿命：中午不睡午觉的人比中午睡午觉的人更容易扑街<br>预防疾病：降低老年痴呆、癌症、心血管疾病、肥胖症、糖尿病、抑郁症等</p><p>睡午觉好处多多，但也要适当，15 分钟到 30 分钟的睡眠最佳，超过的话反而有害。<br>6. 下午上班前运动一下 🚴<br>下午 2 点到 4 点是人清醒度最低的时候，10 分钟的运动可以让我们的身体重新清醒，提高专注度，程序员的工作岗位和场所如果有限，推荐：</p><p>1️⃣ 深蹲<br>2️⃣ 俯卧撑<br>3️⃣ 胯下击掌<br>4️⃣ 爬楼梯（不要下楼梯，下楼梯比较伤膝盖，可以向上爬到顶楼，再坐电梯下来）</p><ol start="7"><li>2 分钟解决和 30 秒决断 🖖<br>⚒️ 2 分钟解决是指遇到在 2 分钟内可以完成的事情，我们趁热打铁把它完成。这是一个解决拖延的小技巧，作为一个程序员，经常会遇到各种各样的突发问题，对于一些问题，我们没办法很好的决策要不要立即完成， 2 分钟解决就是一个很好的辅助决策的办法。<br>💣 30 秒决断是指对于日常的事情，我们只需要用 30 秒去做决策就好了，这源于一个“快棋理论”，研究人员让一个著名棋手去观察一盘棋局，然后分别给他 30 秒和 1 小时去决定下一步，最后发现 30 秒和 1 小时做出的决定中，有 90% 都是一致的。</li><li>不要加班，充足睡眠 💤<br>作为程序员，我们可能经常加班到 9 点，到了宿舍就 10 点半，洗漱上床就 12 点了，再玩会儿手机就可以到凌晨 2、3 点。<br>压缩睡眠时间，大脑就得不到有效的休息，第二天的专注度就会降低，工作效率也会降低，这就是一个恶性循环。<br>想想我们在白天工作的时候，其实有很多时间都是被无效浪费的，如果我们给自己强制设定下班时间，创新、改变工作方式，高效率、高质量、高密度的完成工作，那是否就可以减少加班，让我们有更多的自由时间去学习新的知识技术，进而又提高我们的工作效率，形成一个正向循环。</li><li>睡前 2 小时 🛌</li></ol><p>睡前两小时不能做的事情：</p><p>🍲 吃东西：空腹的时候会促进生长激素，生长激素可以提高血糖，消除疲劳，但如果吃东西把血糖提高了，这时候生长激素就停止分泌了<br>🥃 喝酒<br>⛹️ 剧烈运动<br>💦 洗澡水温过高<br>🎮 视觉娱乐（打游戏，看电影等）<br>📺 闪亮的东西（看手机，看电脑，看电视）<br>💡 在灯光过于明亮的地方</p><p>适合做的事情</p><p>📖 读书<br>🎶 听音乐<br>🎨 非视觉娱乐<br>🧘‍♂️ 使身体放松的轻微运动</p><ol start="10"><li>周末不用刻意补觉 🚫<br>很多人以周为单位进行休息，周一到周五压缩睡眠，周末再补觉，周六日一觉睡到下午 12 点，但这与工作日的睡眠节奏相冲突，造成的后果就是星期一的早上起床感的特别的厌倦、焦躁。<br>其实周末并不需要补觉，人体有一个以天为单位的生物钟，打破当前的生物钟周期，就会影响到下一个生物钟周期，要调节回来也需要花费一定时间。<br>我们应该要以天为单位进行休息，早睡早起，保持每天的专注度。<br>参考<br>以上大部分来源于书籍 《为什么精英都是时间控》，作者桦泽紫苑，是一个脑神经专家，以下是这本书的读书笔记：<br>wukaipeng.notion.site&#x2F;3c2bf227dab…</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="/2023/07/20/DOM%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/07/20/DOM%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件,事件是程序在运行的时候，发生的特定动作或者特定的事情</p><p>下面是一些比较常用的DOM事件</p><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ul><li><code>click</code> (点击事件)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我是点击事件的弹框&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>mouseenter &#x2F; mouseleave (鼠标移入&#x2F;鼠标离开)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;鼠标移入了&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;鼠标离开了&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>mousemove</code> (鼠标移动)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我要开始摸了啊&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</p></li><li><p><code>mouseover</code> &#x2F; <code>mouseout</code> (鼠标移入 &#x2F; 鼠标离开)</p><p>区别:</p><p><code>mouseenter</code>事件只触发一次</p><p><code>mouseover</code>而只要鼠标在节点内部移动,<code>mouseover</code>事件会在子节点上触发多次</p><p><code>mouseout</code>事件和<code>mouseleave</code>事件</p><p>在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发,而<code>mouseout</code>事件会触发</p></li></ul><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><ul><li><p><code>keydown</code> (键盘按下)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;键盘按下了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>keyup</code>(键盘弹起)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;键盘按弹起&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><ul><li><p><code>focus</code>(获得焦点)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focus&#x27;</span> ,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获得焦点了!哈哈哈&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>blur</code>(失去焦点)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;blur&#x27;</span> ,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你别走,没了你我可怎么活啊!燕子555&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><ul><li><p><code>input</code></p><p><code>input</code>事件的一个特点，就是会连续触发，比如用户每按下一次按键，就会触发一次<code>input</code>事件,获取到的都是及时最新的动态</p></li><li><p><code>change</code></p><p>该事件跟<code>change</code>事件很像，不同之处在于<code>input</code>事件在元素的值发生变化后立即发生，而<code>change</code>在元素失去焦点时发生，而内容此时可能已经变化多次。也就是说，如果有连续变化，<code>input</code>事件会触发多次，而<code>change</code>事件只在失去焦点时触发一次。</p></li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>事件监听版本</p><p>L0</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307202159082.png" alt="08ff94172c06fa9f07b09c94e98be78b83d2e932959044a9242cfb78bbabcb29"></p><p>L2</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307202200294.png" alt="1e0802f745a94cf96793a161dba6bd19b552d7c1e3eb366f935e009af5c5bd7d"></p><p>区别:</p><p><code>on click</code> 方式添加多个同名事件会被覆盖，<code>addEventListener</code>则不会</p><p><code>addEventListener</code></p><p>语法:</p><p>事件对象.<code>addEventListener</code>.(事件类型,事件处理函数,是否冒泡[默认为false]一般默认不写),第三个参数将会在下面的事件流中介绍到</p><p><strong>事件三要素:</strong></p><p>1.事件源 —–谁被触发了</p><p>2.事件类型 —–在什么情况下被触发</p><p>3.事件处理函数 —–触发之后干了什么</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>为了正确处理事件，我们需要更深入地了解发生了什么。不仅仅是 “<code>click</code>” 或 “<code>keydown</code>”，还包括鼠标指针的坐标是什么？按下了哪个键？等等</p><p>当事件发生时，浏览器会创建一个 <strong><code>event</code> 对象</strong>，将详细信息放入其中，并将其作为参数传递给处理程序</p><p>既然是一个对象那么它就有一些属性,其中比较常用的有<code>key</code>属性和<code>target</code>属性</p><p><code>e.key</code>获取到用户输入的案件信息是回车还是空格啊</p><p>一般会用在判断用户按下的是不是回车键来进行执行指定的操作,比如说发布评论或是发送消息以及登录操作等等</p><p><code>e.target</code>这个属性获取到的是触发事件的元素,也就是事件源</p><h2 id="环境对象this"><a href="#环境对象this" class="headerlink" title="环境对象this"></a>环境对象this</h2><p>简单的理解,在普通函数中,谁调用函数, this 就指向谁,在全局环境中<br>window 对象,是浏览器的顶级对象,在全局执行 js,全局所有的东西都属于window,</p><p>小总结:</p><p>在全局中this的指向全局对象window对象</p><p>在普通函数中this指向调用者</p><p>构造函数中this指向新创建的对象</p><p>箭头函数有自己固定的this指向会继续沿用上一层作用域中的this指向</p><p>也可以通过call band apply改变this的指向</p><h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><p>页面加载事件</p><p><strong><code>load</code></strong> 事件在整个页面及所有依赖资源如样式表和图片都已完成加载时触发</p><p>当页面完全加载后在控制台打印一段信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;页面已经加载完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>页面滚动事件</p><p>由于 <code>scroll</code> 事件可被高频触发，事件处理程序不应该执行高性能消耗的操作，如 DOM 操作。而更推荐的做法是使用 <code>setTimeout</code>或是使用<code>lodash</code>来进行节流,减少事件触发频率,提高性能</p><p>页面尺寸事件</p><p>页面窗口调整大小时会触发 <strong><code>resize</code></strong> 事件</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件传播的三个阶段:</p><ol><li><p>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</p></li><li><p>目标阶段（Target phase）—— 事件到达目标元素。</p></li><li><p>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307202331649.png" alt="image-20230720230606149" style="zoom:80%;" /></li></ol><p>事件捕获</p><p>也就是说：点击 <code>&lt;td&gt;</code>，事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序。</p><p>事件冒泡</p><p>冒泡（bubbling）原理很简单。</p><p><strong>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</strong></p><p>假设我们有 3 层嵌套 <code>box &gt; father &gt; son</code>，它们各自拥有一个处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        box</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            father</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>son<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 点击事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> father = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.father&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">const</span> son = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.son&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        son.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&#x27;我是儿子&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        father.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&#x27;我是父盒子&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&#x27;我是最外面的盒子&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>点击内部的 <code>son</code> 会首先会执行点击事件：</p><ol><li>在该 <code>son</code> 上的。</li><li>然后是外部 <code>father</code> 上的。</li><li>然后是外部 <code>box</code> 上的。</li><li>以此类推，直到最后的 <code>document</code> 对象。</li></ol><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307202331114.png" alt="image-20230720224845147" style="zoom:80%;" /><p>因此，如果我们点击 <code>son</code>，那么我们将看到 3 个 alert：<code>son</code>→ <code>father</code> → <code>box</code>。</p><p>这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，就像在水里的气泡一样。</p><p>阻止冒泡</p><p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 <code>document</code> 对象，有些事件甚至会到达 <code>window</code>，它们会调用路径上所有的处理程序。</p><p>但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。</p><p>用于停止冒泡的方法是 <code>event.stopPropagation()</code>。</p><p>依旧使用上面的案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">son.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我是儿子&#x27;</span>)</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">&#125;)</span><br><span class="line">father.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我是父盒子&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;我是最外面的盒子&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们给里面的盒子添加了一个阻止冒泡,这样点击son盒子就只会弹出我是儿子,只是停止了传播,并不是阻止了所有的事件,点击在父盒子和外面的盒子上依旧是会有弹出框的</p><p>事件委托(事件委托,事件代理)</p><p>事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；</p><p>一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。</p><p>举个例子，比如一个宿舍的同学同时快递到了，一种方法就是他们都傻傻地一个个去领取，还有一种方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个宿舍同学；</p><p>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM 元素，而出去统一领取快递的宿舍长就是代理的元素，所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个。</p><p>优点</p><p>减少内存消耗</p><p>试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；</p><p>因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件的时候再去匹配判断目标元素；</p><p>所以事件委托可以减少大量的内存消耗，节约效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">tarName</span> === <span class="string">&#x27;LI&#x27;</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的flex布局</title>
      <link href="/2023/07/09/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2023/07/09/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Flex-布局是什么？"><a href="#Flex-布局是什么？" class="headerlink" title="Flex 布局是什么？"></a>Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79a941eb484d4a589501e28b3ffb00aa~tplv-k3u1fbpfcp-watermark.image" alt="flex布局盒子.png"></p><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="Flex-容器："><a href="#Flex-容器：" class="headerlink" title="Flex 容器："></a>Flex 容器：</h2><p>首先，实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></p><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p><strong>1. flex-direction: 决定主轴的方向(即项目的排列方向)</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：row，主轴为水平方向，起点在左端。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/571fd599bc2f45fd94af0ec39c9e7a07~tplv-k3u1fbpfcp-watermark.image" alt="v2-ae8828b8b022dc6f1b28d5b4f7082e91_720w.png"></p><p>row-reverse：主轴为水平方向，起点在右端</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49782da14c6e40ae853ff34740ec3636~tplv-k3u1fbpfcp-watermark.image" alt="v2-215c8626ac95e97834eddb552cfa148a_720w.png"><br>column：主轴为垂直方向，起点在上沿</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b571246d2a98492790bac52528ea47ad~tplv-k3u1fbpfcp-watermark.image" alt="v2-33efe75d166a47588e0174d0830eb020_720w.png"><br>column-reverse：主轴为垂直方向，起点在下沿</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2764f5bddf0b4b52ba8f9df06b386f9e~tplv-k3u1fbpfcp-watermark.image" alt="v2-344757e0fb7eee11e75b127b8485e679_720w.png"></p><p><strong>2. flex-wrap: 决定容器内项目是否可换行</strong></p><p>默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之进行挤压排列不会换行<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/575acd77b3954e89ae832b65c903a506~tplv-k3u1fbpfcp-watermark.image" alt="v2-a590927ad6d83de8840d52a0cf2f0df3_720w.png"></p><p>wrap：项目主轴总尺寸超出容器时换行，第一行在上方</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc232f63c6d4ea196b82efb7af4010c~tplv-k3u1fbpfcp-watermark.image" alt="v2-426949b061e8179aab00cacda8168651_720w.png"></p><p>wrap-reverse：换行，第一行在下方</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33210a854fb04691a3a9d56c3cdf3998~tplv-k3u1fbpfcp-watermark.image" alt="v2-91c53ebf744814e1ab60267643866439_720w.png"></p><p><strong>3. flex-flow: flex-direction 和 flex-wrap 的简写形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为: row nowrap，感觉没什么卵用，老老实实分开写就好了。这样就不用记住这个属性了。</p><p><strong>4. justify-content：定义了项目在主轴的对齐方式。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around | space-evely;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值: flex-start 左对齐</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe7bcc2c8c914e35978ddc71cb1f653c~tplv-k3u1fbpfcp-watermark.image" alt="v2-1bafab80044a7ab2a6198d5937172eb0_720w.png"></p><p>center：居中</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d675af466a04f1cb9409e65992d634c~tplv-k3u1fbpfcp-watermark.image" alt="v2-dea82c75d35f532d35a52d1f9c1c762b_720w.png"></p><p>flex-end：右对齐</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/352319ae43cb4d7ca89d47d272385e01~tplv-k3u1fbpfcp-watermark.image" alt="v2-8b163809a4c944486a127a7c22eee7b2_720w.png"></p><p>space-between：两端对齐，项目之间的间隔相等，即剩余空间均等分配</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6314c2c7316a48d58a1916b86b8de678~tplv-k3u1fbpfcp-watermark.image" alt="v2-ea4061e0f64dd8d7a1fcb5b0ad6f96a8_720w.png"></p><p>space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍(1:2排列)</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e0b96be9f3c45e68ce9fd9ca12848bb~tplv-k3u1fbpfcp-watermark.image" alt="v2-42a358111a221ff52768bdd55238eb0c_720w.png"></p><p>space-evely:所有项目之间均等分配空间 1:1排列</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d18cace54064b70888165d92c3b7d7d~tplv-k3u1fbpfcp-watermark.image" alt="FireShot Capture 008 - Document - 127.0.0.1.png"></p><p><strong>5. align-items: 定义了项目在交叉轴上的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为 stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0814d3654e71453ab02d1169f16a4300~tplv-k3u1fbpfcp-watermark.image" alt="v2-0cced8789b0d73edf0844aaa3a08926d_720w.png"></p><p>假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。</p><p>flex-start：交叉轴的起点对齐</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c34807a7ea4c4359a21f7848befa81be~tplv-k3u1fbpfcp-watermark.image" alt="v2-26d9e85039beedd78e412459bd436e8a_720w.png"></p><p>假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如上图显示。</p><p>flex-end：交叉轴的终点对齐</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5b3ea4983f6485c8f0c707f1d5067da~tplv-k3u1fbpfcp-watermark.image" alt="v2-8b65ee47605a48ad2947b9ef4e4b01b3_720w.png"></p><p>center：交叉轴的中点对齐</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07dde568743f4166a17911cc4da364a9~tplv-k3u1fbpfcp-watermark.image" alt="v2-7bb9d8385273d8ad469605480f40f8f2_720w.png"></p><p>baseline: 项目的第一行文字的基线对齐</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ad13c16cfcc4712abf5b918828759c3~tplv-k3u1fbpfcp-watermark.image" alt="v2-abf7ac4776302ad078986f7cd0dddaee_720w.png"><br>以文字的底部为主，仔细看图可以理解。</p><p><strong>6. align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个这样理解：</p><p>当你 flex-wrap 设置为 nowrap 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 flex-wrap 设置为 wrap 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><p>默认值为 stretch，看下面的图就很好理解了</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb55e131002e43aea8c2161f4abdc805~tplv-k3u1fbpfcp-watermark.image" alt="v2-c284017b4b8b731bc213cd1caab514e5_720w.png"></p><p>从图可以看出又三条轴线(因为容器宽度有限)，当值为 stretch 时会三条轴线平分容器的垂直方向上的空间。</p><p>值得注意的是，虽然在每条轴线上项目的默认值也为 stretch，但是由于我每个项目我都设置了高度，所以它并没有撑开整个容器。如果项目不设置高度的话就会变成下面这样：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479e9fbd5a0c474f95a6c09368e65dbc~tplv-k3u1fbpfcp-watermark.image" alt="v2-2d5feceece695fb84fd650fc49164bd6_720w.png"></p><p>这个我在前面也有提到(align-items)，这里重点还是理解三条轴线会平分垂直轴上的空间。</p><p>flex-start：轴线全部在交叉轴上的起点对齐</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71a92520d7724dc4ba72c8252b80b7d4~tplv-k3u1fbpfcp-watermark.image" alt="v2-61d92d7dc68e3d7d415a16830050fd11_720w.png"></p><p>flex-end：轴线全部在交叉轴上的终点对齐</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a63a45da880a425faff63c99b944144f~tplv-k3u1fbpfcp-watermark.image" alt="v2-0a0a7f10c50596aade787ae11b7b0a75_720w.png"></p><p>center：轴线全部在交叉轴上的中间对齐</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/687317de32fa4124a91f3bf451dc3004~tplv-k3u1fbpfcp-watermark.image" alt="v2-dcf53fce8dbcde7da9c677dd1a033860_720w.png"></p><p>space-between：轴线两端对齐，之间的间隔相等，即剩余空间等分成间隙。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9f580e3b1814d5b90bd2b9e45172920~tplv-k3u1fbpfcp-watermark.image" alt="v2-d80940f71e1e08d45d3d6df4c5401d0d_720w.png"></p><p>space-around：每个轴线两侧的间隔相等，所以轴线之间的间隔比轴线与边缘的间隔大一倍。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f1581383759428793426ee36ad75f98~tplv-k3u1fbpfcp-watermark.image" alt="v2-7c4d5c01f3851a3cec7f8487c6edb21d_720w.png"></p><p>到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item 上的属性。</p><h2 id="Flex-项目属性："><a href="#Flex-项目属性：" class="headerlink" title="Flex 项目属性："></a>Flex 项目属性：</h2><p>有六种属性可运用在 item 项目上：</p><ol><li>order</li><li>flex-basis</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ol><p><strong>1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: 数字;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4a406a1702431383ca505c8f17e1f2~tplv-k3u1fbpfcp-watermark.image" alt="order属性.png"></p><p>在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。</p><p><strong>2. flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值：auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。  </p><p><strong>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</strong></p><ul><li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li><li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li></ul><p><strong>3 flex-grow: 定义项目的放大比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值为 0，即如果存在剩余空间，也不放大</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4589ab8dd7a426f94e3051628d8cd15~tplv-k3u1fbpfcp-watermark.image" alt="flex-grow属性.png"></p><p>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。</p><p>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p><p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。  </p><p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p><p><strong>4. flex-shrink: 定义了项目的缩小比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/244c645c61de4b189313c3503e18cb1b~tplv-k3u1fbpfcp-watermark.image" alt="flex-shrink属性.png"></p><p>这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。</p><p>同理可得：</p><p>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。  </p><p>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。  </p><p><strong>5. flex: flex-grow, flex-shrink 和 flex-basis的简写</strong>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。</p><p>有关快捷值：auto (1 1 auto) 和 none (0 0 auto)  </p><p>关于 flex 取值，还有许多特殊的情况，可以按以下来进行划分：</p><ul><li>当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">1</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 flex 取值为 0 时，对应的三个值分别为 0 1 0%</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;<span class="attribute">flex</span>: <span class="number">0%</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;<span class="attribute">flex</span>: <span class="number">24px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">2</span> <span class="number">3</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">0%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;<span class="attribute">flex</span>: <span class="number">11</span> <span class="number">32px</span>;&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">11</span>;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">flex-basis</span>: <span class="number">32px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议优先使用这个属性，而不是单独写三个分离的属性。  </p><p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。  </p><p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加到各个子元素上。</p><p><strong>6. align-self: 允许单个项目有与其他项目不一样的对齐方式</strong></p><p>单个项目覆盖 align-items 定义的属性</p><p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟 align-items 属性是一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20d4322428004f3cb42991e9b8a19baa~tplv-k3u1fbpfcp-watermark.image" alt="v2-2516cddfbbabaef96fd6dfab4eb71757_720w.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么0.1+0.2≠0.3</title>
      <link href="/2023/07/09/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%E4%B8%8D%E7%AD%89%E4%BA%8E0.3/"/>
      <url>/2023/07/09/%E4%B8%BA%E4%BB%80%E4%B9%880.1+0.2%E4%B8%8D%E7%AD%89%E4%BA%8E0.3/</url>
      
        <content type="html"><![CDATA[<p>在计算机中大家都知道数据都是以二进制的形式进行存储的,所有的数字都被转换成了一串数字0和1</p><h2 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h2><p>十进制转换二进制的方法相信大家都熟能生巧了,如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，我们一起来回忆一下。</p><p>对于大于1的十进制采用的是<strong>除2取余</strong>,比如数字8转二进制过程如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307091155693.png" alt="Snipaste_2023-07-09_11-42-49.png"></p><p>而对于小于1十进制小数转为二进制则采用的是<strong>乘2取整法</strong>,将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307091155672.png" alt="Snipaste_2023-07-09_00-31-08.png"></p><p>如果我们用相同的方式，来把 <code>0.1</code> 转换成二进制，过程如下：</p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/c4b585f1614f4821b22119a32e1b406a~tplv-k3u1fbpfcp-zoom-1.image" alt="2023-07-09_003442" style="zoom: 50%;"><p>可以发现，0.1 的二进制表示是无限循环的。</p><p>由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况。</p><h2 id="计算机是如何存储二进制小数的"><a href="#计算机是如何存储二进制小数的" class="headerlink" title="计算机是如何存储二进制小数的?"></a>计算机是如何存储二进制小数的?</h2><p>计算机存储小数的采用的是<strong>浮点数</strong>,通俗的理解「浮点」表示小数点是可以浮动的</p><p>比如 <code>1000.101</code> 这个二进制数，可以表示成 <code>1.000101 x 2^3</code>，类似于数学上的科学记数法</p><p>可能有的同学距离初中时期已经非常久远了,可能已经忘了什么是科学记数法,我们来复习一下</p><p>比如有个很大的十进制数 1230000，我们可以也可以表示成 <code>1.23 x 10^6</code>，这种方式就称为科学记数法</p><p>该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为<strong>规格化</strong>，比如 <code>1.0 x 10^(-9)</code> 是规格化的科学记数法，而 <code>0.1 x 10^(-9)</code> 和 <code>10.0 x 10^(-9)</code> 就不是了</p><p>因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。</p><p>所以通常将 <code>1000.101</code> 这种二进制数，规格化表示成 <code>1.000101 x 2^3</code>，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息：</p><ul><li><code>000101</code> 称为<strong>尾数</strong>，即小数点后面的数字；</li><li><code>3</code> 称为<strong>指数</strong>，指定了小数点在数据中的位置；</li></ul><p>现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307091155502.webp" alt="IEEE标准"></p><p>这三个重要部分的意义如下：</p><ul><li><em>符号位</em>：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li><em>指数位</em>：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，<strong>指数位的长度越长则数值的表达范围就越大</strong>；</li><li><em>尾数位</em>：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且<strong>尾数的长度决定了这个数的精度</strong>，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li></ul><p>用 <code>32</code> 位来表示的浮点数，则称为<strong>单精度浮点数</strong>，也就是我们编程语言中的 <code>float</code> 变量，而用 <code>64</code> 位来表示的浮点数，称为<strong>双精度浮点数</strong>，也就是 <code>double</code> 变量，它们的结构如下：</p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/aaf861e7cc6842a5bcaac230339238d9~tplv-k3u1fbpfcp-zoom-1.image" alt="float" style="zoom: 67%;"><ul><li>double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 <code>log10(2^53)</code> 约等于 <code>15.95</code> 和 <code>log10(2^24)</code> 约等于 <code>7.22</code> 位，因此 double 的有效数字是 <code>15~16</code> 位，float 的有效数字是 <code>7~8</code> 位，这些有效位是包含整数部分和小数部分；</li><li>double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；</li></ul><p>那二进制小数，是如何转换成二进制浮点数的呢？</p><p>我们就以 <code>10.625</code> 作为例子，看看这个数字在 float 里是如何存储的</p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/7548333ec69c4f728277badf7dab2444~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230709105220726" style="zoom:67%;"><p>首先，我们计算出 10.625 的二进制小数为 1010.101。</p><p>然后<strong>把小数点，移动到第一个有效数字后面</strong>，即将 1010.101 右移 <code>3</code> 位成 <code>1.010101</code>，右移 3 位就代表 +3，左移 3 位就是 -3。</p><p><strong>float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，加3后就是指数位的值了</strong>，即指数位这 8 位存的是 <code>10000010</code>（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。</p><p><code>1.010101</code> 这个数的<strong>小数点右侧的数字就是 float 里的「尾数位」</strong>，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 <code>01010100000000000000000</code>。</p><p><strong>在算指数的时候，你可能会有疑问为什么要加上偏移量呢？</strong></p><p>前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成<strong>无符号整数</strong>。</p><p>float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 <code>-126 ~ +127</code>，于是为了把指数转换成无符号整数，就要加个<strong>偏移量</strong>，比如 float 的指数偏移量是 <code>127</code>，这样指数就不会出现负数了。</p><p>比如，指数如果是 8，则实际存储的指数是 8 + 127（偏移量）&#x3D; 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。</p><p>细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里。</p><p>这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，<strong>既然这一位永远都是 1，那就可以不用存起来了</strong>。</p><p>于是就让 23 位尾数只存储小数部分，然后在计算时会<strong>自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点</strong>。</p><p>那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307091155479.webp" alt="float公式"></p><p>举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/0ff8f00caa6c471381ef856c2e4ef22d~tplv-k3u1fbpfcp-watermark.image" alt="float转二进制例子.png"></p><p>搞清楚了计算机是如何存储小数的我们就来看看0.1和0.2转为二进制到底是多少?</p><p>0.1 的二进制浮点数转换成十进制的结果是 <code>0.100000001490116119384765625</code>：</p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202307091155707.webp" alt="0.1浮点数转二进制小数" style="zoom: 67%;"><p>0.2 的二进制浮点数转换成十进制的结果是 <code>0.20000000298023223876953125</code>：</p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/e8f30c09a2e54c6c8ed0af4602b9944c~tplv-k3u1fbpfcp-zoom-1.image" alt="0.2浮点数转换" style="zoom: 67%;"><p>这两个结果相加就是 <code>0.300000004470348358154296875</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/5842b8b7ce4b4959b258d74e2e4750b2~tplv-k3u1fbpfcp-zoom-1.image" alt="0.1+0.2">!]</p><p>所以，你会看到<strong>在计算机中 0.1 + 0.2 并不等于完整的 0.3</strong>。</p><p>这主要是<strong>因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数</strong>。</p><p>我们在 JavaScript 里执行 0.1 + 0.2，你会得到下面这个结果：</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/990fad28e5b344dd975517c461a1aac3~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230709113009348"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>我们检查 <code>0.1</code> 和 <code>0.2</code> 的总和是否为 <code>0.3</code>，我们会得到 <code>false</code></p><p>我擦！想象一下，你创建了一个电子购物网站，如果访问者将价格为 <code>¥ 0.10</code> 和 <code>¥ 0.20</code> 的商品放入了他的购物车。订单总额将是 <code>¥ 0.30000000000000004</code>。这会让任何人感到惊讶</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最可靠的方法是借助方法 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 对结果进行舍入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="title function_">alert</span>( sum.<span class="title function_">toFixed</span>(<span class="number">2</span>) ); <span class="comment">// &quot;0.30&quot;</span></span><br></pre></td></tr></table></figure><p>请注意，<code>toFixed</code> 总是返回一个字符串。它确保小数点后有 2 位数字。如果我们有一个电子购物网站，并需要显示 <code>¥ 0.30</code>，这实际上很方便。对于其他情况，我们可以使用一元加号将其强制转换为一个数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="title function_">alert</span>( +sum.<span class="title function_">toFixed</span>(<span class="number">2</span>) ); <span class="comment">// 0.3</span></span><br></pre></td></tr></table></figure><p>我们可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少，但仍然可以在除法中得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( (<span class="number">0.1</span> * <span class="number">10</span> + <span class="number">0.2</span> * <span class="number">10</span>) / <span class="number">10</span> ); <span class="comment">// 0.3</span></span><br><span class="line"><span class="title function_">alert</span>( (<span class="number">0.28</span> * <span class="number">100</span> + <span class="number">0.14</span> * <span class="number">100</span>) / <span class="number">100</span>); <span class="comment">// 0.4200000000000001</span></span><br></pre></td></tr></table></figure><p>因此，乘&#x2F;除法可以减少误差，但不能完全消除误差</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>十进制小数怎么转成二进制？</p></blockquote><p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p><blockquote><p>计算机是怎么存小数的？</p></blockquote><p>计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：</p><ul><li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li><li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li></ul><p>用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。</p><blockquote><p>0.1 + 0.2 &#x3D;&#x3D; 0.3 吗？</p></blockquote><p>不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （以0011为循环节无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p><p>因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。</p><p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alist网盘挂载</title>
      <link href="/2023/07/05/Alist%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/"/>
      <url>/2023/07/05/Alist%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>想必大家有听说过 Alist 或者是 CloudDrive，也许有的人正在使用 </p><p>CloudDrive为一款网盘挂载软件，利用它将网盘映射到本地，实现最高画质访问我们的视频文件。对小白比较好，也比较方便。但是 <img src="/./assets/53e5517e85234fd09eaf7b25c215ec1f~tplv-k3u1fbpfcp-zoom-1.image"></p><p> 也遇到了一些问题</p><ul><li>挂载不是很稳定，有时会掉线</li><li>软件并未开源，所有的用户数据全部上传到了作者的云上，介意个人隐私不敢再用了</li><li>后台占用率不低，对低配机不是很友好<img src="/./assets/fd07ed33f84942b0a55f80d1e3b0bb61~tplv-k3u1fbpfcp-zoom-1.image"></li></ul><p>Alist+RaiDrive可以完美解决这个问题<img src="/./assets/60dc37779d4f4d6abc0a2b55543f5ade~tplv-k3u1fbpfcp-zoom-1.image"></p><p> （我自己平时在资源网站上找到的一些什么PS,PR教程的素材就可以直接到挂载到本地的网盘里去拿素材，不用下载到本地十分的方便）</p><p><img src="/./assets/d9b1770e6bd2442783d6a8aaf7a0c544~tplv-k3u1fbpfcp-zoom-1.image"> </p><p>始于2020年底的开源项目AList，在经过了2年的完善优化，可以称得上是CloudDrive完全替代品<br>在Github上目前拥过20k的star，还有专门的中文官网：<a href="https://alist.nn.ci/zh/" title="Home | AList文档">Home | AList文档</a><br>中文讨论论坛：<a href="https://github.com/alist-org/alist/discussions" title="https://github.com/alist-org/alist/discussions">https://github.com/alist-org/alist/discussions</a><br>可支持的网盘也十分的丰富，主流网盘全部都有<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7543c4724e5425bac4fdf6988e870a8~tplv-k3u1fbpfcp-zoom-1.image"></p><p> <img src="/./assets/2d84483522cb450bad0923c0871e067e~tplv-k3u1fbpfcp-zoom-1.png"><br>下面我来教大家如何配置</p><p><img src="/./assets/a741b360d5eb4dbab6e40102b62cea6a~tplv-k3u1fbpfcp-zoom-1.png"> </p><h2 id="下载Alist"><a href="#下载Alist" class="headerlink" title="下载Alist:"></a>下载Alist:</h2><p>进入github release界面：<a href="https://github.com/alist-org/alist/releases" title="https://github.com/alist-org/alist/releases">https://github.com/alist-org/alist/releases</a><br>点击show all assets，找到带windows的文件点击下载：<br><img src="/./assets/32e4debcad9f4010aa92c0da9c218911~tplv-k3u1fbpfcp-zoom-1.png"><br>依据电脑系统下载对应的文件<br>部署Alist:<br>下载后，将压缩包解压缩到任意目录，然后我们当前在文件管理器的路径框内，输入 cmd 并敲下回车就可以快速在命令行工具这里进入alist.exe所在目录，或者右键选择在终端打开也行<img src="/./assets/fdba35abb6204a6eb96df1f0fcf69146~tplv-k3u1fbpfcp-zoom-1.png"> </p><p><img src="/./assets/c4f50efb29c84d779897e2e8ba8317cb~tplv-k3u1fbpfcp-zoom-1.png"></p><p>启动 alist</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">alist server</span><br><span class="line">或是</span><br><span class="line">alist.exe server</span><br></pre></td></tr></table></figure><p>按下回车,这时就默认在本地的 5244 端口开启了一个服务</p><p><img src="/./assets/1cda53c0ceec421f872a03e851105e56~tplv-k3u1fbpfcp-zoom-1.png"></p><p><strong>注：窗口不能关闭，需保持在后台运行</strong></p><p><strong><img src="/./assets/ea8ae58601604f3d9575417c9ffe718e~tplv-k3u1fbpfcp-zoom-1.png"></strong><br>打开浏览器，输入<a href="http://127.0.0.1:5244/" title="http://127.0.0.1:5244/">http://127.0.0.1:5244/</a> </p><p><img src="/./assets/160f4c83aac145ea96f4b15690326c45~tplv-k3u1fbpfcp-zoom-1.png"> </p><p>登录进去之后，更改一下用户名和密码重新登陆，以免忘记密码</p><p><img src="/./assets/6d838ec01a054525983f64a352bdce37~tplv-k3u1fbpfcp-zoom-1.png"> </p><p>进去了之后，页面显示的是这样，不要慌，是因为还没有添加任何网盘<img src="/./assets/fcd0a3ef3f1f4c44bce6b1d67e7a01c5~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/1c7d3c81a3f947c6b588e3f181ef5e4a~tplv-k3u1fbpfcp-zoom-1.png"><br>下面我以百度网盘为例<br>点击页面底部的管理功能，选择存储–添加，即可添加网盘<br><img src="/./assets/054594c34e934c0abb8c4ab4d94176fe~tplv-k3u1fbpfcp-zoom-1.png"><br>其他参数照这样填写即可<br><img src="/./assets/257125a0fc614207b236462c4073b295~tplv-k3u1fbpfcp-zoom-1.png"><br>至于需要填写的刷新令牌和id在前面的中文帮助文档获取，<a href="https://alist.nn.ci/zh/guide/drivers/baidu.html" title="百度网盘 | AList文档">百度网盘 | AList文档</a> </p><p>需要挂载其他网盘也是一样,可以在这里查看对应的帮助文档<img src="/./assets/12c5f08922f0499589384e0b19c6938e~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/511d88f1f9fe4af68311716c13dcd40c~tplv-k3u1fbpfcp-zoom-1.png"><br>填写完成后，点击添加，回到主页即完成<br><img src="/./assets/66bc12c80ead47b1b399a9f83235870e~tplv-k3u1fbpfcp-zoom-1.png"><br>可以在这里上传文件，在线原画观看视频，速度很快<img src="/./assets/5c576b51f32e44009391db10575e88be~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/22afaf3253eb41709b7a30c5b85b7ae2~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/f0b0f6cc39934cacb0489f7850c4c0fe~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/708d19062f684080897bf79b3f760c4b~tplv-k3u1fbpfcp-zoom-1.png"></p><p>也可调用PotPlayer、MXplayer或其他的播放器进行播放<br>115的我就不打开给大家看了，我怕帖子没了<img src="/./assets/a1a9a1a9f9404918a87ad1f9838406e4~tplv-k3u1fbpfcp-zoom-1.png"></p><p><img src="/./assets/7d0d8cedf4ee47dea99174529491af7d~tplv-k3u1fbpfcp-zoom-1.png"></p><h2 id="用RaiDrive将Alist映射到本地"><a href="#用RaiDrive将Alist映射到本地" class="headerlink" title="用RaiDrive将Alist映射到本地"></a>用RaiDrive将Alist映射到本地</h2><p>官网链接：<a href="https://www.raidrive.com.cn/" title="https://www.raidrive.com.cn/">https://www.raidrive.com.cn/</a><br>安装好 RaiDrive 后，点击添加，选择 NAS » WebDav，然后取消掉地址选项，接着<a href="http://xn--127-0v1e343ah0a.0.0.1/" title="http://处填入127.0.0.1">http:&#x2F;&#x2F;处填入127.0.0.1</a>、端口：5244、路径：&#x2F;dav、以及账号密码（Alist的账号和密码），最后再点击连接就行了<br><img src="/./assets/92d474d10fe2404d9a1ec8bd5d2308da~tplv-k3u1fbpfcp-zoom-1.png"><br>效果图，可以在各个文件夹之间复制上传文件<img src="/./assets/3d4daf67bb8049d7b78115e8151cffe4~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/3138ab4559c7417c9bd5247fd11bc9a9~tplv-k3u1fbpfcp-zoom-1.png"> </p><h2 id="设置Alist开机自启"><a href="#设置Alist开机自启" class="headerlink" title="设置Alist开机自启"></a>设置Alist开机自启</h2><p>每次敲cmd开服务端比较麻烦，通过以下实现开机自启：<br>在 alist.exe 所在文件夹内新建一个文本文档，粘贴如下代码： </p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> ws = <span class="built_in">CreateObject</span>(<span class="string">&quot;Wscript.Shell&quot;</span>) ws.run <span class="string">&quot;alist.exe server&quot;</span>,vbhide</span><br></pre></td></tr></table></figure><p><img src="/./assets/2d7290167318498db024f7f87a3ae411~tplv-k3u1fbpfcp-zoom-1.png"></p><p>在alist.exe server前添加上Alist当前所在的目录地址<br>就是这个<br><img src="/./assets/32851e56d1d94dbc930630e8f527f372~tplv-k3u1fbpfcp-zoom-1.png"><br>添加上即可，每个人保存的位置不同，目录位置也不尽相同<br>随便起个名字，将文件夹的后缀改成vbs，并右键创建一个快捷方式<br>win11显示文件后缀看这里<img src="/./assets/92391e51c5964799a1bbcf1d5112bfd1~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/f14ec0e5192d4fe5838505d0c8109c07~tplv-k3u1fbpfcp-zoom-1.png"><br>把这个勾取消掉<br>按住win+r，在窗口里输入shell:startup并回车，将快捷方式粘贴到打开的文件夹之中<br><img src="/./assets/27921724bf4f404ba7b9d928b8ae8ae6~tplv-k3u1fbpfcp-zoom-1.png"><br>Alist 开机启动与后台隐藏运行就设置好了</p><p><img src="/./assets/1f6559c782a54f09bad8cfa83e57f61e~tplv-k3u1fbpfcp-zoom-1.png"> </p><h2 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问:"></a>局域网访问:</h2><p>如果是PC端部署，其他设备处于同一局域网想访问，需要把上述的 <a href="http://127.0.0.1:5244/" title="http://127.0.0.1:5244中的127.0.0.1">http://127.0.0.1:5244中的127.0.0.1</a>替换为局域网IP。局域网IP的查询办法是WIN+R输入cmd运行命令窗口，然后输入ipconfig即可查看到ipv4地址<br>在手机端可以用es文件浏览器（Android和iOS均可）里的webdav连接到电脑上的Alist进行访问和观看 </p><p><img src="/./assets/de9b8fcb75ee4afea876e6779387e733~tplv-k3u1fbpfcp-zoom-1.png"><br>上传速度也不慢<br>也可直接在es文件浏览器登陆百度网盘的账号<br>里面的视频可实现倍速播放<br>手机端的百度网盘上传个视频都要开会员，你是真行啊！百度<img src="/./assets/1435ca0398f744708ecf92513463c3cb~tplv-k3u1fbpfcp-zoom-1.png"><br><img src="/./assets/cfa262bd0f354eb7bf23a71c5c570905~tplv-k3u1fbpfcp-zoom-1.png"><br>在前面的中文文档里也有很多其他网盘的存储教程，大家可自行探索<br>好了，本教程施工完毕，希望大家食用愉快！<img src="/./assets/bf5b8cefcac34ef1bed90c5f16986ee8~tplv-k3u1fbpfcp-zoom-1.png"> </p><p>想要挂载不限速的阿里云盘，驱动选择<strong>阿里云盘开放平台</strong>，使用的是官方授权的API，原阿里云盘驱动已失效，帮助文档内有详细教程 </p><p><img src="/./assets/f00ed17c4a2f4d8b913f2d3ec3387d5d~tplv-k3u1fbpfcp-zoom-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css盒子居中方法总结</title>
      <link href="/2023/07/05/css%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/05/css%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="使用margin"><a href="#使用margin" class="headerlink" title="使用margin"></a>使用margin</h3><p>利用外边距将子盒子挤到大盒子的中间位置</p><p>缺点是大盒子的大小变化了,子盒子就无法实现居中,需要计算同步修改子盒子的外边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-位移-translate-定位-position"><a href="#方法二-位移-translate-定位-position" class="headerlink" title="方法二:位移 translate + 定位 position"></a>方法二:位移 translate + 定位 position</h2><p><strong>定位移动的距离参考的父级的大小</strong></p><p><strong>位移移动参考的距离是自己自身的大小</strong></p><p>利用父相子绝,向右位移50%,向下位移50%,因为定位参考的大小是父级,这时就会超出了</p><p>向上反方向位移自身大小的50%这时子盒子就会居中显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>); //移动的是相较于自身的<span class="number">50%</span>,水平向右为正方向，垂直向下为正方向,为正值,同理负值为反方向</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="方法三-flex弹性盒子布局-推荐"><a href="#方法三-flex弹性盒子布局-推荐" class="headerlink" title="方法三:flex弹性盒子布局 推荐"></a>方法三:flex弹性盒子布局 推荐</h2><p>利用flex布局就非常的简单轻松</p><p>给大盒子设成弹性盒子 ,设置主轴居中<code>justify-content: center</code>和侧轴居中<code>align-items: center</code>就可以实现盒子居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法四-脱标-利用浮动-auto-自动居中"><a href="#方法四-脱标-利用浮动-auto-自动居中" class="headerlink" title="方法四: 脱标, 利用浮动 auto 自动居中"></a>方法四: 脱标, 利用浮动 auto 自动居中</h2><p>给子盒子上下左右设置为0让其脱标,再给外边距设置auto让其自适应实现自动居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法五-将子盒子转成行内块"><a href="#方法五-将子盒子转成行内块" class="headerlink" title="方法五:将子盒子转成行内块"></a>方法五:将子盒子转成行内块</h2><p>将子盒子转成行内块,利用<code>vertical-align: middle</code>属性实现居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法六-写js"><a href="#方法六-写js" class="headerlink" title="方法六:写js"></a>方法六:写js</h2><p>盒子结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;parent&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;parent&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;child&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;child&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;parent&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;parent&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;child&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;child&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> parent = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;parent&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> child = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;child&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> parentW = parent.<span class="property">offsetWidth</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> parentH = parent.<span class="property">offsetHeight</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> childW = child.<span class="property">offsetWidth</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> childH = child.<span class="property">offsetHeight</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    parent.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;relative&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    child.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;absolute&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    child.<span class="property">style</span>.<span class="property">left</span> = (parentW - childW) / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    child.<span class="property">style</span>.<span class="property">top</span> = (parentH - childH) / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 基本使用及命令</title>
      <link href="/2023/07/01/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/07/01/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制(Revision control)是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术<br>·实现跨区域多人协同开发<br>·追踪和记载一个或者多个文件的历史记录<br>·组织和保护你的源代码和文档<br>·统计工作量<br>·并行开发、提高开发效率<br>·跟踪记录整个软件的开发过程<br>·减轻开发人员的负担，节省时间，同时降低人为错误</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p><strong>svn</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上更新或上传自己的修改</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42548dee421449dcbdc0f38966ce18e2~tplv-k3u1fbpfcp-zoom-1.image" alt="svn" style="zoom:80%;"><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p><strong>git</strong></p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aa7e01fe5ca4dacbd6a0b1e7b30e41a~tplv-k3u1fbpfcp-zoom-1.image" alt="git" style="zoom:50%;"><h3 id="git与svn最主要区别"><a href="#git与svn最主要区别" class="headerlink" title="git与svn最主要区别"></a>git与svn最主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A,这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<br><strong>Git是目前世界上最先进的分布式版本控制系统</strong></p><h3 id="git历史"><a href="#git历史" class="headerlink" title="git历史"></a>git历史</h3><p>同生活中的许多伟大事物一样，Git诞生于一个极富纷争大举创新的年代<br>Linux内核开源项目有着为数众多的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存到归档的繁琐事务上(1991-2002年间)。到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。<br>到了2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权力，这就迫使Linux开源社区（特别是Linux的缔造者Linus Torvalds)基于使用BitKeeper时的经验教训，开发出自己的版本系统。也就是后来的Git!</p><p>Git是目前世界上最先进的分布式版本控制系统。</p><p>Git是免费、开源的，最初Git是为辅助Linux内核开发的，来替代BitKeeper!</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/076e6b35efe242f68bb94dd7e08700ef~tplv-k3u1fbpfcp-zoom-1.image" alt="Linus_Torvalds" style="zoom:30%;"><p align=center>Linux和Git之父林纳斯托沃兹(Linus Benedic Torvalds)1969、芬兰</p><h3 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h3><p><a href="https://git-scm.com/">git官网</a></p><p><a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝镜像下载</a></p><h3 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h3><p>pwd:显示当前所在的目录路径</p><p>Is(Il):都是列出当前目录中的所有文件，只不过ll列出的内容更为详细</p><p>touch:新建一个文件如touch index.js就会在当前目录下新建一个index.js文件</p><p>rm:删除一个文件，rm index.js就会把index.js文件删除</p><p>mkdir:新建一个目录，就是新建一个文件夹</p><p>rm -r:删除一个文件夹，rm- r  src  删除src目录</p><p>reset重新初始化终端&#x2F;清屏</p><p>clear清屏</p><p>history查看命令历史</p><p>help帮助</p><p>exit退出</p><p>#表示注释</p><h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><p>配置用户名: git config –global user.name ‘用户名’</p><p>配置邮箱 : git config –global user.email ‘邮箱’</p><p>初始化空的git版本库: git init</p><p>添加单个文件到暂存区：git add 文件名</p><p>添加目录下所有到暂存区:git add .( git add . 当前目录下所有文件添加到暂存区 add和点中间有空格哦)</p><p>将暂存区文件提交到版本库:git commit -m ‘提交的内容说明’(内容说明为空则会中止提交)</p><blockquote><p>一些小的修改无需先暂存再提交，直接git commit -am ‘提交内容说明’即可</p></blockquote><p>查看日志:git log</p><p>在一行显示简略信息: git log –oneline  </p><p>查看文件提交前后差别: git log -p 文件名 </p><p>查看单个文件名的提交日志: git log 文件名 </p><p>查看工作树、暂存区、最新提交之间的差别: git diff </p><p>查看状态: git status</p><p>版本回退: git reset –hard 版本号</p><p>查看仓库所有的操作日志 git reflog</p><p>忽略文件: .gitignore</p><p>创建分支 :git branch 分支名</p><p>查看分支 :git branch</p><p>查看本地仓库分支和远程仓库分支：git branch -a</p><p>切换分支 :git checkout 分支名</p><p>git checkout -   (连字符<code>-</code> 代替分支名也有一样的效果，更加简洁)</p><p>创建并切换到其他分支 ： git checkout -b 分支名</p><p><strong>分支合并步骤：</strong></p><p>先切换到目标分支</p><p>合并分支：git merge 需要合并的分支</p><p>以图表形式查看分支：git log –graph(更加直观)</p><p>删除分支(强制删除，慎用) git branch -d(D)</p><h3 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h3><p>查看配置：git config -l</p><p>查看本地配置  git config–system —list</p><p>全局配置：git  config–global –list</p><p>设置用户名与邮箱</p><p>git config –global user.name “用户名”</p><p>git config –global user.email “邮箱地址”</p><h3 id="git相关的配置文件"><a href="#git相关的配置文件" class="headerlink" title="git相关的配置文件"></a>git相关的配置文件</h3><p>Git\etc\gitconfig :git安装目录下的gitconfig  —system 系统级</p><p>c:\users\个人主机名\.gitconfig   只适用于当前登录用户的配置  –global全局</p><h2 id="git工作原理"><a href="#git工作原理" class="headerlink" title="git工作原理"></a>git工作原理</h2><p>工作目录(Working Directory)</p><p>暂存区(Stage&#x2F;Index)</p><p>资源库(Repositoryi或Git Directory)</p><p>远程的git仓库(Remote Directory)</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02deed8d140d48b79c766edd05365ee8~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20230615175044396" style="zoom:50%;"><p>Workspace:工作区，就是你平时存放项目代码的地方</p><p>Index&#x2F;Stage:暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p><p>Repository:仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p><p>Remote:远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p><p>git的工作流程一般是这样的：<br>1、在工作目录中添加、修改文件：<br>2、将需要进行版本管理的文件放入暂存区域：<br>3、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：</p><p>已修改(modified)</p><p>已暂存(staged)</p><p>已提交(committed)</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4845e31cb847549009fa037a3f5294~tplv-k3u1fbpfcp-zoom-1.image"></div><h3 id="git项目创建及克隆"><a href="#git项目创建及克隆" class="headerlink" title="git项目创建及克隆"></a>git项目创建及克隆</h3><p>项目初始化，新建git仓库</p><p>git init</p><p>git clone ‘远程地址’</p><p>文件四种状态</p><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上</p><p><code>Untracked</code>:未跟踪此文件在文件夹中，但并没有加入到git库，不参与版本控制.通过git add状态变为staged</p><p><code>Unmodify</code>:文件已经入库，未修改即版本库中的文件快照内容与文件夹中完全一致.这种类型的文件有两种去处，如果它被修改，而变为odified.如果使用git rm移出版本库，则成为Untracked文件</p><p><code>Modified</code>:文件已修改，仅仅是修改，并没有进行其他的操作.这个文件也有两个去处，通过git add可进入暂存staged状态，使用git checkout则丢弃修改过返回到unmodify状态，这个git checkout即从库中取出文件，覆盖当前修改！</p><p><code>Staged</code>:暂存状态.执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态，执行git reset HEAD filename取消暂存，文件状态为Modified</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>github &#x2F; gitee</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a033066ab9b4acd8229aeccd6f1a30d~tplv-k3u1fbpfcp-watermark.image" alt="git-github.png"></p><h3 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h3><p>ssh秘钥组成和作用</p><p>shh key的作用：实现本地仓库和github平台之间免登录的加密数据传输：</p><p>ssh key由两部分组成:</p><p>id_rsa (私钥作，#放于客户端的电脑中即可)<br>id_rsa.pub(私钥文件，需要配置列github平台中)</p><p>私钥加密的信息，只能通过公钥解密。公钥加密的信息，只能通过私钥解密。安全性高.</p><p>先在本机生成一个秘钥（以后也可以重新生成，重新配置）</p><p>步骤：</p><p>1,打开Git Bash</p><p>2.粘贴如下的命令</p><p>ssh-keygen-trsa-C”你注册账号的邮箱”</p><p>3.连续敲击3次回车，即可在C:1 Users\用户名文件夹.ssh目录中生成id_rsa和id_rsa.pub两个文件</p><p>4.使用记事本打开id_rsa.pub文件，复制里面的文本内容</p><p>5.粘贴配置到github-&gt;设置-&gt;ssh公钥中即可</p><h3 id="项目推送到远程仓库"><a href="#项目推送到远程仓库" class="headerlink" title="项目推送到远程仓库"></a>项目推送到远程仓库</h3><h4 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h4><p>git remote add origin ‘个人仓库地址’</p><p>删除远程仓库关联</p><p>git remote remove origin</p><p>查看远程仓库关联</p><p>git remote -v</p><h4 id="初次推送"><a href="#初次推送" class="headerlink" title="初次推送"></a>初次推送</h4><p>git push -u origin ‘master’(github默认主分支为main)</p><p>推送主分支以外的其他分支（dev ,login …..）</p><p>git push -u origin ‘dev’</p><p>初次推送完成后推送可直接 git push</p><blockquote><p>在远程仓库添加README.MD说明文件后，再次推送会失败，是因为当前分支文件和远程仓库文件不一致</p><p>更新本地仓库数据后即可，</p><p>代码合并：git push –rebase origin main</p><p>再次推送： <code>git push origin main</code></p></blockquote><h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>git clone ‘个人仓库地址’(默认拉取主分支)</p><p>克隆其他分支</p><p>方式一</p><p>git clone 远程仓库地址 -b 分支名</p><p>方式二</p><p>git checkout -b dev origin&#x2F;dev</p><p>-b 后的参数是在本地仓库新建和远程仓库一样的dev分支名</p><p>新建分支名后的参数是指定远程分支的来源</p><h4 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h4><p>初次拉取：git pull origin(仓库名) 分支名</p><p>之后拉取就直接 git pull</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+Picgo+Github搭建本地图床</title>
      <link href="/2023/07/01/typora%E7%AC%94%E8%AE%B0%E6%90%AD%E9%85%8D%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/07/01/typora%E7%AC%94%E8%AE%B0%E6%90%AD%E9%85%8D%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>typora笔记软件在插入图片时,需要图片在本地,否则图片就无法显示,有一些麻烦,但是如果搭配上图床,把图片上传到云端,就不会有这种烦恼了,只要是在有网络的情况下,就能正常显示<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/270fae821b5846389d278f4d4866fe8a~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁150.gif"></p><p>把文件发送给别人也能够正常显示<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6995eace982d4202a21cef43928d987f~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁39.gif"></p><p><a href="https://typoraio.cn/">typora官方中文地址:</a>(typora需要收费,具体修改方法请自行查询)</p><p><a href="https://github.com/Molunerfinn/Pic">picgo下载地址</a></p><h3 id="picgo下载-安装"><a href="#picgo下载-安装" class="headerlink" title="picgo下载,安装"></a>picgo下载,安装</h3><p>随意进入一个可以顺利下载的地址(以github为例)</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/435107888e6c4949becb778604caedbb~tplv-k3u1fbpfcp-watermark.image" alt="11.png"></p><p>进入assets资源区</p><p>选择与自己电脑系统相对应的安装文件</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9009e32efccd45e080a2d5c742d9efcf~tplv-k3u1fbpfcp-watermark.image" alt="12.png"></p><p>安装完成<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e3024982fbd4d8f9211c3bde67f49a7~tplv-k3u1fbpfcp-watermark.image" alt="aru-1x-1\_142.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/522b2535c74c43dbbf49218eb01240b3~tplv-k3u1fbpfcp-watermark.image" alt="13.png"><br>picgo就暂时结束了,下面我们选择github作为我们的图床,因为github能上传超过1m的图片,而gitee只能上传小于1m的图片,上传超过1m的图片需要压缩,而且需要安装node.js,非常的不人性化</p><p>关于github的注册这里就不再过多的赘述</p><h3 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fa2c55408b247caa1a2c2a2ee1d6340~tplv-k3u1fbpfcp-watermark.image" alt="245.GIF"></p><p>1.创建一个新仓库<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75966f80cf684e64b065822a2b77469e~tplv-k3u1fbpfcp-watermark.image" alt="84a47a6287fc47798503d0952b040c3a.png"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/784b3e4d8582464798050851d8e2082c~tplv-k3u1fbpfcp-watermark.image" alt="15.png"><br>    2.填写仓库名称和描述 ,必须选择public公开,否则存储的图片不能正常访问<br>    <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/091d4c47a167419a82613b622f01c162~tplv-k3u1fbpfcp-watermark.image" alt="16.png"><br>    3.进入设置进行配置<br>    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1775c74abbe14414a781dac768d20e45~tplv-k3u1fbpfcp-watermark.image" alt="20.png"></p><p>   <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d5c9f3ee3b472e959a6ae51450c556~tplv-k3u1fbpfcp-watermark.image" alt="21.png"></p><p>   <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b46e4d888fdd4a78b88d5cb1b92c81e3~tplv-k3u1fbpfcp-watermark.image" alt="22.png"></p><p>   <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4dc11ca49db4dceb907239ad4cbbdcb~tplv-k3u1fbpfcp-watermark.image" alt="23.png"></p><p>   <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b4a49192f0547938063c3ef3b15e7ac~tplv-k3u1fbpfcp-watermark.image" alt="24.png"></p><p>   最后会生成一个token令牌,因为我已经有了一个了,这里就不再演示</p><p>   <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c8f185a27d4a90aeb89d044f4ffe34~tplv-k3u1fbpfcp-watermark.image" alt="122.png"></p><p>   <strong>注意:生成的token令牌只会显示一次,请用记事本保存起来以免忘记</strong></p><p>   至此Github的配置已经完成</p><h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h3><p>   <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a7e7f6219a4231bbac1f247590c0d0~tplv-k3u1fbpfcp-watermark.image" alt="26.png"></p><p>   上面我们只是下载了picgo还没有进行配置最后我们配置一下picgo</p><p>   <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a85ec240b2f4ae382853a2b681b06ea~tplv-k3u1fbpfcp-watermark.image" alt="27.png"><br>    <strong>仓库名</strong><br>    <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c0d9919f7bc455cbdcdd7f49c6e9138~tplv-k3u1fbpfcp-watermark.image" alt="28.png"><br>    <strong>分支</strong></p><p>  默认master.从2020.10.01开始,默认分支变更为,main</p><p>   <strong>token</strong></p><p>   前面你生成的token令牌</p><p>   自定义域名</p><p><code>https://cdn.jsdelivr.net/gh/自己的github个人地址/仓库</code></p><p>   至此,typora+Github+picgo搭建图床已经全部完成</p><p>   我们可以回到typora验证一下是不是真的搭建成功了</p><p>   <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6086c01d0bd46aea0c49a88003d5587~tplv-k3u1fbpfcp-watermark.image" alt="29.png"><br>    typora显示上传成功,并且在picgo也成功看到了图片,这就表明我们已经成功搭建完成了<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20cb0df5f8684deb8454e4ffd6803e7b~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁91.gif"></p><p>   <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64776c2096c04a3881a76b977c322048~tplv-k3u1fbpfcp-watermark.image" alt="30.png"></p><blockquote><p><strong>补充:typora的图片插入默认是居中显示的</strong></p><p><strong>非常的不美观,这个也非常的简单进入对应的主题文件夹的css文件中</strong></p><p><strong>将图片的排列方式更改为 text-align:left; 靠左排列,再重启typora即可</strong></p></blockquote><p>   <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc41d01344394d21b3534dc0ef265ff4~tplv-k3u1fbpfcp-watermark.image" alt="246.PNG"><br>    分享到此结束<br>    <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27bb7664d1414463a4ab9ce62388acc7~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁49.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 奇技淫巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js基础入门</title>
      <link href="/2023/07/01/js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/01/js%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器执行JS简介"><a href="#浏览器执行JS简介" class="headerlink" title="浏览器执行JS简介"></a>浏览器执行JS简介</h2><h4 id="浏览器分成两大部分-渲染引擎和JS-引擎"><a href="#浏览器分成两大部分-渲染引擎和JS-引擎" class="headerlink" title="浏览器分成两大部分 渲染引擎和JS 引擎"></a>浏览器分成两大部分 渲染引擎和JS 引擎</h4><p>渲染引擎： 用来解析HTML与CSS,俗称内核，比如chrome浏览器的blink,老版本的webkit JS 引擎：也称为JS 解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的v8 </p><p>浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎（解释器)来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以Javascript语言归为脚本语言，会逐行解释执行</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>是一种运行在客户端（浏览器）的编程语言，可以用来创建动态更新的内容，控制多媒体，制作图像动画等交互效果</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22023a65a4cd42d899102c6261ae4841~tplv-k3u1fbpfcp-watermark.image" alt="01.png"></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ECMAScript: ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商工共同遵守的一套JS语法工业标准</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94794ab776614fad80d19ab1d1dea3fc~tplv-k3u1fbpfcp-watermark.image" alt="02.png"><br><strong>DOM—文档对象模型（Document Object Model)</strong></p><p>文档对象模型，是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作（大小，位置，颜色等）<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fef7879b6f14882bffbfb6b89ee3295~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁34.gif"></p><p><strong>BOM—浏览器对象模型（Browser Object Model)</strong></p><p>BOM 是指浏览器对象模型，他提供了独立于内容的，可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框，控制浏览器跳转，获取分辨率等<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8088d763e6b423f8826766812a40da9~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁112.gif"></p><blockquote><p>上面的对象模型会在下一篇的WebAPI进行详细的介绍</p></blockquote><h2 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h2><p>内部<code>js</code></p><p><strong><code>外部js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;努力 奋斗&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">外部js</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 内部样式 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;努力 奋斗&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;!-- 外部样式 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!--  script标签中间无需写代码，否则会被忽略！ --&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>script</code>标签中间无需写代码，否则会被忽略！</p></blockquote><p>行内<code>js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;alert(&#x27;你好,js&#x27;)&quot;</span>&gt;点击我月薪过万&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="js注释"><a href="#js注释" class="headerlink" title="js注释"></a>js注释</h2><p>单行注释 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3e6577f0eb47eea65b2bd97960a5a7~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁41.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br><span class="line"></span><br><span class="line">快捷键:ctrl+/</span><br></pre></td></tr></table></figure><p>多行注释 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3baa293fd624d4ebd903141ddca7871~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁101.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是多行注释,假装有很多的内容</span></span><br><span class="line"><span class="comment">假装有很多的内容假装有很多的内容</span></span><br><span class="line"><span class="comment">假装有很多的内容假装有很多的内容</span></span><br><span class="line"><span class="comment">假装有很多的内容假装有很多的内容 */</span></span><br><span class="line"></span><br><span class="line">快捷键:shift + alt + a 块级注释</span><br></pre></td></tr></table></figure><h2 id="输入-、输出语句"><a href="#输入-、输出语句" class="headerlink" title="输入 、输出语句"></a>输入 、输出语句</h2><h3 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h3><h4 id="弹出框语句"><a href="#弹出框语句" class="headerlink" title="弹出框语句"></a>弹出框语句</h4><p>语法: alert</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;页面弹出内容&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="控制台输出语句"><a href="#控制台输出语句" class="headerlink" title="控制台输出语句"></a>控制台输出语句</h4><p>语法:console.log</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello word!&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="页面输出-给用户展示文本-可解析标签"><a href="#页面输出-给用户展示文本-可解析标签" class="headerlink" title="页面输出(给用户展示文本,可解析标签)"></a>页面输出(给用户展示文本,可解析标签)</h4><p>语法:document.write</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;页面输出内容&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="输入语句"><a href="#输入语句" class="headerlink" title="输入语句"></a>输入语句</h3><p>输入框语句</p><p><code>prompt</code> 函数接收两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="title function_">prompt</span>(<span class="string">&#x27;title&#x27;</span>, [<span class="keyword">default</span>]);</span><br></pre></td></tr></table></figure><p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定&#x2F;取消按钮</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title</span><br></pre></td></tr></table></figure><p>显示给用户的文本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>可选的第二个参数，指定 input 框的初始值(未输入值或值为空,初始值就会生效)</p><p>举个栗子： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adb7a87b65e1460d94cc26fee78e2b65~tplv-k3u1fbpfcp-watermark.image" alt="aru-1x-3_011.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;How old are you?&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`You are <span class="subst">$&#123;age&#125;</span> years old!`</span>); <span class="comment">// You are 100 years old!</span></span><br></pre></td></tr></table></figure><p>IE 浏览器会提供默认值</p><p>第二个参数是可选的。但是如果我们不提供的话，Internet Explorer 会把 <code>&quot;undefined&quot;</code> 插入到 prompt。</p><p>我们可以在 Internet Explorer 中运行下面这行代码来看看效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="title function_">prompt</span>(<span class="string">&quot;Test&quot;</span>);</span><br></pre></td></tr></table></figure><p>所以，为了 prompt 在 IE 中有好的效果，建议始终提供第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="title function_">prompt</span>(<span class="string">&quot;Test&quot;</span>, <span class="string">&#x27;&#x27;</span>); <span class="comment">// &lt;-- for IE</span></span><br></pre></td></tr></table></figure><p>嫌麻烦的同学,可以直接忽略第二个参数,写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">prompt</span>(<span class="string">&#x27;页面输入内容&#x27;</span>)</span><br></pre></td></tr></table></figure><p>语法:<code>confirm</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">confirm</span>(<span class="string">&#x27;页面弹出的内容&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>confirm</code> 函数显示一个带有用户输入的内容以及确定和取消两个按钮的模态窗口。</p><p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code></p><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isBoss = <span class="title function_">confirm</span>(<span class="string">&quot;Are you the boss?&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>( isBoss ); <span class="comment">// 如果“确定”按钮被按下，则显示 true</span></span><br></pre></td></tr></table></figure><p>这个语法和 prompt 语法不能说一模一样,只能说是非常的神似,不过使用体验上看上去有点鸡肋<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20bf0d36278f446997a669335b911b71~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁23.gif"></p><p>上述所有方法共有两个限制：</p><p>1.模态窗口的确切位置由浏览器决定。通常在页面中心</p><p>2.窗口的确切外观也取决于浏览器。我们不能修改它</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/684760221e714bcaaee13ac1f051f9f8~tplv-k3u1fbpfcp-watermark.image" alt="99.PNG"></p><h2 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h2><p>分号<code>;</code></p><p>结束符可写可不写;(一行显示必须要加)</p><p>实际看团队要求,保证风格统一</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f24e56b5de4dc1a10a8b97c0daf379~tplv-k3u1fbpfcp-watermark.image" alt="03.png"></p><h4 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h4><p><code>typeof </code>运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用</p><p>对 <code>typeof x</code> 的调用会以字符串的形式返回数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">0</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">10n</span> <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;foo&quot;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>) <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Math</span> <span class="comment">// &quot;object&quot;  (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;  (2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> alert <span class="comment">// &quot;function&quot;  (3)</span></span><br></pre></td></tr></table></figure><blockquote><p>你可能还会遇到另一种语法：<code>typeof(x)</code>。它与 <code>typeof x</code> 相同。</p><p>简单点说：<code>typeof</code> 是一个操作符，不是一个函数。这里的括号不是 <code>typeof</code> 的一部分。它是数学运算分组的括号。</p><p>通常，这样的括号里包含的是一个数学表达式，例如 <code>(2 + 2)</code>，但这里它只包含一个参数 <code>(x)</code>。从语法上讲，它们允许在 <code>typeof</code> 运算符和其参数之间不打空格，有些人喜欢这样的风格。</p><p>有些人更喜欢用 <code>typeof(x)</code>，尽管 <code>typeof x</code> 语法更为常见。</p></blockquote><p><strong>数字型</strong><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1d192318c14afdaba9a1449ab9d19a~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁82.gif"></p><p><code>   number</code></p><p>(整数,小数,分数,负数)</p><p>作用:做数学运算</p><p>检测数据类型返回结果<code>number</code></p><p>除了常规的数字，还包括所谓的“特殊数值”也属于这种类型：<code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>。</p><p><code>Infinity</code> 代表数学概念中的 <a href="https://en.wikipedia.org/wiki/Infinity">无穷大</a> ∞。是一个比任何数字都大的特殊值。</p><p>我们可以通过除以 0 来得到它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">1</span> / <span class="number">0</span> ); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>或者在代码中直接使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="title class_">Infinity</span> ); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;not a number&quot;</span> / <span class="number">2</span> ); <span class="comment">// NaN，这样的除法是错误的</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 是粘性的。任何对 <code>NaN</code> 的进一步数学运算都会返回 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="title class_">NaN</span> + <span class="number">1</span> ); <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">3</span> * <span class="title class_">NaN</span> ); <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;not a number&quot;</span> / <span class="number">2</span> - <span class="number">1</span> ); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>所以，如果在数学表达式中有一个 <code>NaN</code>，会被传播到最终结果（只有一个例外：<code>NaN ** 0</code> 结果为 <code>1</code>,在数学运算中任何数的0次方都等于1）。</p><p><strong>字符串型</strong><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea54b011e660403697f820ca14ec34ea~tplv-k3u1fbpfcp-watermark.image" alt="{_10_245_}.png"></p><p><code>string</code></p><p>在 JavaScript 中，有三种包含字符串的方式。</p><ol><li>双引号：<code>&quot;Hello&quot;</code>.</li><li>单引号：<code>&#39;Hello&#39;</code>.</li><li>反引号：<code>Hello</code>.</li></ol><p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别</p><p>反引号是 <strong>功能扩展</strong> 引号(模版字符串)。它们允许我们通过将变量和表达式包装在 <code>$&#123;…&#125;</code> 中，来将它们嵌入到字符串中。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;李明&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入一个变量</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span> ); <span class="comment">// Hello, 李明!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入一个表达式</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">`1+1= <span class="subst">$&#123;<span class="number">1</span> + <span class="number">1</span>&#125;</span>`</span> ); <span class="comment">// 1+1=2</span></span><br></pre></td></tr></table></figure><p><code>$&#123;…&#125;</code> 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 <code>$&#123;…&#125;</code> 内放置任何东西：诸如名为 <code>name</code> 的变量，或者诸如 <code>1 + 1</code> 的算数表达式，或者其他一些更复杂的</p><p>这仅仅在反引号内有效，其他引号不允许这种嵌入。会被识别为字符串,直接输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;the result is $&#123;1 + 2&#125;&quot;</span> ); <span class="comment">// the result is $&#123;1 + 2&#125;（使用双引号则不会计算 $&#123;…&#125; 中的内容）</span></span><br></pre></td></tr></table></figure><p>作用:用来显示文字</p><p>检测数据类型返回结果<code>string</code></p><p><strong>boolean (布尔型)</strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ff0756b5984a68983ae19d06a11042~tplv-k3u1fbpfcp-watermark.image" alt="{_10_265_}.png"></p><p>真<code>true</code> 假<code>false</code></p><p>这种类型通常用于存储表示 yes 或 no 的值：<code>true</code> 意味着 “yes，正确”，<code>false</code> 意味着 “no，不正确”</p><p>作用:依据条件判断真假或是正确与不正确</p><p>检测数据类型返回结果<code>boolean</code></p><p><strong>未定义型</strong><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e8380aa65dc4b748825ce8d6591d416~tplv-k3u1fbpfcp-watermark.image" alt="{_10_324_}.png"></p><p><code>undefind</code></p><p>声明了变量但未赋值</p><p>检测数据类型返回结果<code>undefind</code></p><p><strong>空类型</strong><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4afeba3f25ec414aa0fe088ceecb7c6c~tplv-k3u1fbpfcp-watermark.image" alt="{_10_335_}.png"></p><p><code>null</code></p><p>已经赋值了,但是内容为空(毛坯房)</p><p>JavaScript 中的 <code>null</code> 仅仅是一个代表“无”、“空”或“值未知”的特殊值。</p><p>应用场景:如果一个变量里面确定存放的是对象,但是还未准备好对象,可以先放个null</p><blockquote><p>注意点:特殊的值,表示有值但是值为空</p></blockquote><p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3397f335aaa452faee318aadd52423e~tplv-k3u1fbpfcp-watermark.image" alt="04.png"></p><p><strong>数组</strong></p><p><strong>对象</strong></p><p><strong>函数</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05c526ca73dc48c7b2a76269a6956a08~tplv-k3u1fbpfcp-watermark.image" alt="180.GIF"></p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>作用:在内存中开辟空间存储数据</p><p>本质：变量是程序中申请的一块用来存放数据的空间。</p><p>类似我们酒店的房间，酒店就是内存，酒店内的一个房间就可以看作是一个变量</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed569e79368c47e2892f5c9090960bbb~tplv-k3u1fbpfcp-watermark.image" alt="变量的存储.png"></p><p><strong>一个现实生活的类比</strong></p><p>如果将变量想象成一个“数据”的盒子，盒子上有一个唯一的标注盒子名字的贴纸。这样我们能更轻松地掌握“变量”的概念。</p><p>例如，变量 <code>message</code> 可以被想象成一个标有 <code>&quot;message&quot;</code> 的盒子，盒子里面的值为 <code>&quot;Hello!&quot;</code></p><p><code>我们可以往盒子里放入任何值,</code>并且，这个盒子的值，我们想改变多少次，就可以改变多少次</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92fc9dd5b3064312a8d1a1c88a24fb21~tplv-k3u1fbpfcp-watermark.image" alt="05.png"></p><p><strong>变量的使用</strong></p><p>1.创建变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userName</span><br></pre></td></tr></table></figure><p>2.通过赋值运算符,给变量赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ueserName = <span class="string">&#x27;Jack chen&#x27;</span></span><br></pre></td></tr></table></figure><p>3.通过输出语法结合变量名进行查看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;userName&#x27;</span>)<span class="comment">//Jack chen</span></span><br></pre></td></tr></table></figure><h3 id="变量声明和赋值"><a href="#变量声明和赋值" class="headerlink" title="变量声明和赋值"></a>变量声明和赋值</h3><p><strong>声明</strong></p><p>语法:<code>let</code>+变量名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//   声明了一个年龄的变量</span></span><br><span class="line"><span class="keyword">let</span> age </span><br><span class="line"><span class="comment">// age=变量名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>赋值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   声明了一个年龄的变量</span></span><br><span class="line"><span class="keyword">let</span> age <span class="comment">//生成了一个空盒子</span></span><br><span class="line"><span class="comment">// age=变量名</span></span><br><span class="line"><span class="comment">// 给变量赋值为18</span></span><br><span class="line">age = <span class="number">18</span>  <span class="comment">//往盒子里装入一个内容为18的数字</span></span><br><span class="line"><span class="comment">// 控制台打印输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br></pre></td></tr></table></figure><blockquote><p>但是我们一般声明的同时直接赋值 (变量的初始化)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量初始化</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="变量重复声明"><a href="#变量重复声明" class="headerlink" title="变量重复声明"></a>变量重复声明</h4><p>会报错!<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77b652fd91de4f848bafde15b13d166f~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁172.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了一个age变量,里面存放了一个18的数据</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="comment">// 变量重复声明</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span></span><br><span class="line"><span class="comment">// 控制台结果输出会报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c7d31b3ae27447c97d71d8d1679b77c~tplv-k3u1fbpfcp-watermark.image" alt="07.png"></p><p>在一行中同时声明多个变量</p><p>多个变量之间用逗号<code>,</code>隔开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 同时声明多个变量</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>,uname = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看上去代码长度更短，但<strong>并不推荐这样</strong>,为了更好的可读性，请一行只声明一个变量</p><p>多行变量声明有点长，但更容易阅读：<strong>建议使用</strong><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a9fbdc3699412182e0482bf2a49460~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁52.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一些程序员采用下面的形式书写多个变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  age = <span class="number">25</span>,</span><br><span class="line">  message = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>……甚至使用“逗号在前”的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;John&#x27;</span></span><br><span class="line">  , age = <span class="number">25</span></span><br><span class="line">  , message = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>技术上讲，这些变体都有一样的效果。所以，这是个个人品味和审美方面的问题。</strong></p><p>我们还可以声明两个变量，然后将其中一个变量的数据赋值给另一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把变量 Hello 里面的字符串&#x27;Hello word&#x27; 赋值给了 message</span></span><br><span class="line">message = hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在两个变量保存着相同的数据</span></span><br><span class="line"><span class="title function_">alert</span>(hello); <span class="comment">// Hello world!</span></span><br><span class="line"><span class="title function_">alert</span>(message); <span class="comment">// Hello world!</span></span><br></pre></td></tr></table></figure><h3 id="变量更新"><a href="#变量更新" class="headerlink" title="变量更新"></a>变量更新</h3><p>步骤:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了一个message变量,里面存放了一个hello的数据</span></span><br><span class="line"><span class="keyword">let</span> message = hello</span><br><span class="line"><span class="comment">// 变量里面的数据更新为word</span></span><br><span class="line">message = word</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message);<span class="comment">//word</span></span><br></pre></td></tr></table></figure><p>当变量的值发生了改变,之前的数据就被从变量中删除了<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69cbce855d8e459282347f7bfc951432~tplv-k3u1fbpfcp-watermark.image" alt="06.png"></p><p><strong>保留关键字</strong></p><p>有一张 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords">保留字列表</a>，这张表中的保留字无法用作变量命名，因为它们被用于编程语言本身了。</p><p>比如，<code>let</code>、<code>class</code>、<code>return</code>、<code>function</code> 都被保留了。</p><h3 id="var与let区别"><a href="#var与let区别" class="headerlink" title="var与let区别!"></a>var与let区别!</h3><p>1.<code>var</code>可以先使用后声明,而let不用</p><p>2.<code>var</code>可以重复声明而let不行</p><p>3.<code>var</code>没有块级作用域,而let有,var会进行变量提升,而let不行</p><h3 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h3><p>交换操作(相当于就是重新赋值的过程)</p><p>需要一个新的临时变量名,来保存我们之前的变量</p><p>再声明一个新的变量</p><p>步骤:</p><p>1.声明一个新的临时空变量temp</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2f92a179f7c480487cf887ef8281ba4~tplv-k3u1fbpfcp-watermark.image" alt="08.png"></p><p>2.把apple的 苹果汁 倒入 temp (赋值)<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c1cb44317064952afaec4ab21e34bf5~tplv-k3u1fbpfcp-watermark.image" alt="09.png"></p><p>3.把orange橙子汁倒入 apple 杯子里面<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd3073d32c094577b5300c86027f99f1~tplv-k3u1fbpfcp-watermark.image" alt="10.png"></p><p>4.把 temp里面的苹果汁倒入 orange杯子</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec71ce903e4d448199811a0307ebb9cb~tplv-k3u1fbpfcp-watermark.image" alt="11.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个装橙汁的容器,一个装苹果汁的容器</span></span><br><span class="line">     <span class="keyword">let</span> orange = <span class="string">&#x27;橙子汁&#x27;</span></span><br><span class="line">     <span class="keyword">let</span> apple = <span class="string">&#x27;苹果汁&#x27;</span></span><br><span class="line">     <span class="comment">// 1.声明一个空临时变量</span></span><br><span class="line">     <span class="keyword">let</span> temp</span><br><span class="line">     <span class="comment">// 2.把apple赋值给空变量</span></span><br><span class="line">     temp = apple</span><br><span class="line">     <span class="comment">// 3.把orange赋值给apple</span></span><br><span class="line">     apple = orange</span><br><span class="line">     <span class="comment">// 4.temp的值给orange</span></span><br><span class="line">     orange = temp</span><br></pre></td></tr></table></figure><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f16cecb23b4040509b5a6d98ed26e2d3~tplv-k3u1fbpfcp-watermark.image" alt="哈哈哈.png"></p><p>规则:</p><p>不能用关键字</p><p>关键字：有特殊含义的字符，JavaScript 内置的一些英语词汇。即上面提到的保留关键字</p><p><strong>只能用下划线、字母、数字、$组成，且数字不能开头</strong></p><p>字母严格区分大小写，如 Age 和 age 是不同的变量</p><p>规范:</p><p>起名要有意义，见名知意(语义化)<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/556206c1d80a40a6a9d4ff961ea9807c~tplv-k3u1fbpfcp-watermark.image" alt="face014.jpg"></p><p>遵守<strong>小驼峰命名法</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbfe5d607fe34793873197520e384dfc~tplv-k3u1fbpfcp-watermark.image" alt="驼峰命名法.png"></p><p>第一个单词首字母小写，后面每个单词首字母大写。例：<code>userName</code></p><h2 id="正确命名变量"><a href="#正确命名变量" class="headerlink" title="正确命名变量"></a>正确命名变量</h2><p>一个变量名应该有一个清晰、明显的含义，对其存储的数据进行描述。</p><p>变量命名是编程过程中最重要且最复杂的技能之一。快速地浏览变量的命名就知道代码是一个初学者还是有经验的开发者写的。</p><p>在一个实际项目中，大多数的时间都被用来修改和扩展现有的代码库，而不是从头开始写一些完全独立的代码。当一段时间后，我们做完其他事情，重新回到我们的代码，找到命名良好的信息要容易得多。换句话说，变量要有个好名字。</p><p>声明变量之前，多花点时间思考它的更好的命名。你会受益良多。</p><p>一些可以遵循的规则：</p><ul><li>使用易读的命名，比如 <code>userName</code> 或者 <code>shoppingCart</code>。</li><li>离诸如 <code>a</code>、<code>b</code>、<code>c</code> 这种缩写和短名称远一点，除非你真的知道你在干什么。</li><li>变量名在能够准确描述变量的同时要足够简洁。不好的例子就是 <code>data</code> 和 <code>value</code>，这样的名称等于什么都没说。如果能够非常明显地从上下文知道数据和值所表达的含义，这样使用它们也是可以的。</li><li>脑海中的术语要和团队保持一致。如果网站的访客称为“用户”，则我们采用相关的变量命名，比如 <code>currentUser</code> 或者 <code>newUser</code>，而不要使用 <code>currentVisitor</code> 或者一个 <code>newManInTown</code>。</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bef38904b1d14d59abd6d0a888602863~tplv-k3u1fbpfcp-watermark.image" alt="104.PNG"></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>也是一个容器,用来保存数据,常量的值无法修改的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br></pre></td></tr></table></figure><blockquote><p>常量值无法修改,强制修改会报错</p><p>常量必须要初始化(定义时必须要进行赋值)</p><p>常量和变量的使用场景:</p><p>1.当存储无需修改的数据时使用<strong>常量</strong></p><p>2.当存储需要后期修改的数据时,应当使用<code>let</code>关键字来定义<strong>变量</strong></p></blockquote><p><strong>大写形式的常数</strong><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcc856ef53384b629c9c3a63ea0a08d1~tplv-k3u1fbpfcp-watermark.image" alt="face076.jpg"></p><p>一个普遍的做法是将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。</p><p>使用大写字母和下划线来命名这些常量。</p><p>例如，让我们以所谓的“web”（十六进制）格式为颜色声明常量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_RED</span> = <span class="string">&quot;#F00&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_GREEN</span> = <span class="string">&quot;#0F0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_BLUE</span> = <span class="string">&quot;#00F&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_ORANGE</span> = <span class="string">&quot;#FF7F00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……当我们需要选择一个颜色</span></span><br><span class="line"><span class="keyword">let</span> color = <span class="variable constant_">COLOR_ORANGE</span>;</span><br><span class="line"><span class="title function_">alert</span>(color); <span class="comment">// #FF7F00</span></span><br></pre></td></tr></table></figure><p>好处:<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f263794ebb04059930e0fddcef0c035~tplv-k3u1fbpfcp-zoom-1.image"></p><ul><li><code>COLOR_ORANGE</code> 比 <code>&quot;#FF7F00&quot;</code> 更容易记忆。</li><li>比起 <code>COLOR_ORANGE</code> 而言，<code>&quot;#FF7F00&quot;</code> 更容易输错。</li><li>阅读代码时，<code>COLOR_ORANGE</code> 比 <code>#FF7F00</code> 更易懂。</li></ul><p>什么时候该为常量使用大写命名，什么时候进行常规命名？让我们弄清楚一点。</p><p>作为一个“常数”，意味着值永远不变。但是有些常量在执行之前就已知了（比如红色的十六进制值），还有些在执行期间被“计算”出来，但初始赋值之后就不会改变。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pageLoadTime = <span class="comment">/* 网页加载所需的时间 */</span>;</span><br></pre></td></tr></table></figure><p><code>pageLoadTime</code> 的值在页面加载之前是未知的，所以采用常规命名。但是它仍然是个常量，因为赋值之后不会改变。</p><p>换句话说，大写命名的常量仅用作“硬编码（hard-coded）”值的别名。</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>什么是字面量?</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db0ccc6ae6545a3b434eb8bc4e177cc~tplv-k3u1fbpfcp-watermark.image" alt="78.PNG"></p><p>只要是能被<code>js</code>识别的数据都被称之为字面量</p><blockquote><p>字面量不是变量和常量,字面量指的是数据不是容器,所以字面量只能在赋值运算符&#x3D;右边当数据使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字字面量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">18</span>)</span><br><span class="line"><span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// 布尔字面量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 数组字面量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([])</span><br><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算术运算符:</strong></p><p><strong>加法: <code>+</code></strong></p><p><strong>减法: <code>-</code></strong></p><p><strong>乘法:<code>*</code></strong></p><p><strong>除法:<code>/</code></strong></p><p><strong>取余: <code>%</code></strong></p><p><strong>求幂:<code>**</code></strong></p><p>算数运算符作用:进行数学运算</p><p>前四个都很简单，而 <code>%</code> 和 <code>**</code> 则需要说一说。</p><p>取余运算符是 <code>%</code>，尽管它看起来很像百分数，但实际并无关联</p><p><code>a % b</code> 的结果是 <code>a</code> 整除 <code>b</code> 的余数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">5</span> % <span class="number">2</span> ); <span class="comment">// 1，5 除以 2 的余数</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">8</span> % <span class="number">3</span> ); <span class="comment">// 2，8 除以 3 的余数</span></span><br></pre></td></tr></table></figure><p>除法取余运算符 <code>% </code>应用场景</p><p>判断某个数字能否被整除</p><p>进行取余数运算时,前面一个数小于后面一个数,返回的余数则是第一个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制台打印结果为5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> % <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="求幂"><a href="#求幂" class="headerlink" title="求幂"></a>求幂</h3><p>求幂运算 <code>a ** b</code> 将 <code>a</code> 提升至 <code>a</code> 的 <code>b</code> 次幂。</p><p>在数学运算中我们将其表示为</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c85cf4645a9d408c9624613c45ca7420~tplv-k3u1fbpfcp-watermark.image" alt="QianJianTec1686760251619.png"></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">2</span> ** <span class="number">2</span> ); <span class="comment">// 2² = 4</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">2</span> ** <span class="number">3</span> ); <span class="comment">// 2³ = 8</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">2</span> ** <span class="number">4</span> ); <span class="comment">// 2⁴ = 16</span></span><br></pre></td></tr></table></figure><p>就像在数学运算中一样，幂运算也适用于非整数。</p><p>例如，平方根是指数为 ½ 的幂运算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">4</span> ** (<span class="number">1</span>/<span class="number">2</span>) ); <span class="comment">// 2（1/2 次方与平方根相同)</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">8</span> ** (<span class="number">1</span>/<span class="number">3</span>) ); <span class="comment">// 2（1/3 次方与立方根相同)</span></span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13815c36840d4283bef7175df20c36ee~tplv-k3u1fbpfcp-watermark.image" alt="QianJianTec1686760875612.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ffe5286959847259292803f69f6d2cb~tplv-k3u1fbpfcp-watermark.image" alt="QianJianTec1686760941512.png"></p><p>除了常规的数字，还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：<code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>。</p><ul><li><p><code>Infinity</code> 代表数学概念中的 <a href="https://en.wikipedia.org/wiki/Infinity">无穷大</a> ∞。是一个比任何数字都大的特殊值。</p><p>我们可以通过除以 0 来得到它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">1</span> / <span class="number">0</span> ); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>或者在代码中直接使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="title class_">Infinity</span> ); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure></li><li><p><code>NaN</code> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;not a number&quot;</span> / <span class="number">2</span> ); <span class="comment">// NaN，这样的除法是错误的</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 是粘性的。任何对 <code>NaN</code> 的进一步数学运算都会返回 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="title class_">NaN</span> + <span class="number">1</span> ); <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">3</span> * <span class="title class_">NaN</span> ); <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;not a number&quot;</span> / <span class="number">2</span> - <span class="number">1</span> ); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>所以，如果在数学表达式中有一个 <code>NaN</code>，会被传播到最终结果（只有一个例外：<code>NaN ** 0</code> 结果为 <code>1</code>）。</p></li></ul><h3 id="算术运算符优先级"><a href="#算术运算符优先级" class="headerlink" title="算术运算符优先级"></a>算术运算符优先级</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcaae7f00f48439a8f37075a5348358a~tplv-k3u1fbpfcp-watermark.image" alt="15.PNG"><br>先乘除取余,后加减,有小括号先算小括号里面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制台打印结果为NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;张三&#x27;</span> * <span class="number">5</span>);</span><br></pre></td></tr></table></figure><blockquote><p>计算错误会出现<code>NaN</code>,不属于数字,但属于数字类型</p></blockquote><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串 "></a>拼接字符串 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef035f31333c44cea5c1a754efacdde4~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁99.gif"></h4><p>` ` 反引号包含数据</p><p>${ 变量名 }</p><p><code>+</code> <strong>数字相加,字符相连</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面弹出输入数据</span></span><br><span class="line"><span class="keyword">let</span> uname = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入你的姓名&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入你的练习时长&#x27;</span>)</span><br><span class="line"><span class="comment">// 页面输出打印展示</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`大家好,我叫<span class="subst">$&#123;uname&#125;</span>,练习时长<span class="subst">$&#123;age&#125;</span>年`</span>)</span><br></pre></td></tr></table></figure><p><strong><code>$&#123;…&#125;</code> 内的表达式会被计算，计算结果会成为字符串的一部分</strong>。可以在 <code>$&#123;…&#125;</code> 内放置任何东西：诸如名为 <code>name</code> 的变量，或者诸如 <code>1 + 2</code> 的算数表达式，或者其他一些更复杂的。</p><p>需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&quot;the result is $&#123;1 + 2&#125;&quot;</span> ); <span class="comment">// the result is $&#123;1 + 2&#125;（使用双引号则不会计算 $&#123;</span></span><br></pre></td></tr></table></figure><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf8822830a5c41ad98889ea8a9905b00~tplv-k3u1fbpfcp-zoom-1.image"><p><strong>赋值运算符</strong></p><p><strong><code>+=</code></strong></p><p><strong><code>-=</code></strong></p><p><strong><code>\*=</code></strong></p><p><strong><code>/=</code></strong></p><p><strong><code>%=</code></strong></p><p>作用:是为了快速地进行赋值操作<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/204aac2505cb494f8d552ed903af2c96~tplv-k3u1fbpfcp-watermark.image" alt="aru-1x-1_152.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span></span><br><span class="line">num += <span class="number">5</span> 等价于 num = num + <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>注意点:赋值运算符,一定是把右边的值赋值给左边(变量或是常量)</p></blockquote><h4 id="链式赋值-Chaining-assignments"><a href="#链式赋值-Chaining-assignments" class="headerlink" title="链式赋值(Chaining assignments)"></a>链式赋值(Chaining assignments)</h4><p>一个有趣的特性是链式赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, c;</span><br><span class="line"></span><br><span class="line">a = b = c = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( a ); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">alert</span>( b ); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">alert</span>( c ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>链式赋值从右到左进行计算。首先，对最右边的表达式 <code>2 + 2</code> 求值，然后将其赋给左边的变量：<code>c</code>、<code>b</code> 和 <code>a</code>。最后，所有的变量共享一个值。</p><p>同样，出于可读性，最好将这种代码分成几行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">b = c;</span><br><span class="line">a = c;</span><br></pre></td></tr></table></figure><p>这样可读性更强，尤其是在快速浏览代码的时候。</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e80139a6e4e24d70aaa1855de81e5a9a~tplv-k3u1fbpfcp-zoom-1.image"></div><p><strong>自增 &#x2F; 自减运算符</strong></p><p>作用:把变量每次<strong>加一</strong>或是<strong>减一</strong></p><p>++自增</p><p>++在前,前缀式:++变量,先输出当前的值,+1在运算</p><p>--自减</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> num = <span class="number">10</span> </span><br><span class="line">   <span class="comment">// 写法一</span></span><br><span class="line">   num = num + <span class="number">1</span></span><br><span class="line"><span class="comment">//    写法二</span></span><br><span class="line">   num += <span class="number">1</span></span><br><span class="line"><span class="comment">//    写法三</span></span><br><span class="line">   num ++</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line"><span class="comment">//    最终所有结果都为11</span></span><br></pre></td></tr></table></figure><p><strong>自增&#x2F;自减只能应用于变量。试一下，将其应用于数值（比如 <code>5++</code>）则会报错</strong><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977209db51fb4b8d95df13f2c4636d80~tplv-k3u1fbpfcp-watermark.image" alt="aru-1x-1_156.png"></p><p><strong>比较运算符</strong></p><table><thead><tr><th>&lt;</th><th>大于</th></tr></thead><tbody><tr><td>&gt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>比较数值</td></tr><tr><td>&#x3D;&#x3D;&#x3D;</td><td>比较值和类型</td></tr><tr><td>!&#x3D;&#x3D;</td><td>左右两边值和类型是否不全等(有一个不满足条件)</td></tr><tr><td>!&#x3D;</td><td>左右两边是否不相等</td></tr></tbody></table><p>作用:比较两个数据之间的关系</p><p>结果:返回布尔值true &#x2F; false <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5bbee045fd4162b25bea137bc5229b~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁98.gif"></p><blockquote><p><code>===</code>比较的是<strong>值</strong>和<strong>类型</strong></p><p><code>==</code>比较的是值</p><p><code>=</code>是赋值</p></blockquote><p><strong>运算符优先级</strong></p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d1192b7a7434284ae74f85ecf15686a~tplv-k3u1fbpfcp-zoom-1.image"></div><p><strong>逻辑运算符</strong></p><p>逻辑与 <code>&amp;&amp;</code></p><p>逻辑或 <code>||</code> </p><p>逻辑非 <code>!</code></p><p><strong>作用:在<code>js</code>里需要同时判断多个条件使用</strong></p><p>返回值:布尔类型</p><p>逻辑与 <code>&amp;&amp;</code></p><p>查找规则:一假则假</p><p>逻辑与 <code>||</code></p><p>查找规则:一真则真</p><p>逻辑非 <code>!</code></p><p>查找规则:取反(真变假,假变真)</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d4c5b057c3430db52c00d0c5b5b64a~tplv-k3u1fbpfcp-zoom-1.image"></div><p><strong>案例</strong></p><p>判断一个数是否能同时被4和100整除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 用户输入</span></span><br><span class="line">    <span class="keyword">let</span> num = +<span class="title function_">prompt</span>(<span class="string">&#x27;请输入一个数进行计算:&#x27;</span>)</span><br><span class="line">    <span class="comment">// 弹出计算结果</span></span><br><span class="line">    alert (num % <span class="number">4</span> &lt;mark&gt;= <span class="number">0</span> &amp;&amp; num % <span class="number">100</span> &lt;/mark&gt;= <span class="number">0</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="空值合并运算符-‘-’"><a href="#空值合并运算符-‘-’" class="headerlink" title="空值合并运算符 ‘??’"></a>空值合并运算符 ‘??’</h3><p>空值合并运算符（nullish coalescing operator）的写法为两个问号 <code>??</code>。</p><p>由于它对待 <code>null</code> 和 <code>undefined</code> 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 <code>null</code> 也不是 <code>undefined</code> 时，我们将其称为“已定义的（defined）”。</p><p><code>a ?? b</code> 的结果是：</p><ul><li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li><li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li></ul><p>换句话说，如果第一个参数不是 <code>null/undefined</code>，则 <code>??</code> 返回第一个参数。否则，返回第二个参数。</p><p>空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。</p><p>我们可以使用我们已知的运算符重写 <code>result = a ?? b</code>，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = (a !== <span class="literal">null</span> &amp;&amp; a !== <span class="literal">undefined</span>) ? a : b;</span><br></pre></td></tr></table></figure><p><code>??</code> 的常见使用场景是提供默认值。</p><p>例如，在这里，如果 <code>user</code> 的值不为 <code>null/undefined</code> 则显示 <code>user</code>，否则显示 <code>匿名</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user; <span class="title function_">alert</span>(user ?? <span class="string">&quot;匿名&quot;</span>); <span class="comment">// 匿名（user 未定义）</span></span><br></pre></td></tr></table></figure><p>在下面这个例子中，我们将一个名字赋值给了 <code>user</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&quot;John&quot;</span>; <span class="title function_">alert</span>(user ?? <span class="string">&quot;匿名&quot;</span>); <span class="comment">// John（user 已定义）</span></span><br></pre></td></tr></table></figure><p>我们还可以使用 <code>??</code> 序列从一系列的值中选择出第一个非 <code>null/undefined</code> 的值。</p><p>假设我们在变量 <code>firstName</code>、<code>lastName</code> 或 <code>nickName</code> 中存储着一个用户的数据。如果用户决定不填写相应的值，则所有这些变量的值都可能是未定义的。</p><p>我们想使用这些变量之一显示用户名，如果这些变量的值都是 <code>null/undefined</code>，则显示 “匿名”。</p><p>让我们使用 <code>??</code> 运算符来实现这一需求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&quot;Supercoder&quot;</span>; </span><br><span class="line"><span class="comment">// 显示第一个已定义的值</span></span><br><span class="line"><span class="title function_">alert</span>(firstName ?? lastName ?? nickName ?? <span class="string">&quot;匿名&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="与-比较"><a href="#与-比较" class="headerlink" title="与||比较"></a>与<code>||</code>比较</h3><p>或运算符 <code>||</code> 可以以与 <code>??</code> 运算符相同的方式使用</p><p>例如，在上面的代码中，我们可以用 <code>||</code> 替换掉 <code>??</code>，也可以获得相同的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&quot;Supercoder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示第一个真值：</span></span><br><span class="line"><span class="title function_">alert</span>(firstName || lastName || nickName || <span class="string">&quot;Anonymous&quot;</span>); <span class="comment">// Supercoder</span></span><br></pre></td></tr></table></figure><p>纵观 JavaScript 发展史，或 <code>||</code> 运算符先于 <code>??</code> 出现。它自 JavaScript 诞生就存在了，因此开发者长期将其用于这种目的。</p><p>另一方面，空值合并运算符 <code>??</code> 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 <code>||</code> 不太满意。</p><p>它们之间重要的区别是：</p><ul><li><code>||</code> 返回第一个 <strong>真</strong> 值</li><li><code>??</code> 返回第一个 <strong>已定义的</strong> 值</li></ul><p>换句话说，<code>||</code> 无法区分 <code>false</code>、<code>0</code>、空字符串 <code>&quot;&quot;</code> 和 <code>null/undefined</code>。它们都一样 —— 假值（falsy values）。如果其中任何一个是 <code>||</code> 的第一个参数，那么我们将得到第二个参数作为结果。</p><p>不过在实际中，我们可能只想在变量的值为 <code>null/undefined</code> 时使用默认值。也就是说，当该值确实未知或未被设置时。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p><code>+</code>号两边有一个是字符串,就会把另外一个也转成字符串</p><p><code>+</code> <code>-</code> <code>*</code> <code>/</code>等算术运算符都会把数据转成数字类型</p><p><code>+</code>号作为正号解析可以转换为数字类型</p><p>任何数据和字符串拼接都是字符串</p><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换 "></a>显示转换 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d3cc3d3c02430c93a645d9932b8389~tplv-k3u1fbpfcp-watermark.image" alt="{_10_297_}.png"></h3><p>数字型</p><p><code>Number</code>(数字)</p><p>转成数字类型</p><p>若字符串内有非数字,会转换失败<code>NaN</code></p><p><code>Parseint</code>(数字)</p><p>只保留整数,不会四舍五入</p><p><code>ParseFloat</code>浮点数(数字)</p><p>可以保留小数</p><p>数字类型转换</p><p>语法<code>number</code>(其他数据类型)</p><blockquote><ol><li>number只能转换纯数字的字符串,非纯数字字符串转换结果是NaN</li><li>布尔类型转数字,true为1,false为0</li><li>null转数字类型是0</li><li>undefind转数字类型是NaN</li></ol></blockquote><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbf7f3548f274420adfd86f6ed5f62b3~tplv-k3u1fbpfcp-zoom-1.image"></div><p>其他类型转数字类型为整数</p><p>语法:<code>parselnt</code>(数据)</p><blockquote><p>数据要以数字开头保留整数,非数字开头结果是NaN</p></blockquote><p>其他类型转数字类型为小数</p><p>语法:parseFloat 浮点数(数据)</p><blockquote><p>数据要以数字开头保留小数,非数字开头结果是NaN</p></blockquote><p>字符串类型转换</p><p>其他类型转字符串</p><p><strong>方式一</strong>😀</p><p>语法:String(数据)</p><blockquote><p>可以转换null和undefined</p></blockquote><p><strong>方式二</strong></p><p>语法:变量.toString(进制)</p><blockquote><p>undefind和null这两个特殊值没有toString,不能够使用,会报错</p><p>String（）实际开发使用最多</p></blockquote><p>布尔类型转换</p><p>语法:<code>Boolean</code></p><blockquote><p>其他类型转布尔类型除了( <code>0</code> , <code>false</code> , <code>null</code> , <code>undefind</code> , <code>NaN</code> , <code>&#39;&#39;</code> )转布尔为<code>false</code>,</p><p>其他任何类型全部都是<code>true</code></p></blockquote><h3 id="隐式转换-1"><a href="#隐式转换-1" class="headerlink" title="隐式转换 "></a>隐式转换 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc4aca43e1de4110b7b7e5138fc61ef8~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁88.gif"></h3><p>通过运算符实现系统内部自动转换</p><blockquote><p>实际开发中尽量使用显示转换,隐式转换慎用</p></blockquote><blockquote><p>null与undefined的相同点与不同点</p><p>相同点:值相同,转布尔类型都是false</p><p>不同点:类型不同,转数字类型不同</p></blockquote><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/751022f1546a4e9eafdb66a70f2cc161~tplv-k3u1fbpfcp-zoom-1.image"></div><h2 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h2><p><strong>表达式:可以被求值的代码,由运算符组成的式子,最终会计算出一个结果</strong></p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p><strong>语句</strong> :一段可以执行功能的代码,是一个行为</p><p><strong>顺序语句</strong></p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2512da5d5403445497c01f55e1ea5667~tplv-k3u1fbpfcp-zoom-1.image"></div><h4 id="单分支语句"><a href="#单分支语句" class="headerlink" title="单分支语句"></a>单分支语句</h4><p>依据条件,有选择性的执行代码</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5703ae6c1dd4f7d9bb8cc5c8178b32f~tplv-k3u1fbpfcp-zoom-1.image"></div><p>当上面的if语句控制一行代码时, { } 可省略,写在一行</p><p>但是一般情况下,不推荐<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ca82a275cd8426fac446312b333bb85~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁172.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> score = +<span class="title function_">prompt</span>(<span class="string">&#x27;请您输入您的考试分数&#x27;</span>)</span><br><span class="line"><span class="comment">// if (score &gt; 700) &#123;</span></span><br><span class="line"><span class="comment">//     alert(&#x27;恭喜您考入蓝翔挖掘机高级技工学校&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>) <span class="title function_">alert</span>(<span class="string">&#x27;恭喜您考入蓝翔挖掘机高级技工学校&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="if单分支语句"><a href="#if单分支语句" class="headerlink" title="if单分支语句"></a>if单分支语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件会默认转换为布尔类型) &#123;</span><br><span class="line"></span><br><span class="line">依据条件判断是否执行</span><br><span class="line">条件为 <span class="literal">true</span> 时,会执行</span><br><span class="line">若为 <span class="literal">false</span> 时,则不会执行</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">2</span> === <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;执行的语句&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除了0所有数字都为真</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;执行的语句&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除了空&#x27;&#x27;字符串所有字符串都为真</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;执行的语句&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双分支语句"><a href="#双分支语句" class="headerlink" title="双分支语句"></a>双分支语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line"></span><br><span class="line">满足条件代码</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">未满足条件代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算平、闰年案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入年份</span></span><br><span class="line"><span class="keyword">let</span> year = +<span class="title function_">prompt</span>(<span class="string">&#x27;请输入年份:&#x27;</span>)</span><br><span class="line"><span class="comment">// 判断条件</span></span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> &lt;mark&gt;= <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> &lt;/mark&gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">prompt</span>(<span class="string">`<span class="subst">$&#123;year&#125;</span>年是闰年`</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">prompt</span>(<span class="string">`<span class="subst">$&#123;year&#125;</span>年是平年`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多分支语句"><a href="#多分支语句" class="headerlink" title="多分支语句"></a>多分支语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (条件一) &#123;</span><br><span class="line">           条件一输出结果</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (条件二) &#123;</span><br><span class="line">           条件二输出结果</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (条件三) &#123;</span><br><span class="line">           条件三输出结果</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           最终保底输出结果</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// else不一定为必写项,具体看实际要求</span></span><br></pre></td></tr></table></figure><p>成绩判断案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> score = +<span class="title function_">prompt</span>(<span class="string">&#x27;请输入您的考试成绩&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (score&gt;=<span class="number">90</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">70</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;良好&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">60</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;及格&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="基础运算符-数学运算"><a href="#基础运算符-数学运算" class="headerlink" title="基础运算符,数学运算"></a>基础运算符,数学运算</h3><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28b976623d984a86b66c97908ef9cbd9~tplv-k3u1fbpfcp-zoom-1.image"></div><h4 id="术语-’一元运算符’-’二元运算符’-运算元"><a href="#术语-’一元运算符’-’二元运算符’-运算元" class="headerlink" title="术语:’一元运算符’,’二元运算符’,运算元"></a><strong>术语:’一元运算符’,’二元运算符’,运算元</strong><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21121e453c8e41bf8292adeb53b28fdd~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁103.gif"></h4><p><strong>运算元</strong> —— 运算符应用的对象。比如说乘法运算 <code>5 * 2</code>，有两个运算元：左运算元 <code>5</code> 和右运算元 <code>2</code>。有时候人们也称其为“参数”而不是“运算元”。</p><p>如果一个运算符对应的只有一个运算元，那么它是 <strong>一元运算符</strong>。比如说一元负号运算符（unary negation）<code>-</code>，它的作用是对数字进行正负转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x = -x;</span><br><span class="line"><span class="title function_">alert</span>( x ); <span class="comment">// -1，一元负号运算符生效</span></span><br></pre></td></tr></table></figure><p>如果一个运算符拥有两个运算元，那么它是 <strong>二元运算符</strong>。减号还存在二元运算符形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">3</span>;</span><br><span class="line"><span class="title function_">alert</span>( y - x ); <span class="comment">// 2，二元运算符减号做减运算</span></span><br></pre></td></tr></table></figure><p> 严格地说，在上面的示例中，我们使用一个相同的符号表征了两个不同的运算符：负号运算符，即反转符号的一元运算符，减法运算符，是从另一个数减去一个数的二元运算符。</p><p>二元运算符 + 连接字符串</p><p>通常，加号 <code>+</code> 用于求和。</p><p>但是如果加号 <code>+</code> 被应用于字符串，它将合并（连接）各个字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;my&quot;</span> + <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(s); <span class="comment">// mystring</span></span><br></pre></td></tr></table></figure><p>注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串</p><p>举个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> ); <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">2</span> + <span class="string">&#x27;1&#x27;</span> ); <span class="comment">// &quot;21&quot;</span></span><br></pre></td></tr></table></figure><p>你看，第一个运算元和第二个运算元，哪个是字符串并不重要。</p><p>下面是一个更复杂的例子：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2110d3982cff41cb8e2d1382b4231917~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁92.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">2</span> + <span class="number">2</span> + <span class="string">&#x27;1&#x27;</span> ); <span class="comment">// &quot;41&quot;，不是 &quot;221&quot;</span></span><br></pre></td></tr></table></figure><p>在这里，运算符是按顺序工作。第一个 <code>+</code> 将两个数字相加，所以返回 <code>4</code>，然后下一个 <code>+</code> 将字符串 <code>1</code> 加入其中，所以就是 <code>4 + &#39;1&#39; = &#39;41&#39;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> + <span class="number">2</span>); <span class="comment">// &quot;122&quot;，不是 &quot;14&quot;</span></span><br></pre></td></tr></table></figure><p>这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。<code>2</code> 被与 <code>&#39;1&#39;</code> 连接到了一起，也就是像 <code>&#39;1&#39; + 2 = &quot;12&quot;</code> 然后 <code>&quot;12&quot; + 2 = &quot;122&quot;</code> 这样</p><p>是不是看这些文字理解起来有些困难,用生活中的一个例子:<strong>运算符按照顺序工作,就像仓库里堆积着一些油漆,其中有一桶漏了,而它只会影响到下面的物品,将其染上了色,并不会影响到上面的物品</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04e2ddccf81a4ea187c0fc6c8b29b42f~tplv-k3u1fbpfcp-watermark.image" alt="cc00ebad-f4e9-4276-b3e5-0e61448b6ac8.png"></p><p>二元 <code>+</code> 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3129749d418a4ad2ba58b99b43b7e1de~tplv-k3u1fbpfcp-zoom-1.image"></div><p>下面是减法和除法运算的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">6</span> - <span class="string">&#x27;2&#x27;</span> ); <span class="comment">// 4，将 &#x27;2&#x27; 转换为数字</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;6&#x27;</span> / <span class="string">&#x27;2&#x27;</span> ); <span class="comment">// 3，将两个运算元都转换为数字</span></span><br></pre></td></tr></table></figure><p><strong>数字转化 、一元运算符 +</strong></p><p>加号 <code>+</code> 有两种形式。一种是上面我们刚刚讨论的二元运算符进行算术的加法运算，还有一种是一元运算符。</p><p>一元运算符加号，或者说，加号 <code>+</code> 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 <code>+</code> 则会将其转化为数字。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对数字无效</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="title function_">alert</span>( +x ); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = -<span class="number">2</span>;</span><br><span class="line"><span class="title function_">alert</span>( +y ); <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化非数字</span></span><br><span class="line"><span class="title function_">alert</span>( +<span class="literal">true</span> ); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>( +<span class="string">&quot;&quot;</span> );   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>它的效果和 <code>Number(...)</code> 相同，但是更加简短。<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377200f9887747a3968e47fb9c512aa3~tplv-k3u1fbpfcp-watermark.image" alt="{_10_335_}.png"></p><p>我们经常会有将字符串转化为数字的需求。比如，如果我们正在从 HTML 表单中取值，通常得到的都是字符串。如果我们想对它们求和，该怎么办？</p><p>二元运算符加号会把它们合并成字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> oranges = <span class="string">&quot;3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( apples + oranges ); <span class="comment">// &quot;23&quot;，二元运算符加号合并字符串</span></span><br></pre></td></tr></table></figure><p>如果我们想把它们当做数字对待，我们需要转化它们，然后再求和：<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19e43179b3ec49c88a3e40be73003e88~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁203.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> oranges = <span class="string">&quot;3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二元运算符加号起作用之前，所有的值都被转化为了数字</span></span><br><span class="line"><span class="title function_">alert</span>( +apples + +oranges ); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更长的写法</span></span><br><span class="line"><span class="comment">// alert( Number(apples) + Number(oranges) ); // 5</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结:</strong></p><p>1.<strong>数字相加</strong></p><p>2.<strong>字符相连</strong></p><p>3.<strong>非数字类型转化为数字类型进行求和操作</strong></p></blockquote><h4 id="三元运算符-三元表达式"><a href="#三元运算符-三元表达式" class="headerlink" title="三元运算符(三元表达式)"></a>三元运算符(三元表达式)</h4><p>语法: <code>条件? 满足条件的表达式 : 不满足条件的表达式</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&lt;<span class="number">5</span> ? <span class="title function_">alert</span>(<span class="string">&#x27;真的&#x27;</span>) : <span class="title function_">alert</span>(<span class="string">&#x27;假的&#x27;</span>)</span><br></pre></td></tr></table></figure> <div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47c16c0ec9cd463fb5e2de8978b7ce6c~tplv-k3u1fbpfcp-zoom-1.image"></div><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">    代码</span><br><span class="line">    <span class="comment">// 没有全等条件会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简易计算器案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> num1 = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入第一个数字&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> sp = <span class="title function_">prompt</span>(<span class="string">&#x27;请您选择对应的 + - * / 操作&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> num2 = <span class="title function_">prompt</span>(<span class="string">&#x27;请您输入第二个数字&#x27;</span>)</span><br><span class="line">    <span class="keyword">switch</span> (sp) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        alert (<span class="string">`<span class="subst">$&#123;num1 + num2&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        alert (<span class="string">`<span class="subst">$&#123;num1 - num2&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        alert (<span class="string">`<span class="subst">$&#123;num1 * num2&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        alert (<span class="string">`<span class="subst">$&#123;num1 / num2&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">        alert (<span class="string">&#x27;你真调皮,请执行对应操作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>水果查询案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> frults = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入一种水果&#x27;</span>)</span><br><span class="line"><span class="keyword">switch</span> (frults) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;苹果&#x27;</span>:</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&#x27;你输入的是苹果,价格是6元/Kg&#x27;</span>)</span><br><span class="line">     <span class="keyword">break</span>      <span class="comment">// 退出switch</span></span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;香蕉&#x27;</span>:   </span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&#x27;你输入的是香蕉,价格是5元/Kg&#x27;</span>) </span><br><span class="line">     <span class="keyword">break</span>       <span class="comment">// 退出switch</span></span><br><span class="line">     <span class="attr">default</span>:</span><br><span class="line">     <span class="title function_">alert</span>(<span class="string">&#x27;没有&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等值(<strong>值</strong>和<strong>类型</strong>)比较直接显示结果</p><p>break关键字表示case这一项的介绍,如果每一项不加break则会造成穿透(代码逐层往下执行)</p><p>实际开发中短的额分支推荐使用if多分支语句,若是长的分支推荐使用switch语句,性能方面switch语句性能比if多分支要高</p><h3 id="循环语句-无限循环"><a href="#循环语句-无限循环" class="headerlink" title="循环语句(无限循环)"></a>循环语句(无限循环)<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0780d2e9c674a8eabcd9fb150fe7cae~tplv-k3u1fbpfcp-watermark.image" alt="face074.gif"></h3><h4 id="while无限循环"><a href="#while无限循环" class="headerlink" title="while无限循环"></a>while无限循环</h4><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">  <span class="comment">// 所谓的“循环体”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98db070abf1b454fb4f2a004758054e7~tplv-k3u1fbpfcp-watermark.image" alt="273.GIF"></p><p>当 <code>condition</code> 为真时，执行循环体的 <code>code</code>。</p><p>例如，以下将循环输出当 <code>i &lt; 3</code> 时的 <code>i</code> 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123; <span class="comment">// 依次显示 0、1 和 2</span></span><br><span class="line">  i++;</span><br><span class="line">  <span class="title function_">alert</span>( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> love = <span class="title function_">prompt</span>(<span class="string">&#x27;请问你爱我吗?&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> (love === <span class="string">&#x27;爱&#x27;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c642b20789941638ba9a071d11582f0~tplv-k3u1fbpfcp-zoom-1.image"></div><p>for无限循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">            <span class="keyword">let</span> love = <span class="title function_">prompt</span>(<span class="string">&#x27;请问你爱我吗?&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (love === <span class="string">&#x27;爱&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//不推荐,看起来不直观</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    初始值</span></span><br><span class="line">   <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="comment">// 循环条件</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt;= <span class="number">50</span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;只因你太美&lt;br&gt;&#x27;</span>)</span><br><span class="line">    <span class="comment">// 变量变化值</span></span><br><span class="line">    i++</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="for循环😀"><a href="#for循环😀" class="headerlink" title="for循环😀"></a>for循环😀</h4><p>for循环三要素</p><p>1.定义变量初始值</p><p>2.定义变量循环条件</p><p>3.设置变量变化量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量初始值;变量循环条件;变量变化量) &#123;</span><br><span class="line">    满足执行条件的循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b88b19d6e3e4ca39d8235a08e3a00e2~tplv-k3u1fbpfcp-watermark.image" alt="272.GIF"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;☺&lt;br&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求0-100偶数和案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">           sum += i 等价于（sum = sum + i）</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   alert (<span class="string">`偶数和为<span class="subst">$&#123;sum&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><h4 id="中止循环"><a href="#中止循环" class="headerlink" title="中止循环 "></a>中止循环 <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1303ff154e44c36b3966a96602a4fe2~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁277.gif"></h4><p>break 中止<strong>整个循环</strong>,一般用于结果已经得到, 后续的循环不需要的时候可以使用（提高效率）</p><p>continue中止<strong>本次循环</strong>,一般用于排除或者跳过某一个选项的时候</p><h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05a3b19940854335a8ca3e8c6406de59~tplv-k3u1fbpfcp-zoom-1.image"></div><p>外层循环一次,里层循环多次</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e02e5cce8748589bc4a94e54979e60~tplv-k3u1fbpfcp-zoom-1.image"></div><blockquote><p>运行路径:<strong>外层循环一次,内层全部循环一次</strong>(外层循环一次,内层全部执行完毕之后,才会执行外部的第二次循环)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层for循环控制行数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line">   <span class="comment">// 里层for循环控制列数</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> j =<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++) &#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`★`</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95b0656c02644887bf8b1a1a348a3be8~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁205.gif"></h3><p>数组是一个引用数据类型</p><p>作用:在单个变量中存储多个数据</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>定义数组</p><p>let 数组名 &#x3D; [ 数据1,数据2,数据3] ,多个数据以逗号隔开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;卧龙&#x27;</span>,<span class="string">&#x27;凤雏&#x27;</span>,<span class="number">111</span>]</span><br></pre></td></tr></table></figure><p>空数组 [ ]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5212c130ec0a4875b96abf3cc2db56dd~tplv-k3u1fbpfcp-watermark.image" alt="262.GIF"></p><h3 id="数组取值"><a href="#数组取值" class="headerlink" title="数组取值"></a>数组取值</h3><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19d45ebdd5354dfea321592b9538b9a0~tplv-k3u1fbpfcp-zoom-1.image"></div><h4 id="数组名-索引或下标"><a href="#数组名-索引或下标" class="headerlink" title="数组名[索引或下标]"></a>数组名[索引或下标]<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e9dad0722a04f0ea9fb40e5e9eedf5e~tplv-k3u1fbpfcp-watermark.image" alt="face106.gif"></h4><p>它其实与 <code>obj[key]</code> 相同，其中 <code>arr</code> 是对象，而数字用作键（key）,它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 <code>length</code> 属性。但从本质上讲，它仍然是一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>[<span class="number">1</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">class</span>[<span class="number">1</span>])<span class="comment">//小刚</span></span><br></pre></td></tr></table></figure><p><strong>数组或下标开始由0开始</strong></p><p>循环数组(遍历数组)</p><p><strong>遍历数组</strong>：把数组中每个数据都访问到</p><p><strong>数组长度</strong>： 数组名.<code>length</code></p><blockquote><p>因为数组的索引是从0开始的,所以循环初始值定义</p></blockquote><h4 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h4><h4 id="数组的增删改查"><a href="#数组的增删改查" class="headerlink" title="数组的增删改查"></a>数组的增删改查<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45ed32fe313e42d9ae1a73ae1dbc65c9~tplv-k3u1fbpfcp-watermark.image" alt="face058.jpg"></h4><table><thead><tr><th>新增</th><th></th></tr></thead><tbody><tr><td>push</td><td>在尾部新增</td></tr><tr><td>unshift</td><td>在头部新增</td></tr><tr><td>删除</td><td></td></tr><tr><td>pop</td><td>删除最后一个元素</td></tr><tr><td>shift</td><td>删除第一个元素</td></tr></tbody></table><h4 id="push-shift方法"><a href="#push-shift方法" class="headerlink" title="push&#x2F;shift方法"></a>push&#x2F;shift方法</h4><p><code>push</code> 在末端添加一个元素</p><p><code>shift</code> 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed7dc313b6e342fead907bcd96e3344c~tplv-k3u1fbpfcp-watermark.image" alt="12.png"></p><p><code>数组名.push()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">push</span>(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits ); <span class="comment">// Apple, Orange, Pear</span></span><br></pre></td></tr></table></figure><p><code>数组名.shift( )</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="title function_">shift</span>() ); <span class="comment">// 移除 Apple 然后 alert 显示出来</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits ); <span class="comment">// Orange, Pear</span></span><br></pre></td></tr></table></figure><p>数组名.shift( ),括号内不填任何东西哦<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ac88e80fbf4738b22fe8150e9c1709~tplv-k3u1fbpfcp-zoom-1.image"></p><p>数组还有另一个用例，就是数据结构 <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">栈</a>。</p><p>它支持两种操作：</p><ul><li><code>push</code> 在末端添加一个元素.</li><li><code>pop</code> 从末端取出一个元素.</li></ul><p>所以新元素的添加和取出都是从“末端”开始的。</p><p>栈通常被被形容成一叠卡片：要么在最上面添加卡片，要么从最上面拿走卡片：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0f5d1ed992429795ad86f7cf8f967f~tplv-k3u1fbpfcp-watermark.image" alt="13.png"></p><p>对于栈来说，最后放进去的内容是最先接收的，也叫做 LIFO（Last-In-First-Out），即后进先出法则。而与队列相对应的叫做 FIFO（First-In-First-Out），即先进先出。</p><p>JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端&#x2F;末端来添加&#x2F;删除元素。</p><p>这在计算机科学中，允许这样的操作的数据结构被称为 <a href="https://en.wikipedia.org/wiki/Double-ended_queue">双端队列（deque）</a></p><h4 id="pop-unshift方法"><a href="#pop-unshift方法" class="headerlink" title="pop &#x2F; unshift方法"></a>pop &#x2F; unshift方法</h4><p><code>pop</code>取出并返回数组的最后一个元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="title function_">pop</span>() ); <span class="comment">// 移除 &quot;Pear&quot; 然后 alert 显示出来</span></span><br><span class="line"><span class="title function_">alert</span>( fruits ); <span class="comment">// Apple, Orange</span></span><br></pre></td></tr></table></figure><p><code>unshift</code>在数组的首端添加元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>]; </span><br><span class="line">fruits.<span class="title function_">unshift</span>(<span class="string">&#x27;Apple&#x27;</span>); </span><br><span class="line"><span class="title function_">alert</span>( fruits ); <span class="comment">// Apple, Orange, Pear</span></span><br></pre></td></tr></table></figure><p><code>fruits.pop()</code> 和 <code>fruits.at(-1)</code> 都返回数组的最后一个元素，但 <code>fruits.pop()</code> 同时也删除了数组的最后一个元素，进而修改了原数组</p><p><strong>数组修改</strong></p><p>数组名[索引]&#x3D;新值</p><p>返回值：如果下标不存在，则是新增一个数组元素，并修改了数组长度（尽量避免）</p><blockquote><p>若数组中没有该值则为新增</p></blockquote><p><strong>数组查询</strong></p><p>数组名[索引]从0开始</p><p>查找不到默认返回undefined</p><p>获取最后一个元素</p><p>数组名[数组名.length-1]</p><blockquote><p>使用 at 获取最后一个元素</p><p>最近新增的特性</p><p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.</p></blockquote><p>假设我们想要数组的最后一个元素。</p><p>一些编程语言允许我们使用负数索引来实现这一点，例如 <code>fruits[-1]</code>。</p><p>但在 JavaScript 中这行不通。结果将是 <code>undefined</code>，因为方括号中的索引是被按照其字面意思处理的。</p><p>我们可以显式地计算最后一个元素的索引，然后访问它：<code>fruits[fruits.length - 1]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits[fruits.<span class="property">length</span>-<span class="number">1</span>] ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure><p>有点麻烦，不是吗？我们需要写两次变量名。</p><p>幸运的是，这里有一个更简短的语法 <code>fruits.at(-1)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 fruits[fruits.length-1] 相同</span></span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="title function_">at</span>(-<span class="number">1</span>) ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure><p>换句话说，<code>arr.at(i)</code>：</p><ul><li>如果 <code>i &gt;= 0</code>，则与 <code>arr[i]</code> 完全相同。</li><li>对于 <code>i</code> 为负数的情况，它则从数组的尾部向前数</li></ul><h3 id="关于length"><a href="#关于length" class="headerlink" title="关于length"></a>关于length<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91a99bf294a74eb2b9e083fb0e97941e~tplv-k3u1fbpfcp-zoom-1.image"></h3><p>当我们修改数组的时候，<code>length</code> 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。</p><p>例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 <code>length</code> 也会很大：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [];</span><br><span class="line">fruits[<span class="number">123</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="property">length</span> ); <span class="comment">// 124</span></span><br></pre></td></tr></table></figure><p>要知道的是我们通常不会这样使用数组。</p><p><code>length</code> 属性的另一个有意思的点是它是可写的。</p><p>如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>; <span class="comment">// 截断到只剩 2 个元素</span></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>; <span class="comment">// 又把 length 加回来</span></span><br><span class="line"><span class="title function_">alert</span>( arr[<span class="number">3</span>] ); <span class="comment">// undefined：被截断的那些数值并没有回来</span></span><br></pre></td></tr></table></figure><p>所以，清空数组最简单的方法就是：<code>arr.length = 0;</code></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h3><p><code>push/pop</code> 方法运行的比较快，而 <code>shift/unshift</code> 比较慢</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ba6427a3d6543bea4e51fe0973dafcb~tplv-k3u1fbpfcp-watermark.image" alt="数组性能.png"></p><p>为什么作用于数组的末端会比首端快呢？让我们看看在执行期间都发生了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits.<span class="title function_">shift</span>(); <span class="comment">// 从首端取出一个元素</span></span><br></pre></td></tr></table></figure><p>只获取并移除索引 <code>0</code> 对应的元素是不够的。其它元素也需要被重新编号。</p><h4 id="shift-操作必须做三件事"><a href="#shift-操作必须做三件事" class="headerlink" title="shift 操作必须做三件事:"></a><code>shift</code> 操作必须做三件事:<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19efdc65a5f147f28589c6a27df69ae1~tplv-k3u1fbpfcp-zoom-1.image"></h4><ol><li>移除索引为 <code>0</code> 的元素。</li><li>把所有的元素向左移动，把索引 <code>1</code> 改成 <code>0</code>，<code>2</code> 改成 <code>1</code> 以此类推，对其重新编号。</li><li>更新 <code>length</code> 属性。</li></ol><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36aa25ded53b41c5a256082a82cb79fc~tplv-k3u1fbpfcp-zoom-1.image"></div><p><strong>数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。</strong></p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ff8316f47e49ad90cf723fae04ddb4~tplv-k3u1fbpfcp-zoom-1.image"></div><p><code>unshift</code> 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。</p><p>那 <code>push/pop</code> 是什么样的呢？它们不需要移动任何东西。如果从末端移除一个元素，<code>pop</code> 方法只需要清理索引值并缩短 <code>length</code> 就可以了。</p><h4 id="pop-操作的行为："><a href="#pop-操作的行为：" class="headerlink" title="pop 操作的行为："></a><code>pop</code> 操作的行为：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits.<span class="title function_">pop</span>(); <span class="comment">// 从末端取走一个元素</span></span><br></pre></td></tr></table></figure><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1230d5649bb44b5a7ca5b2d43d2f6bb~tplv-k3u1fbpfcp-zoom-1.image"></div><p><strong><code>pop</code> 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 <code>pop</code> 会特别快。</strong></p><p><code>push</code> 方法也是一样的<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0e9639dd7de48c49a2b149c788f4b6f~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="数组-splice-方法"><a href="#数组-splice-方法" class="headerlink" title="数组(splice)方法"></a>数组(splice)方法</h3><p><strong>从指定位置删除或者增加的数组元素</strong></p><p><strong>2个参数是删除</strong></p><p>数组名.splice(删除的位置(参考数组索引),删除的个数)</p><p>返回值:删除的对应元素</p><p>第二个参数不填,默认从索引位置删除到结尾</p><p><strong>3个参数是添加</strong></p><p>数组名.splice(新增的位置,新增个数(替换操作),新增的数据1,新增的数据2)</p><p>返回值:[ ]空数组</p><h3 id="sort排序-升序-降序"><a href="#sort排序-升序-降序" class="headerlink" title="sort排序(升序,降序)"></a>sort排序(升序,降序)</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f313a8ac7dd4063956d53fb922cf286~tplv-k3u1fbpfcp-zoom-1.image"><p>数组名.sort()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">89</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">78</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基本使用"><a href="#函数的基本使用" class="headerlink" title="函数的基本使用"></a>函数的基本使用</h3><h4 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数?"></a>什么是函数?</h4><p>一段可以重复使用的代码块,代码块由 { } 包裹</p><p>作用:利于代码的重复使用,提高开发效率</p><p>其实之前我们使用到的输入,输出框的语句像prompt(‘’) , alert(‘’)就已经使用到了函数,它们是浏览器内置的函数,我们直接调用就可以使用,我们也可以创建自己的函数</p><h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤:"></a>使用步骤:</h4><p>1.定义函数(声明函数)</p><p>语法:<code>function</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名() &#123;</span><br><span class="line">函数体 (要重复执行的代码)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数名命名与变量一致,使用小驼峰命名法</p></blockquote><p>2.调用函数</p><p>函数名( )</p><blockquote><p>函数(代码块)默认不执行,调用的时候才会执行</p></blockquote><h4 id="函数的复用代码和循环重复的代码的区别"><a href="#函数的复用代码和循环重复的代码的区别" class="headerlink" title="函数的复用代码和循环重复的代码的区别"></a>函数的复用代码和循环重复的代码的区别</h4><blockquote><p>循环的代码写完会立即执行,不能很方便的控制执行位置,循环是用来重复执行代码</p><p>复用的代码是在需要的地方拿来调用,可以重复的使用</p></blockquote><p>求1-100和案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum100</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">let</span> sum = <span class="number">0</span> <span class="comment">//声明变量初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="title function_">sum100</span>()</span><br></pre></td></tr></table></figure><h3 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域(scope)"></a>作用域(scope)</h3><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1344020ffa940dea599dede4cd064b7~tplv-k3u1fbpfcp-zoom-1.image"></div><h4 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么?"></a>作用域是什么?<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c516ce6707264025ad3f21dfd4ef2a3d~tplv-k3u1fbpfcp-zoom-1.image"></h4><p>变量或是值在代码中生效的范围</p><p>作用:管理变量的作用范围,防止发生冲突</p><h5 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1.全局作用域"></a>1.全局作用域</h5><p><code>let </code>&#x2F; <code>const </code>&#x2F; <code>var</code> 声明的变量</p><p>作用范围:整个script标签内部,和单独的js文件</p><h5 id="2-局部作用域-函数作用域和块级作用域"><a href="#2-局部作用域-函数作用域和块级作用域" class="headerlink" title="2.局部作用域(函数作用域和块级作用域)"></a>2.局部作用域(函数作用域和块级作用域)</h5><h5 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h5><p>作用范围:函数内部生效,函数外部不生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">//10,20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// a,b is not defined</span></span><br></pre></td></tr></table></figure><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>作用范围:使用<code>let</code>或<code>const</code>在 { } 中定义的变量称为块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span> </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//a is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>函数内部不声明直接赋值的变量当全局变量,不提倡,乱了套</p><p>函数内部的形参当局部变量看</p></blockquote><h4 id="变量的访问原则"><a href="#变量的访问原则" class="headerlink" title="变量的访问原则"></a>变量的访问原则</h4><p>在能够访问到的情况下先局部,局部没有往上找全局,全局找不到最后就会报错</p><p>就近原则,逐级查找</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cad4ad5eeed04d1ea54b0d2f65f7d57c~tplv-k3u1fbpfcp-zoom-1.image"></div><p>参数:也叫参变量,是一个变量</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fcfce9d8f64a3ca8dea0a85c915671~tplv-k3u1fbpfcp-zoom-1.image"></div><blockquote><p>形参:声明函数时括号里的参数(形式上的参数),[用于接收实参传递过来的数据]</p><p>实参:调用函数小括号里的参数(实际上的参数)[向实参传递数据]</p><p>传参:把实参的数据传递给形参的执行过程,提供给函数内部使用,简单理解为变量在赋值</p></blockquote><p>我们可以使用参数（也称“函数参数 &#x2F; 参变量”）来将任意数据传递给函数<br>在如下示例中，函数有两个参数：<code>from</code> 和 <code>text</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text</span>) &#123; <span class="comment">// 参数：from 和 text</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="keyword">from</span> + <span class="string">&#x27;: &#x27;</span> + text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&#x27;Ann&#x27;</span>, <span class="string">&#x27;Hello!&#x27;</span>); <span class="comment">// Ann: Hello! (*)</span></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&#x27;Ann&#x27;</span>, <span class="string">&quot;What&#x27;s up?&quot;</span>); <span class="comment">// Ann: What&#x27;s up? (**)</span></span><br></pre></td></tr></table></figure><p>当函数在 <code>(*)</code> 和 <code>(**)</code> 行中被调用时，给定值(实参)通过传参给到了局部变量 <code>from</code> 和 <code>text</code>。然后函数使用它们进行计算,最后在页面显示出来</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>如果未提供参数，那么其默认值则是 <code>undefined</code>。</p><p>例如，之前提到的函数 <code>showMessage(from, text)</code> 可以只使用一个参数调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showMessage</span>(<span class="string">&quot;Ann&quot;</span>);</span><br></pre></td></tr></table></figure><p>那不是错误，这样调用将输出 <code>&quot;Ann: undefined&quot;</code>。这里没有参数 <code>text</code>，所以程序假定 <code>text === undefined</code>。</p><p>如果我们想在本示例中设定“默认”的 <code>text</code>，那么我们可以在 <code>=</code> 之后指定它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text = <span class="string">&quot;no text given&quot;</span></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>( <span class="keyword">from</span> + <span class="string">&quot;: &quot;</span> + text );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&quot;Ann&quot;</span>); <span class="comment">// Ann: no text given</span></span><br></pre></td></tr></table></figure><p>现在如果 <code>text</code> 参数未被传递，它将会得到值 <code>&quot;no text given&quot;</code>。</p><p>这里 <code>&quot;no text given&quot;</code> 是一个字符串，但它可以是更复杂的表达式，并且只会在缺少参数时才会被计算和分配。所以，这也是可能的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text = anotherFunction()</span>) &#123;</span><br><span class="line"><span class="comment">// anotherFunction() 仅在没有给定 text 时执行</span></span><br><span class="line"><span class="comment">// 其运行结果将成为 text 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认参数的计算"><a href="#默认参数的计算" class="headerlink" title="默认参数的计算"></a>默认参数的计算</h4><p>在 JavaScript 中，每次函数在没带个别参数的情况下被调用，默认参数会被计算出来。</p><p>在上面的例子中，每次 <code>showMessage()</code> 不带 <code>text</code> 参数被调用时，<code>anotherFunction()</code> 就会被调用。</p><blockquote><p>形参个数过多, 多余的参数会自动补充 undefined</p><p>实参参数过多, 多余的实参参数会被忽略</p><p>建议实际开发中形参和实参个数一致</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3dc45802e23416cbbc138094d835195~tplv-k3u1fbpfcp-watermark.image" alt="256.GIF"></p><h4 id="逻辑中断"><a href="#逻辑中断" class="headerlink" title="逻辑中断"></a>逻辑中断<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b19dee1847149f1b1dec753475ebcb7~tplv-k3u1fbpfcp-zoom-1.image"></h4><p>什么是逻辑中断?</p><p>在逻辑运算符中有 <code>$$</code> 与 || ,这两个运算符有另外一个叫法称为短路运算符,这两个运算符的作用是左边如果满足一定条件会中断代码执行,这种行为被称为逻辑短路 &#x2F; 逻辑中断</p><p>(一真则真)逻辑或 <code>||</code>中断:如果左边为真,中断右边代码不执行,如果左边为假,则返回右边的值</p><p>或运算符 <code>||</code> 做了如下的事情：</p><ul><li>从左到右依次计算操作数。</li><li>处理每一个操作数时，都将其转化为布尔值。如果结果是 <code>true</code>，就停止计算(逻辑中断)，返回这个操作数的初始值。</li><li>如果所有的操作数都被计算过（也就是，转换结果都是 <code>false</code>），则返回最后一个操作数。</li></ul><p>(一假则假) 逻辑与 <code>$$</code>中断:如果左边为假,中断右边代码不执行,如果左边为真,则返回右边的值</p><p>同理</p><blockquote><p>逻辑运算符在比较时会转为布尔类型,最后返回的结果是原来的值</p></blockquote><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/135c072f67244953b252c8aedf45a12f~tplv-k3u1fbpfcp-zoom-1.image"></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 声明函数(接收调用者传递的数据)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sumArr</span>(<span class="params">arr = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 3.内部处理,数组求和</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span><span class="comment">//定义变量初始值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组拿到每一项值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        sum += arr[i]<span class="comment">//数组求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.返回求和的结果给到调用者</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用函数,将接收到的数据传递给形参</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title function_">sumArr</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>])</span><br><span class="line"><span class="comment">// 打印出结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1740347dee274bba9f8db3d59a325f84~tplv-k3u1fbpfcp-zoom-1.image"></h3><p>语法: <code>return</code></p><p>返回值:函数执行完毕之后的结果</p><p>作用:把处理的结果返回给调用者,结束函数</p><blockquote><p>函数不一定要有返回值,例alert ()</p><p>函数可以没有返回值,如果没有返回值,结果是undefined</p><p>如需拿到返回值进行下一步操作,则需要return返回</p></blockquote><p>举个简单的小栗子:<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/778b50dd573a4dd39b597175fd25854d~tplv-k3u1fbpfcp-watermark.image" alt="阿鲁156.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">alert</span>( result ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>指令 <code>return</code> 可以在函数的任意位置。当执行到达时，函数停止，并将值返回给调用代码（分配给上述代码中的 <code>result</code>）</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337d0a951267426a831292092921e588~tplv-k3u1fbpfcp-zoom-1.image"></div><p>在一个函数中可能会出现很多次 <code>return</code>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">prompt</span>(<span class="string">&#x27;Got a permission from the parents?&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只使用 <code>return</code> 但没有返回值也是可行的。但这会导致函数立即退出</p><p>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMovie</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="title function_">checkAge</span>(age) ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">&quot;Showing you the movie&quot;</span> ); <span class="comment">// (*)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果 <code>checkAge(age)</code> 返回 <code>false</code>，那么 <code>showMovie</code> 将不会运行到 <code>alert</code>。</p><p>空值的 <code>return</code> 或没有 <code>return</code> 的函数返回值为 <code>undefined</code></p><p>如果函数无返回值，它就会像返回 <code>undefined</code> 一样：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9737bdd931f64b33b735309e719e0d6e~tplv-k3u1fbpfcp-zoom-1.image"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doNothing</span>(<span class="params"></span>) &#123; <span class="comment">/* 没有代码 */</span> &#125;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">doNothing</span>() === <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>空值的 <code>return</code> 和 <code>return undefined</code> 等效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doNothing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">doNothing</span>() === <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>不要在 <code>return</code> 与返回值之间添加新行</p><p>对于 <code>return</code> 的长表达式，可能你会很想将其放在单独一行，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line"> (some + long + expression + or + whatever * <span class="title function_">f</span>(a) + <span class="title function_">f</span>(b))</span><br></pre></td></tr></table></figure><p>但这不行，因为 JavaScript 默认会在 <code>return</code> 之后加上分号,上面这段代码和下面这段代码运行流程相同:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> (some + long + expression + or + whatever * <span class="title function_">f</span>(a) + <span class="title function_">f</span>(b))</span><br></pre></td></tr></table></figure><p>因此，实际上它的返回值变成了空值。</p><p>如果我们想要将返回的表达式写成跨多行的形式，那么应该在 <code>return</code> 的同一行开始写此表达式。或者至少按照如下的方式放上左括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  some + long + expression</span><br><span class="line">  + or +</span><br><span class="line">  whatever * <span class="title function_">f</span>(a) + <span class="title function_">f</span>(b)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>然后它就能像我们预想的那样正常运行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMovie</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="title function_">checkAge</span>(age) ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">&quot;Showing you the movie&quot;</span> ); <span class="comment">// (*)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a83ad29a5a4a4903831c588f975f2491~tplv-k3u1fbpfcp-zoom-1.image"></div><p>封装获取数组最大值函数案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装求数组最大值函数</span></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxArr</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"><span class="comment">// 定义最大值变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">MAX</span> = arr[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//遍历获取到数组,依次获取到数组里面的值与定义的最大值变量进行比较</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i &lt;arr.<span class="property">length</span>;i++) &#123;</span><br><span class="line">    <span class="comment">// 数值比较判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable constant_">MAX</span> &lt; arr[i]) &#123;</span><br><span class="line">        <span class="comment">// 如果获取到的数值比定义的初始最大值变量要大,则直接把获取到的最大值赋值给初始的最大值变量,进行覆盖</span></span><br><span class="line">        <span class="variable constant_">MAX</span> = arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回最大值的结果,给调用者</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable constant_">MAX</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数传参</span></span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="title function_">maxArr</span>([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>])</span><br><span class="line"><span class="comment">// 控制台打印输出查看结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(maxNum);</span><br></pre></td></tr></table></figure><h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>函数就是行为（action）。所以它们的名字通常是动词。它应该简短且尽可能准确地描述函数的作用。这样读代码的人就能清楚地知道这个函数的功能</p><p>一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为。团队内部必须就前缀的含义达成一致。</p><p>例如，以 <code>&quot;show&quot;</code> 开头的函数通常会显示某些内容。</p><p>函数以 XX 开始……</p><ul><li><code>&quot;get…&quot;</code> —— 返回一个值，</li><li><code>&quot;calc…&quot;</code> —— 计算某些内容，</li><li><code>&quot;create…&quot;</code> —— 创建某些内容，</li><li><code>&quot;check…&quot;</code> —— 检查某些内容并返回 boolean 值，等。</li></ul><p>有了前缀，只需瞥一眼函数名，就可以了解它的功能是什么，返回什么样的值。</p><p>一个函数 —— 一个行为</p><p>一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。</p><p>两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。</p><p>有几个违反这一规则的例子：</p><ul><li><code>getAge</code> —— 如果它通过 <code>alert</code> 将 age 显示出来，那就有问题了（只应该是获取）。</li><li><code>createForm</code> —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。</li><li><code>checkPermission</code> —— 如果它显示 <code>access granted/denied</code> 消息，那就有问题了（只应执行检查并返回结果）。</li></ul><p>这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。</p><p>非常短的函数命名</p><p>常用的函数有时会有<strong>非常短</strong>的名字。</p><p>例如，<a href="http://jquery.com/">jQuery</a> 框架用 <code>$</code> 定义一个函数。<a href="http://lodash.com/">LoDash</a> 库的核心函数用 <code>_</code> 命名。</p><p>这些都是例外，一般而言，函数名应简明扼要且具有描述性。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/048949ead40a44bb857c48f9ba5f1ede~tplv-k3u1fbpfcp-watermark.image" alt="141.png"></p><h3 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h3><h4 id="具名函数"><a href="#具名函数" class="headerlink" title="具名函数"></a>具名函数</h4><p>带有名字的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"> </span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>没有名字的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数的两种使用方式</p><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值,这个值可以被赋值给一个变量,通过变量名来调用,这个就称之为函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，函数被创建并像其他赋值一样，被明确地分配给了一个变量。不管函数是被怎样定义的，都只是一个存储在变量 <code>sayHi</code> 中的值。</p><p>我们还可以用 <code>alert</code> 打印这个变量值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>(sayHi)</span><br></pre></td></tr></table></figure><blockquote><p>匿名函数和具名函数使用方式一致</p></blockquote><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1fab474fc41441dae05c374544cb1c8~tplv-k3u1fbpfcp-zoom-1.image"></div><h4 id="立即执行函数-IIFE-自执行函数"><a href="#立即执行函数-IIFE-自执行函数" class="headerlink" title="立即执行函数( IIFE)自执行函数"></a>立即执行函数( IIFE)自执行函数</h4><p>方式一</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f90b5034f0664083959fd82eeb6afabe~tplv-k3u1fbpfcp-zoom-1.image"></div><p>方式二</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/241b637faa9a482dac22bab27f3e043a~tplv-k3u1fbpfcp-zoom-1.image"></div>作用:防止全局变量冲突<blockquote><p>1.立即执行函数使用时,所有的语法需要使用分号隔开</p><p>2.立即执行函数和普通函数没有什么区别</p><p>3.立即执行函数也属于函数一类,也是一个数据,属于引用数据类型</p></blockquote><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0ddfc66d15e40d0b22403cb383dcb5e~tplv-k3u1fbpfcp-zoom-1.image"></h3><p><strong>把一个函数作为参数传递给另外一个函数</strong></p><p>我们写一个包含三个参数的函数 <code>ask(question, yes, no)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">question</span><br></pre></td></tr></table></figure><p>关于问题的文本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><p>当回答为 “Yes” 时，要运行的脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure><p>当回答为 “No” 时，要运行的脚本</p><p>函数需要提出 <code>question</code>（问题），并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10ab19641f09404c99cbf19b29dbd56d~tplv-k3u1fbpfcp-zoom-1.image"></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ask</span>(<span class="params">question, yes, no</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">prompt</span>(question)) &#123;</span><br><span class="line">     <span class="title function_">yes</span>();</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">no</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showOk</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;You agreed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showCancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;You canceled the execution.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span></span><br><span class="line"><span class="title function_">ask</span>(<span class="string">&quot;Do you agree?&quot;</span>, showOk, showCancel);</span><br></pre></td></tr></table></figure><p>在实际开发中，这样的的函数是非常有用的。实际开发与上述示例最大的区别是，实际开发中的函数会通过更加复杂的方式与用户进行交互，而不是通过简单的 prompt。在浏览器中，这样的函数通常会绘制一个漂亮的提问窗口。但这是另外一件事了。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bcc77ea4b424d72a033b3fd6689aea5~tplv-k3u1fbpfcp-zoom-1.image"></p><p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong></p><p>主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。在我们的例子中，<code>showOk</code> 是回答 “yes” 的回调，<code>showCancel</code> 是回答 “no” 的回调</p><p>我们可以用函数表达式对同样的函数进行大幅简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ask</span>(<span class="params">question, yes, no</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">prompt</span>(question)) <span class="title function_">yes</span>()</span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">no</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">ask</span>(</span><br><span class="line">  <span class="string">&quot;Do you agree?&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="string">&quot;You agreed.&quot;</span>); &#125;,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="string">&quot;You canceled the execution.&quot;</span>); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问（因为没有对它们分配变量），不过这正是我们想要的。</p><p>这样的代码在我们的脚本中非常常见，这正符合 JavaScript 语言的思想。</p><p>一个函数是表示一个“行为”的值</p><p>字符串或数字等常规值代表 <strong>数据</strong>。</p><p>函数可以被视为一个 <strong>行为（action）</strong>。</p><p>我们可以在变量之间传递它们，并在需要时运行。</p><h4 id="函数声明和函数表达式之间的主要区别："><a href="#函数声明和函数表达式之间的主要区别：" class="headerlink" title="函数声明和函数表达式之间的主要区别："></a>函数声明和函数表达式之间的主要区别：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea46222dfc064c0b8a315b31153d78d6~tplv-k3u1fbpfcp-zoom-1.image"></h4><p>首先是语法：如何通过代码对它们进行区分</p><p><strong>函数声明</strong>：在主代码流中声明为单独的语句的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数表达式</strong>：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 <code>=</code> 右侧创建的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更细微的差别是，JavaScript 引擎会在 <strong>什么时候</strong> 创建函数。</p><p>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d58b24730674a2f8151b7c1034ed3fc~tplv-k3u1fbpfcp-zoom-1.image"></p><p>一旦代码执行到赋值表达式 <code>let sum = function…</code> 的右侧，此时就会开始创建该函数，并且可以从现在开始使用（分配，调用等）。</p><p>函数声明则不同。</p><p><strong>在函数声明被定义之前，它就可以被调用。</strong></p><p>例如，一个全局函数声明对整个脚本来说都是可见的，无论它被写在这个脚本的哪个位置。</p><p>这是内部算法的原故。当 JavaScript <strong>准备</strong> 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。我们可以将其视为“初始化阶段”。</p><p>在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。</p><div align="center"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9fc645a1b5c4f75acc270be583db440~tplv-k3u1fbpfcp-zoom-1.image"><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d649ce6c4042fb9921775c3e456fa7~tplv-k3u1fbpfcp-zoom-1.image"></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">arg1, arg2, ...argN</span>) =&gt; expression</span><br></pre></td></tr></table></figure><p>……这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p><p>换句话说，它是下面这段代码的更短的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">arg1, arg2, ...argN</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> expression;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们来看一个具体的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"><span class="comment">/* 这个箭头函数是下面这个函数的更短的版本：</span></span><br><span class="line"><span class="comment">let sum = function(a, b) &#123;</span></span><br><span class="line"><span class="comment">  return a + b;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>(a, b) =&gt; a + b</code> 表示一个函数接受两个名为 <code>a</code> 和 <code>b</code> 的参数。在执行时，它将对表达式 <code>a + b</code> 求值，并返回计算结果。</p><p>如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = n =&gt; n * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 差不多等同于：let double = function(n) &#123; return n * 2 &#125;</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">double</span>(<span class="number">3</span>) ); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>如果没有参数，括号将是空的（但括号应该保留）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sayHi</span> = (<span class="params"></span>) =&gt; <span class="title function_">alert</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure><p>箭头函数可以像函数表达式一样使用</p><p>例如动态创建一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">let</span> welcome = (age &lt; <span class="number">18</span>) ?</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;Hello&#x27;</span>) :</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">alert</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line"><span class="title function_">welcome</span>();</span><br></pre></td></tr></table></figure><h3 id="多行的箭头函数"><a href="#多行的箭头函数" class="headerlink" title="多行的箭头函数"></a>多行的箭头函数</h3><p>上面的例子从 <code>=&gt;</code> 的左侧获取参数，然后使用参数计算右侧表达式的值。</p><p>但有时我们需要更复杂一点的东西，比如多行的表达式或语句。这也是可以做到的，但是我们应该用花括号括起来。然后使用一个普通的 <code>return</code> 将需要返回的值进行返回。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;  <span class="comment">// 花括号表示开始一个多行函数</span></span><br><span class="line">  <span class="keyword">let</span> result = a + b;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常见面试题合集</title>
      <link href="/2023/01/14/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2023/01/14/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="对vue的理解"><a href="#对vue的理解" class="headerlink" title="对vue的理解"></a>对vue的理解</h2><p>Vue.js（&#x2F;vjuː&#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。Vue所关注的核心是MVC模式中的视图层,由数据驱动视图,把重点放在操作数据上</p><p>1.vue的核心特征就是主要有三点</p><p>数据驱动,所谓的数据驱动就是 mvvm (Model-View-ViewModel )</p><ul><li><p>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</p></li><li><p>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</p></li><li><p>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</p><p><strong>2.组件化开发</strong></p><p>把一整个页面拆成各个不同的组件,然后再整合在一起,实现各个功能,布局的隔离,降低整个系统的耦合度</p><p>调试方便,因为不同的功能布局是分离的在出现问题的时候就可以通过错误快速的定位源头,方便快捷的查找排查错误</p><p>提高可维护性和复用性,每个组件的职责是单一的</p><p><strong>3.丰富的指令系统</strong></p><p>指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><p>常用的vue指令有:</p><p><code>v-model</code>,双向数据绑定</p><p><code>v-on(@)</code>,监听事件</p><p><code>v-bind(:)</code>,绑定属性</p><p><code>v-for</code>:列表循环渲染</p><p><code>v-if</code>:条件渲染</p></li></ul><h2 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h2><p>前端路由的核心就是,访问不同的地址,对应切换不同的组件显示不同的内容,而不是重新加载刷新页面</p><p>vue-router就是把组件一一对应的映射到路由地址上,然后渲染出来</p><p>主要有三种模式</p><p>history 在url地址的后面是以 &#x2F; 分隔的,但是需要和后端配合进行配置,不然用户访问的页面就是404</p><p>hash 在url的后面是以 # 分隔的,比较丑,不美观,这也是路由的默认模式,一般会在开发的时候使用,在上线的时候可以把模式改为history好看一点</p><p>abstract 通常用于非浏览器环境，例如在服务器端渲染 (SSR) 中。</p><h2 id="什么是mvvm-优缺点"><a href="#什么是mvvm-优缺点" class="headerlink" title="什么是mvvm?优缺点"></a>什么是mvvm?优缺点</h2><p>MVVM 表示的是 <code>Model-View-ViewModel</code></p><ul><li><p>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</p></li><li><p>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</p></li><li><p>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁, ViewModel 负责监听 Model 的变化并更新 View,实现数据和视图之间的双向数据绑定,就像前面介绍vue的时候说的一样用户只需要把重点放在操作数据上面,而不是去操作dom</p></li></ul><h2 id="工厂函数与构造函数的区别"><a href="#工厂函数与构造函数的区别" class="headerlink" title="工厂函数与构造函数的区别"></a>工厂函数与构造函数的区别</h2><ol><li>工厂函数没有共享原型</li><li>工厂函数需要手动<code>return</code> </li><li>构造函数是通过<code>new</code>关键字创建</li></ol><h2 id="在vue2中是如何监听数组的变化"><a href="#在vue2中是如何监听数组的变化" class="headerlink" title="在vue2中是如何监听数组的变化"></a>在vue2中是如何监听数组的变化</h2><p>在<code>Vue2</code>中，<code>Vue</code>提供了一种称为”&#x3D;&#x3D;数组变异方法&#x3D;&#x3D;”的机制，用于监听数组的变化。这些变异方法包括 </p><p>1.<code>push</code>、数组尾部添加，返回修改i后数组长度</p><p>2.<code>pop</code>、数组尾部删除，返回删除的数据</p><p>3.<code>shift</code>、数组头部删除，返回删除的元素</p><p>4.<code>unshift</code>、数组头部添加，返回新数组长度</p><p>5.<code>splice</code>、删除数组任意位置元素</p><p><code>splice</code>(删除元素对应位置的索引,删除的个数[不填默认从头部开始删除],新增的元素)  ，返回值:删除的元素数组</p><p>6.<code>sort</code>   数组排序  </p><p>7.<code>reverse</code>  数组翻转</p><p>当你使用这些方法修改数组时，<code>Vue</code>能够检测到变化并及时更新视图</p><p><code>Vue</code>的数组变异方法通过重写数组的原型方法来实现。当你调用这些方法时，<code>Vue</code>会在修改数组之前和之后执行一些特定的逻辑，以便通知相关的依赖（比如视图）</p><p>以下是一个简单的例子，演示了如何在<code>Vue2</code>中监听数组的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Vue Array Mutation&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;addItem&quot;&gt;Add Item&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [1, 2, 3]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addItem: function() &#123;</span><br><span class="line">      this.items.push(this.items.length + 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在上面的例子中，当点击按钮时，<code>addItem</code> 方法会使用数组变异方法 <code>push</code> 向 <code>items</code> 数组中添加一个新的元素。由于<code>Vue</code>监听了这个数组的变化，它会在数组被修改后自动更新相关的视图，使新的元素在页面上显示出来。</p><p>需要注意的是，<code>Vue</code>对数组变异的监听仅限于这些特定的数组变异方法，直接通过索引修改数组的元素或修改 <code>length</code> 属性的方式是无法被Vue检测到的。如果你需要监听这些非变异操作，可以使用 <code>Vue.set</code> 方法或 <code>vm.$set</code> 方法</p><h2 id="有没有了解虚拟列表"><a href="#有没有了解虚拟列表" class="headerlink" title="有没有了解虚拟列表"></a>有没有了解虚拟列表</h2><p>虚拟列表（Virtual List）是一种优化长列表渲染性能的技术。当需要展示大量数据时，传统的方式是将所有数据都渲染到DOM中，这可能导致页面加载缓慢、占用大量内存和性能下降。虚拟列表通过只渲染用户当前可见的部分数据，以及根据滚动位置动态加载和卸载列表项，来减轻这些问题。</p><p>基本思想是只渲染视口（可见区域）内的数据项，而不是整个数据集。这可以通过以下几个关键概念来实现：</p><ol><li><strong>可视区域（Viewport）：</strong> 用户当前看到的部分页面。在虚拟列表中，只有可视区域内的数据项会被真正渲染到DOM中。</li><li><strong>滚动监听：</strong> 监听滚动事件，以确定用户浏览的位置。当用户滚动时，虚拟列表会相应地更新可视区域的内容。</li><li><strong>动态加载和卸载：</strong> 根据滚动位置，动态加载进入可视区域的数据项，同时卸载离开可视区域的数据项，以保持DOM的轻量级。</li></ol><p>虚拟列表的优势在于减少了初始加载时的渲染压力，提高了页面的响应速度。这对于处理大型数据集的情况非常有用，比如在前端框架 （如Vue、React等）中使用虚拟列表来渲染大量的列表数据。</p><p>实现虚拟列表的方式可以有多种，具体的实现可能依赖于所用的前端框架或库。许多现代前端框架都提供了虚拟列表的支持或者有相关的第三方库。</p><h2 id="vue2中element-ui的自动按需导入"><a href="#vue2中element-ui的自动按需导入" class="headerlink" title="vue2中element-ui的自动按需导入"></a>vue2中element-ui的自动按需导入</h2><h3 id="1-安装-babel-plugin-import-插件"><a href="#1-安装-babel-plugin-import-插件" class="headerlink" title="1. 安装 babel-plugin-import 插件"></a>1. 安装 babel-plugin-import 插件</h3><p>在项目中安装 <code>babel-plugin-import</code> 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-import -D</span><br></pre></td></tr></table></figure><h3 id="2-配置-babelrc-文件"><a href="#2-配置-babelrc-文件" class="headerlink" title="2. 配置 .babelrc 文件"></a>2. 配置 <code>.babelrc</code> 文件</h3><p>在项目根目录下创建 <code>.babelrc</code> 文件，配置插件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;import&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;element-ui&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-在-main-js-中引入-Element-UI-样式"><a href="#3-在-main-js-中引入-Element-UI-样式" class="headerlink" title="3. 在 main.js 中引入 Element UI 样式"></a>3. 在 main.js 中引入 Element UI 样式</h3><p>在你的 <code>main.js</code> 文件中引入 Element UI 的样式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br></pre></td></tr></table></figure><h3 id="libraryName-配置"><a href="#libraryName-配置" class="headerlink" title="libraryName 配置"></a>libraryName 配置</h3><p><code>libraryName</code> 选项通常用于指定按需加载的组件库的名称。对于 <code>babel-plugin-import</code> 插件，它的配置对象中还有一些其他可用的选项，可以根据需要进行配置。以下是一些常见的选项：</p><ol><li><strong>libraryName (字符串，必需)</strong>: 用于指定要按需加载的组件库的名称，即插件将按照这个名称来寻找组件并进行按需加载。</li><li><strong>libraryDirectory (字符串，默认为 “lib”)</strong>: 用于指定组件库源代码的目录，通常是包含组件定义的目录。这是相对于组件库的主目录的路径。</li><li><strong>style (布尔值或函数，默认为 true)</strong>: 是否同时导入样式文件。如果设置为 <code>true</code>，插件将尝试导入样式文件；如果设置为 <code>false</code>，则只导入 JavaScript 文件。你还可以提供一个函数，根据需要返回样式文件路径。</li><li><strong>camel2DashComponentName (布尔值，默认为 true)</strong>: 是否将组件名从驼峰式转为短横线形式。例如，<code>MyComponent</code> 可以被转换为 <code>my-component</code>。</li></ol><p>这里是一个示例配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;element-ui&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;libraryDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;camel2DashComponentName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="图片懒加载实现"><a href="#图片懒加载实现" class="headerlink" title="图片懒加载实现"></a>图片懒加载实现</h2><ol><li><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用<code>HTML5</code> 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p><p>注意：<code>data-xxx</code> 中的xxx可以自定义，这里我们使用<code>data-src</code>来定义。</p><p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p><p>使用原生<code>JavaScript</code>实现懒加载：<br>知识点：<br>（1）<code>window.innerHeight</code> 是浏览器可视区的高度<br>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离<br>（3）<code>imgs.off</code>Set<code>Top</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）<br>（4）图片加载条件：<code>img.offSetTop &lt; window.innerHeight + document.body.scrollTop;</code></p></li></ol><h2 id="vue-cli基于webpack底层封装了mode-环境变量配置-开发或是生产环境-可以实现手动配置选项覆盖"><a href="#vue-cli基于webpack底层封装了mode-环境变量配置-开发或是生产环境-可以实现手动配置选项覆盖" class="headerlink" title="vue-cli基于webpack底层封装了mode,环境变量配置(开发或是生产环境),可以实现手动配置选项覆盖"></a>vue-cli基于webpack底层封装了mode,环境变量配置(开发或是生产环境),可以实现手动配置选项覆盖</h2><h2 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h2><ol><li>!important（在属性后面写上这条样式，会覆盖掉页面上任何位置定义的元素的样式。）</li><li>行内样式，在style属性里面写的样式。</li><li>id选择器</li><li>class选择器</li><li>标签选择器</li><li>通配符选择器</li><li>浏览器的自定义属性和继承</li></ol><h3 id="可继承的属性有哪些"><a href="#可继承的属性有哪些" class="headerlink" title="可继承的属性有哪些"></a>可继承的属性有哪些</h3><p>以下是一些常见的可继承属性：</p><ol><li><strong>文本属性（Text Properties）</strong>：<ul><li><code>color</code>：文本颜色</li><li><code>font</code>：字体系列、字体大小等</li><li><code>font-family</code>：字体系列</li><li><code>font-size</code>：字体大小</li><li><code>font-style</code>：字体样式（正常、斜体等）</li><li><code>font-weight</code>：字体粗细</li></ul></li><li><strong>行高属性（Line Height Properties）</strong>：<ul><li><code>line-height</code>：行高</li></ul></li><li><strong>列表属性（List Properties）</strong>：<ul><li><code>list-style</code>：列表样式类型、位置等</li><li><code>list-style-type</code>：列表项标志的类型</li><li><code>list-style-position</code>：列表项标志的位置</li><li><code>list-style-image</code>：用作列表项标志的图像</li></ul></li><li><strong>表格布局属性（Table Layout Properties）</strong>：<ul><li><code>border-collapse</code>：表格边框的折叠方式</li><li><code>border-spacing</code>：表格边框的间距</li></ul></li><li><strong>用户界面属性（User Interface Properties）</strong>：<ul><li><code>cursor</code>：鼠标指针样式</li></ul></li><li><strong>可见性属性（Visibility Properties）</strong>：<ul><li><code>visibility</code>：元素的可见性</li></ul></li><li><strong>生成内容属性（Generated Content Properties）</strong>：<ul><li><code>content</code>：用于 ::before 和 ::after 伪元素的生成内容</li></ul></li><li><strong>光标属性（Cursors Properties）</strong>：<ul><li><code>cursor</code>：光标类型</li></ul></li></ol><p>需要注意的是，并非所有的属性都是可继承的。例如，<code>width</code>、<code>height</code>等尺寸相关的属性就不是可继承的</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol><li><p><strong>使用clearfix（清除浮动的伪元素）</strong>：</p><p>这是一种常见的清除浮动的方法，通过在父元素上应用伪元素清除浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>; <span class="comment">/* 兼容IE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父元素上添加 <code>clearfix</code> 类，这样就会在父元素最后插入一个空的块级元素，该元素通过 <code>clear: both;</code> 规则清除浮动。</p></li><li><p><strong>使用overflow属性</strong>：</p><p>将父元素的 <code>overflow</code> 属性设置为 <code>auto</code> 或 <code>hidden</code> 也可以触发 BFC（块级格式化上下文），从而清除浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 或 overflow: auto; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设置会创建一个新的 BFC，使得父元素包含浮动的子元素。</p></li></ol><h3 id="盒子居中方法"><a href="#盒子居中方法" class="headerlink" title="盒子居中方法"></a>盒子居中方法</h3><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><h4 id="2-脱标-利用margin自动实现居中"><a href="#2-脱标-利用margin自动实现居中" class="headerlink" title="2.脱标,利用margin自动实现居中"></a>2.脱标,利用margin自动实现居中</h4><h4 id="3-利用位移和定位"><a href="#3-利用位移和定位" class="headerlink" title="3.利用位移和定位"></a>3.利用位移和定位</h4><p><strong>定位移动的距离参考的父级的大小</strong></p><p><strong>位移移动参考的距离是自己自身的大小</strong></p><p>利用父相子绝,向右位移50%,向下位移50%,因为定位参考的大小是父级,这时就会超出了</p><p>向上反方向位移自身大小的50%这时子盒子就会居中显示</p><h2 id="自定义指令的生命周期"><a href="#自定义指令的生命周期" class="headerlink" title="自定义指令的生命周期"></a>自定义指令的生命周期</h2><ol><li><p><strong>bind:</strong></p><ul><li>当指令被第一次绑定到元素时触发。在这个阶段，你可以执行一次性的初始化设置。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">bind</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在绑定时执行一次性的初始化设置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>inserted:</strong></p><ul><li>当被绑定元素插入到 DOM 中时触发。通常用于执行初始化操作，比如获取焦点。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在元素插入到 DOM 时执行初始化操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>update:</strong></p><ul><li>在包含组件的 VNode 更新时触发，但可能在其子 VNode 更新之前。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件的 VNode 更新时触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>componentUpdated:</strong></p><ul><li>在包含组件的 VNode 及其子 VNode 全部更新后触发。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">componentUpdated</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件的 VNode 及其子 VNode 全部更新后触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>unbind:</strong></p><ul><li>在指令与元素解绑时触发。可以执行一些清理工作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">unbind</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在解绑时执行清理工作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>你在vue中给key添加一个属性,但是DOM没有刷新</p><ol><li><ul><li>如果你在对象或数组上新增属性或元素，Vue 也无法检测到变化。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">myArray</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">addElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这样新增的元素不会触发响应式更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myArray</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong> 同样，使用 <code>Vue.set</code> 方法或者扩展运算符来确保变化被观察到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">myArray</span>, <span class="variable language_">this</span>.<span class="property">myArray</span>.<span class="property">length</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用扩展运算符</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">myArray</span> = [...<span class="variable language_">this</span>.<span class="property">myArray</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol><li><p><strong>provide 选项：</strong></p><ul><li><code>provide</code> 选项允许你指定一个对象，其中包含你想要提供给后代组件的属性或方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParentComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello from parent!&#x27;</span>,</span><br><span class="line">    <span class="attr">showMessage</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>inject 选项：</strong></p><ul><li><code>inject</code> 选项用于接收祖先组件通过 <code>provide</code> 提供的值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;showMessage&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">// &#x27;Hello from parent!&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showMessage</span>(); <span class="comment">// Alert: &#x27;Hello!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以使用对象语法来更详细地配置注入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: &#123; <span class="attr">default</span>: <span class="string">&#x27;Default message&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">showMessage</span>: &#123; <span class="attr">default</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">// &#x27;Hello from parent!&#x27; 或者 &#x27;Default message&#x27;（如果没有被提供）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showMessage</span>(); <span class="comment">// 执行提供的函数，或者是空函数（如果没有被提供）</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="前端路由两个形式"><a href="#前端路由两个形式" class="headerlink" title="前端路由两个形式"></a>前端路由两个形式</h2><p>hash</p><p>history</p><h2 id="给你一个数组实现去重"><a href="#给你一个数组实现去重" class="headerlink" title="给你一个数组实现去重"></a>给你一个数组实现去重</h2><ol><li><p><strong>使用 Set（ES6）:</strong></p><ul><li>Set 是一种集合类型，它只允许存储唯一的值，因此可以用来快速去重数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 filter 方法:</strong></p><ul><li>使用 <code>filter</code> 方法结合 <code>indexOf</code> 或 <code>includes</code> 方法来筛选出不重复的元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.<span class="title function_">indexOf</span>(value) === index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure><p>或者使用 <code>includes</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.<span class="title function_">includes</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 reduce 方法:</strong></p><ul><li>使用 <code>reduce</code> 方法来构建一个新数组，只添加第一次出现的元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!accumulator.<span class="title function_">includes</span>(currentValue)) &#123;</span><br><span class="line">    accumulator.<span class="title function_">push</span>(currentValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Map 数据结构:</strong></p><ul><li>使用 Map 数据结构来存储数组中的唯一值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Map</span>(array.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> [item, item])).<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure></li></ol><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>computed计算属性具有&#x3D;&#x3D;缓存的特性&#x3D;&#x3D;,当我们初次访问的时候会把数据缓存起来,下次访问直接在缓存里面直接取,只有当依赖的数据发生变化时才会重新计算,它会返回一个经过&#x3D;&#x3D;计算之后的值&#x3D;&#x3D;,并且是只能&#x3D;&#x3D;执行同步任务&#x3D;&#x3D;</p><p>而watch起到的是一个观察的作用&#x3D;&#x3D;监听数据的变化&#x3D;&#x3D;,当监听的数据发生变化时就会,执行自定义的回调函数,它&#x3D;&#x3D;没有返回值&#x3D;&#x3D;,是可以&#x3D;&#x3D;执行异步任务&#x3D;&#x3D;,例如发起异步的ajax请求</p><h2 id="对SPA的理解"><a href="#对SPA的理解" class="headerlink" title="对SPA的理解"></a>对SPA的理解</h2><p>SPA（single-page application）翻译过来就是单页面应用程序,是一种网络应用程序或是网站的模型,它是通过动态的重写当前页面来实现与用户之间的交互,避免了页面之间的切换跳转打断用户的体验,所有页面上的资源和内容都是在用户点击访问的时候按需加载,在任何时候都不会重新加载页面</p><p>优点:</p><ul><li>有桌面应用端的快速访问的及时性和高效性</li><li>用户体验好,用户切换页面是不会重新加载整个页面</li><li>良好的前后端分离，分工更加明确</li></ul><p>缺点:</p><ul><li>首屏加载速度慢</li><li>只有一个html页面不利于seo搜索引擎抓取</li></ul><p>解决首屏加载慢问题</p><blockquote><p>1.减少入口文件的体积</p><p>2.静态资源本地缓存</p><p>3.ui框架的按需加载，不要使用全局导入</p><p>4.使用路由懒加载，只有在用户访问的时候才加载对应的页面内容</p><p>5.使用SSR,使用SSR可以在服务器端预先渲染页面，减少客户端渲染时间，提高页面加载速度和性能</p><p>6.组件重复打包,将SPA中重复使用的组件进行打包，避免重复加载相同的代码，减少服务器响应时间和带宽占用</p></blockquote><h2 id="v-show和v-if怎么理解"><a href="#v-show和v-if怎么理解" class="headerlink" title="v-show和v-if怎么理解"></a>v-show和v-if怎么理解</h2><p>都是依据条件来选择性的决定是否显示dom元素</p><p>v-show是通过动态的设置css的display: none&#x2F;block 来显示隐藏dom元素,dom元素还是在页面上的,占据位置</p><p>应用场景是页面的元素切换显示隐藏比较频繁,<strong>模态框的显示隐藏</strong></p><p>v-if是设置依据条件,创建或是销毁dom元素,销毁了后页面上是没有dom元素的,相较于v-show开销更加大</p><p>应用场景一般用在初始状态就是显示或是隐藏,在进入页面后**<font color="red">检查用户是否登录</font>**</p><h2 id="聊一聊vue的生命周期"><a href="#聊一聊vue的生命周期" class="headerlink" title="聊一聊vue的生命周期"></a>聊一聊vue的生命周期</h2><p>概念: vue实例从<font color="red">创建</font>到<font color="red">销毁</font>的整个过程就叫作生命周期</p><p>生命周期主要有四个阶段八个钩子函数分别是</p><table><thead><tr><th>生命周期钩子</th><th>阶段</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td><td>组件实例还未创建,常用于插件开发的一些初始化任务</td></tr><tr><td>created</td><td>创建后</td><td>组件初始化完毕,可以获取数据使用,常用于发起ajax的异步数据请求</td></tr><tr><td>beforeMount</td><td>挂载前</td><td>dom已被初始化,但并未挂载和渲染</td></tr><tr><td>mounted</td><td>挂载后</td><td>dom已完成挂载和渲染,可用于访问数据和操作页面的dom元素</td></tr><tr><td>beforeUpdate</td><td>更新前</td><td>数据已被更新,但页面数据并未更新</td></tr><tr><td>updated</td><td>更新后</td><td>数据已更新完毕</td></tr><tr><td>beforeDestroy</td><td>销毁前</td><td>实例销毁前,实例目前实例仍然可用,常用于一些定时器的清除</td></tr><tr><td>destroyed</td><td>销毁后</td><td>实例已被销毁完毕</td></tr></tbody></table><h4 id="题外话-数据请求在created和mounted的区别"><a href="#题外话-数据请求在created和mounted的区别" class="headerlink" title="题外话:数据请求在created和mounted的区别"></a>题外话:数据请求在created和mounted的区别</h4><p><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成；<code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的。触发时机上<code>created</code>是比<code>mounted</code>要更早的</p><p>两者的相同点：都能拿到实例对象的属性和方法。</p><p>讨论这个问题本质就是触发的时机，放在<code>mounted</code>中的请求时间超时就会造成页面渲染阻塞或是造成白屏的状况（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中</p><h2 id="vue实例挂载的过程中发生了什么"><a href="#vue实例挂载的过程中发生了什么" class="headerlink" title="vue实例挂载的过程中发生了什么"></a>vue实例挂载的过程中发生了什么</h2><p>首先找到<code>vue</code>的构造函数</p><p>源码位置：<code>src</code>\core\instance\index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options</code>是用户传递过来的配置项，如<code>data、methods</code>等常用的方法</p><p><code>vue</code>构建函数调用<code>_init</code>方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>);     <span class="comment">// 定义 _init</span></span><br><span class="line"><span class="title function_">stateMixin</span>(<span class="title class_">Vue</span>);    <span class="comment">// 定义 $`Set` $get $delete $watch 等</span></span><br><span class="line"><span class="title function_">eventsMixin</span>(<span class="title class_">Vue</span>);   <span class="comment">// 定义事件  $on  $once $off $emit</span></span><br><span class="line"><span class="title function_">lifecycleMixin</span>(<span class="title class_">Vue</span>);<span class="comment">// 定义 _update  $forceUpdate  $destroy</span></span><br><span class="line"><span class="title function_">renderMixin</span>(<span class="title class_">Vue</span>);   <span class="comment">// 定义 _render 返回虚拟dom</span></span><br></pre></td></tr></table></figure><p>首先可以看<code>initMixin</code>方法，发现该方法在<code>Vue</code>原型上定义了<code>_init</code>方法</p><p>源码位置：<code>src</code>\core\instance\init.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="comment">// 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 合并vue属性</span></span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化proxy拦截器</span></span><br><span class="line">      <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line">    <span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="comment">// 初始化组件事件侦听</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="comment">// 初始化渲染方法</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="comment">// 初始化依赖注入内容，在初始化data、props之前</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="comment">// 初始化props/data/method/watch/methods</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载元素</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">      vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>仔细阅读上面的代码，我们得到以下结论：</p><ul><li>在调用<code>beforeCreate</code>之前，数据初始化并未完成，像<code>data</code>、<code>props</code>这些属性无法访问到</li><li>到了<code>created</code>的时候，数据已经初始化完成，能够访问<code>data</code>、<code>props</code>这些属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li><li>挂载方法是调用<code>vm.$mount</code>方法</li></ul><p><code>initState</code>方法是完成<code>props/data/method/watch/methods</code>的初始化</p><p>源码位置：<code>src</code>\core\instance\state.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods方法</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们和这里主要看初始化<code>data</code>的方法为<code>initData</code>，它与<code>initState</code>在同一文件上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 获取到组件上的data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性名不能与方法名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性名不能与state名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 响应式监听data是数据的变化</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细阅读上面的代码，我们可以得到以下结论：</p><ul><li>初始化顺序：<code>props</code>、<code>methods</code>、<code>data</code></li><li><code>data</code>定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</li></ul><p>关于数据响应式在这就不展开详细说明</p><p>上文提到挂载方法是调用<code>vm.$mount</code>方法</p><p>源码位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 获取或查询元素</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// vue 不允许直接挂载到body或页面文档上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="variable language_">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 通过选择器获取元素内容</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  1.将temmplate解析ast tree</span></span><br><span class="line"><span class="comment">       *  2.将ast tree转换成render语法字符串</span></span><br><span class="line"><span class="comment">       *  3.生成render方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们能得到以下结论：</p><ul><li>不要将根元素放到<code>body</code>或者<code>html</code>上</li><li>可以在对象中定义<code>template/render</code>或者直接使用<code>template</code>、<code>el</code>表示元素选择器</li><li>最终都会解析成<code>render</code>函数，调用<code>compileToFunctions</code>，会将<code>template</code>解析成<code>render</code>函数</li></ul><p>对<code>template</code>的解析步骤大致分为以下几步：</p><ul><li>将<code>html</code>文档片段解析成<code>ast</code>描述符</li><li>将<code>ast</code>描述符解析成字符串</li><li>生成<code>render</code>函数</li></ul><p>生成<code>render</code>函数，挂载到<code>vm</code>上后，会再次调用<code>mount</code>方法</p><p>源码位置：<code>src</code>\platforms\web\runtime\index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 渲染组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>mountComponent</code>渲染组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告</span></span><br><span class="line">  <span class="comment">// render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有获取到vue的模板文件</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// we `Set` this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="comment">// 监听当前组件状态，当有数据变化时，更新组件</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们得到以下结论：</p><ul><li>会触发<code>beforeCreate</code>钩子</li><li>定义<code>updateComponent</code>渲染页面视图的方法</li><li>监听组件数据，一旦发生变化，触发<code>beforeUpdate</code>生命钩子</li></ul><p><code>updateComponent</code>方法主要执行在<code>vue</code>初始化时声明的<code>render</code>，<code>update</code>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render`的作用主要是生成`vnode</span><br></pre></td></tr></table></figure><p>源码位置：<code>src</code>\core\instance\render.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义vue 原型上的render方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// render函数来自于组件的option</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">        vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">            _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">            vm.<span class="property">$slots</span>,</span><br><span class="line">            vm.<span class="property">$scopedSlots</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Set` parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">        <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">        <span class="comment">// when parent component is patched.</span></span><br><span class="line">        currentRenderingInstance = vm</span><br><span class="line">        <span class="comment">// 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode</span></span><br><span class="line">        vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">        <span class="comment">// return error render result,</span></span><br><span class="line">        <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">        <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">                vnode = vm.<span class="property">_vnode</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">                vm</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `Set` parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中</p><p>源码位置：<code>src</code>\core\instance\lifecycle.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="comment">// 设置当前激活的作用域</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = <span class="string">`Set`</span><span class="title class_">ActiveInstance</span>(vm)</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      <span class="comment">// 执行具体的挂载逻辑</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h3><ul><li><code>new Vue</code>的时候调用会调用<code>_init</code>方法<ul><li>定义 <code>$</code>Set&#96;&#96;、<code>$get</code> 、<code>$delete</code>、<code>$watch</code> 等方法</li><li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off</code>等事件</li><li>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</li></ul></li><li>调用<code>$mount</code>进行页面的挂载</li><li>挂载的时候主要是通过<code>mountComponent</code>方法</li><li>定义<code>updateComponent</code>更新函数</li><li>执行<code>render</code>生成虚拟<code>DOM</code></li><li><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</li></ul><h2 id="为什么不建议v-for和v-if一起用"><a href="#为什么不建议v-for和v-if一起用" class="headerlink" title="为什么不建议v-for和v-if一起用"></a>为什么不建议v-for和v-if一起用</h2><p>v-if用于条件性的渲染页面dom元素</p><p>v-for遍历数组循环渲染列表数据</p><p>v-for的优先级比v-if要高,会先执行页面的循环渲染再依据v-if的条件选择性的渲染对应的元素,若是初次v-for循环渲染的时候有不符合条件的元素就会被渲染出来再依据v-if的条件来判断是否删除和创建元素,这样就会造成不必要的性能损耗</p><p>所以永远不要把v-if和v-show放在同一个元素上</p><p>如果必须要使用可以使用<strong>计算属性</strong>先把每个元素依据条件过滤一遍再执行渲染</p><h2 id="为什么data属性是一个函数而不是对象"><a href="#为什么data属性是一个函数而不是对象" class="headerlink" title="为什么data属性是一个函数而不是对象"></a>为什么data属性是一个函数而不是对象</h2><p>保持<strong>数据私有化</strong>,<strong>避免数据污染</strong>,如果data是一个普通的对象,当你创建多个相同的组件实例的时候,他们就会共享同一个数据对象,当你修改其中一个组件实例的数据是另外一个也会被修改,这样就会造成影响</p><p>如果是一个函数,当组件被创建的时候,函数被调用,返回的是一个新的数据对象,这样每一个组件的初始数据都是不一样的,保持数据的一个私有化,修改一个另外一个不会被影响到</p><h2 id="组件间的通信方式"><a href="#组件间的通信方式" class="headerlink" title="组件间的通信方式"></a>组件间的通信方式</h2><p>组件通讯可以分为<strong>组件</strong>和<strong>通讯</strong>两部分来理解</p><p><strong>组件</strong>:每一个<code>.vue</code>文件都可以理解为是一个组件</p><p><strong>通讯</strong>:是指以某种方式或是以某种手段来实现信息的传递或者是交互</p><p>每一个vue文件都有<strong>自己独立的作用域</strong>,组件之间的数据无法实现数据之间的共享,而我们在开发的时候有这种需求,组件通讯的目的就是实现<strong>组件之间数据的共享</strong>,把各个组件构成一个完整的有机的整体</p><p>组件之间的关系主要有<strong>父子关系</strong>和<strong>非父子</strong>关系</p><h3 id="父子组件之间的通讯"><a href="#父子组件之间的通讯" class="headerlink" title="父子组件之间的通讯"></a>父子组件之间的通讯</h3><h4 id="父向子传值"><a href="#父向子传值" class="headerlink" title="父向子传值"></a>父向子传值</h4><p>父向子传递父组件绑定一个自定义属性向子组件传递数据，子组件就可以使用props属性接收到传递过来的数据，进行页面渲染</p><h4 id="子向父传值"><a href="#子向父传值" class="headerlink" title="子向父传值"></a>子向父传值</h4><p>子向父传递数据使用$emit触发一个自定义事件，并传递数据，父组件监听到这个自定义事件就可以获取到这个数据，来操作获取到的数据</p><h3 id="非父子组件之间的传值"><a href="#非父子组件之间的传值" class="headerlink" title="非父子组件之间的传值"></a>非父子组件之间的传值</h3><h3 id="兄弟之间"><a href="#兄弟之间" class="headerlink" title="兄弟之间"></a>兄弟之间</h3><p>事件总线<code>eventbus</code>，一方传递数据<code>$emit</code>触发自定义事件并携带数据，另一方就可以使用<code>$on</code>监听到自定义事件和传递过来的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent</span><br></pre></td></tr></table></figure><h3 id="复杂组件"><a href="#复杂组件" class="headerlink" title="复杂组件"></a>复杂组件</h3><p>复杂的组件之间的通信推荐使用vuex,开发实际中使用的也是比较多的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">parent$emit</span>()</span><br></pre></td></tr></table></figure><h2 id="vue双向绑定的理解及原理"><a href="#vue双向绑定的理解及原理" class="headerlink" title="vue双向绑定的理解及原理"></a>vue双向绑定的理解及原理</h2><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数 据变动时发布消息给订阅者，触发相应的监听回调。</p><p>主要分为以下几 个步骤：</p><ol><li><p>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会 触发 setter，那么就能监听到了数据变化</p></li><li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化 渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数 据的订阅者，一旦数据有变动，收到通知，更新视图 </p></li><li><p>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做 的事情是:</p></li></ol><p> ①在自身实例化时往属性订阅器(dep)里面添加自己 </p><p>② 自身必须有一个 update()方法 ③待属性变动 dep.notice()通知时， 能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</p><ol start="4"><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果</li></ol><h2 id="谈谈你对-nextTick-的理解"><a href="#谈谈你对-nextTick-的理解" class="headerlink" title="谈谈你对 $nextTick 的理解"></a>谈谈你对 $nextTick 的理解</h2><p>vue在更新dom的时候是异步的,当数据发生变化的时候就会开启一个<strong>异步更新队列</strong>,页面视图需要等待队列中所有的<strong>数据完成变化之后再统一进行更新</strong></p><p>如果没有<code>$nextTick</code>那么每次修改数据都会触发页面视图的更新,有了<code>$nextTick</code>机制就只需要更新一次,本质上也是对性能的一种优化策略</p><p>使用场景:在<strong>修改数据后想要立即得到修改后的dom元素</strong>,或者是<strong>一进入页面就要对搜索框获取到焦点</strong>,就可以使用</p><h2 id="slot的理解，应用场景"><a href="#slot的理解，应用场景" class="headerlink" title="slot的理解，应用场景"></a>slot的理解，应用场景</h2><p>slot艺名叫做插槽，花名“占坑”，可以对组件内容进行个性化的diy定制，当我们使用组件的时候不会所有的组件的内容都是符合我们业务的需求，这个时候我门就需要使用插槽来完成我们的开发需求</p><p>应用场景</p><p>当我们的父组件在使用一个复用组件的时候，仅仅只需要修改一小部分内容，那我们再去重写一个一样的显然是不明智的，通过slot插槽向不同的位置分发不同的内容，实现组件在不同场景下的应用</p><p>三种插槽</p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>在子组件内使用slot标签来占位置，也可以在slot的标签内写入内容，这会作为标签的后备内容，如果父组件没有传递内容，就会显示设置的默认值，</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>顾名思义就是有名字的插槽</p><p>在子组件上使用name属性给插槽起一个名字（不填为默认插槽），父组件在分发内容的使用，v-slot&#x3D;属性名，来向子组件内分发指定的内容</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽其实就时可以带数据的插槽,即可以携带参数的插槽</p><p>简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。</p><p><strong>基本使用步骤:</strong></p><ol><li>在子组件的 slot 标签上使用自定义属性,携带数据传递给父组件</li><li>父组件使用 template 配合 v-slot 获取传递过来的数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &lt;td&gt;</span><br><span class="line">       &lt;!-- </span><br><span class="line">         注意: :item 相当于往插槽上加了一个自定义属性, 最终以对象包裹属性的形式传递过去</span><br><span class="line">         例如: 此处传过去的数据格式 &#123; item: item, index: index &#125;</span><br><span class="line">          --&gt;</span><br><span class="line">       &lt;slot :index=&quot;index&quot; :item=&quot;item&quot;&gt;&lt;/slot&gt;</span><br><span class="line">     &lt;/td&gt;</span><br><span class="line">&lt;MyTable :data=&quot;list&quot;&gt;</span><br><span class="line">   &lt;!-- </span><br><span class="line">     定义形参接收</span><br><span class="line">     插槽默认名字叫 default</span><br><span class="line">     可以简写为 #default=&quot;变量名&quot;,这个变量名保存的是由子组件传递过来的数据,</span><br><span class="line">     //一般通常情况下直接在这里对传递过来的对象进行解构操作,方便后面的使用</span><br><span class="line">     如果不用 # 也可以不指定名字, 直接写为 v-slot=&quot;变量名&quot;</span><br><span class="line">    --&gt;</span><br><span class="line">     完整写法: v-slot:default = &#x27;变量名&#x27;</span><br><span class="line">     简写形式: #default = &#x27;变量名&#x27;</span><br><span class="line">     不指定插槽名,接收数据:v-solt = &#x27;变量名&#x27; // 对象解构 v-solt = &#123; 属性名1,属性名2 , ...&#125;</span><br><span class="line">   &lt;template v-slot=&quot;scope&quot;&gt;</span><br><span class="line">     &lt;button @click=&quot;del(scope.item.id)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line"> &lt;/MyTable&gt;</span><br></pre></td></tr></table></figure><h2 id="vue-observable-你有了解过吗？"><a href="#vue-observable-你有了解过吗？" class="headerlink" title="vue.observable 你有了解过吗？"></a>vue.observable 你有了解过吗？</h2><h2 id="对vue中key的理解"><a href="#对vue中key的理解" class="headerlink" title="对vue中key的理解"></a>对vue中key的理解</h2><p>v-for数组循环列表给每一项添加一个唯一标识,主要是为了更加高效的更新dom元素,在没有key属性的时候,更新和改变数据的时候会将整个列表全部重新渲染,浪费性能</p><p>v-for默认采用的是就地复用的原则,当列表数据发生变化的时候,他会根据key属性去判断某一项到底是不是需要被修改,如果需要修改就直接渲染这一项否则就会复用之前的</p><h2 id="对keep-alive的理解，如何缓存当前组件、缓存后如何更新"><a href="#对keep-alive的理解，如何缓存当前组件、缓存后如何更新" class="headerlink" title="对keep-alive的理解，如何缓存当前组件、缓存后如何更新"></a>对keep-alive的理解，如何缓存当前组件、缓存后如何更新</h2><p>路由之间在切换的时候对应的组件就会被销毁和创建,这样就会导致状态丢失,keep-alive主要目的就是保持组件的状态,确保组件在销毁时不会丢失数据和状态而是把它缓存起来</p><p>使用:</p><p>使用<keep-alive>标签包裹需要缓存的组件即可</p><p>有三个属性:</p><ol><li>include:组件名数组,只有被匹配中的组件才会被缓存起来</li><li>exclude:组件名数组,任何被匹配中的组件都不会被缓存</li><li>max ,数字,最多缓存多少组件</li></ol><p>keep-alive会触发两个生命周期函数</p><ol><li>activated,在进入组件的时候触发</li><li>deactivated,在离开组件的时候触发</li></ol><p>组件在被缓存后就不会有created,beforemount,mounted 钩子函数了,只会有在进入页面的时候的那一次,所以提供了activated和deactivated钩子函数来帮我们实现业务需求</p><h3 id="keep-alive原理"><a href="#keep-alive原理" class="headerlink" title="keep alive原理"></a>keep alive原理</h3><h2 id="vue常用修饰符，应用场景"><a href="#vue常用修饰符，应用场景" class="headerlink" title="vue常用修饰符，应用场景"></a>vue常用修饰符，应用场景</h2><p>表单修饰符</p><p><code>.lazy</code></p><p><code>.trim</code> 去除表单首尾的空格</p><p><code>.number</code> 将用户输入的值转换为数字类型</p><p>事件修饰符</p><p><code>.stop</code>  阻止事件冒泡</p><p><code>.prevent</code>  阻止默认行为</p><p><code>.once</code>  绑定事件后只会触发一次</p><p>按键修饰符</p><p><code>.enter</code></p><p><code>.tab</code></p><p><code>.esc</code></p><p>….</p><p><code>v-bind</code>修饰符</p><p><code>.sync</code>   数据的双向绑定</p><h2 id="你有写过自定义指令吗？应用场景"><a href="#你有写过自定义指令吗？应用场景" class="headerlink" title="你有写过自定义指令吗？应用场景"></a>你有写过自定义指令吗？应用场景</h2><p><code>vue</code>的核心就是由数据驱动视图，为了方便的实现数据驱动视图，<code>vue</code>设计了一些内置的由v-开头的指令来实现不同的功能。像常用的有<code>v-model</code>的双向数据绑定，<code>v-bind</code>的数据绑定，<code>v-if</code>，<code>v-else</code>的数据的条件渲染等等</p><p>但是有的时候并不是所有的指令都满足我们的需求，<code>vue</code>也是支持我们自己自定义指令的，实现个性化的需求</p><p>组件的注册又分为全局注册和局部注册</p><p>全局注册</p><p>全局注册在<code>main.js</code>里面使用<code>Vue.directive</code>方法进行注册，该方法会接受两个参数，一个是要自定义的指令的名字，一个是指令的配置对象配置对象里面会有一个<code>insered</code>指令的钩子函数会在被插入到<code>dom</code>树上时自动执行，并把绑定了该指令的对象传递过来，我们就可以对该元素进行一些你自己想要的一些自定义需求</p><p>局部注册</p><p>局部注册在组件的<code>options</code>选项中设置<code>directives</code>属性，和全局注册差不多，里面有自定义的指令名，和配置对象，等绑定了自定义指令的元素被插入到<code>dom</code>树上面的时候对它进行你自己想要的自定义操作</p><p>应用场景</p><p>封装一个<code>v-focus</code>在初始一进入页面时就获取到<code>input</code>框的一个焦点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.directive(指令名,配置对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inserted() 是指令的钩子函数,被指令绑定了的元素会在被插入到 DOM 树上时自动执行</span></span><br><span class="line"><span class="comment">//执行时会将绑定该指令的元素传过来,然后就可以对其进行操作了</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者是封装一个v-throttle的一个阻止表单重复提交的一个自定义指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cbFun;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) &#123; <span class="comment">// 第一次执行</span></span><br><span class="line">        cbFun = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          cbFun = <span class="literal">null</span>;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>权限校验自定义指令</p><h2 id="vue中的过滤器了解过吗？应用场景"><a href="#vue中的过滤器了解过吗？应用场景" class="headerlink" title="vue中的过滤器了解过吗？应用场景"></a>vue中的过滤器了解过吗？应用场景</h2><h2 id="什么是虚拟DOM？如何实现一个虚拟DOM"><a href="#什么是虚拟DOM？如何实现一个虚拟DOM" class="headerlink" title="什么是虚拟DOM？如何实现一个虚拟DOM"></a>什么是虚拟DOM？如何实现一个虚拟DOM</h2><p>虚拟 DOM 的解析过程：</p><p> 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将 其表示出来，比如一个元素对象，包含 TagName、props 和 Children 70 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段 插入到文档中</p><p>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候， 首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象 树和旧的对象树进行比较，记录下两棵树的的差异</p><p> 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了</p><h2 id="了解diff算法吗？"><a href="#了解diff算法吗？" class="headerlink" title="了解diff算法吗？"></a>了解diff算法吗？</h2><p>在新老虚拟 DOM 对比时：</p><p> 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换 如果为相同节点，进行 patchVnode，判断如何对该节点的子节点进行处理</p><p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除) </p><p>比较如果都有子节点，则进行 updateChildren，判断如何对这些新 老节点的子节点进行操作（diff 核心）</p><p> 匹配时，找到相同的子节点，递归比较子节点 在 diff 中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从 O(n 3)降低值 O(n)，也就是说，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较</p><h2 id="vue2及vue3的区别"><a href="#vue2及vue3的区别" class="headerlink" title="vue2及vue3的区别"></a>vue2及vue3的区别</h2><ol><li><strong>性能优化：</strong><ul><li>Vue 3引入了响应式系统的重大改进，通过Proxy实现了更高效的响应式数据追踪，从而提高了性能。</li><li>Vue 3的编译器生成的代码更小，运行时性能更好，使应用程序加载更快。</li></ul></li><li><strong>Composition API：组合API：</strong><ul><li>Vue 3引入了<code>Composition API</code>，这是一种新的API风格，使得组件的逻辑更易于组织和重用。<code>Composition API</code>允许开发者按照功能划分代码，而不是像Vue 2那样按照选项的顺序。</li></ul></li><li><strong>全局 API的修改：</strong><ul><li>在Vue 3中，全局API发生了一些变化，例如<code>Vue.component</code>变成了<code>app.component</code>，<code>Vue.directive</code>变成了<code>app.directive</code>等。这是为了更好地支持模块化的开发方式。</li></ul></li><li><strong>Teleport：传送：</strong><ul><li>Vue 3引入了Teleport组件，用于更灵活地在DOM中的不同位置渲染组件，这在处理模态框等场景时非常有用。</li></ul></li><li><strong>Fragment和多根节点：</strong><ul><li>Vue 3允许组件返回多个根节点，而Vue 2要求组件有且只有一个根节点。Vue 3还引入了Fragment语法，使得在模板中使用多个根节点更加方便。</li></ul></li><li><strong>动态属性：</strong><ul><li>在Vue 3中，可以使用<code>v-bind</code>绑定动态的属性名，而在Vue 2中需要使用<code>v-bind</code>和<code>v-on</code>的结合来实现。</li></ul></li></ol><h2 id="vue项目本地开发完成后部署到服务器后报404是什么原因呢？"><a href="#vue项目本地开发完成后部署到服务器后报404是什么原因呢？" class="headerlink" title="vue项目本地开发完成后部署到服务器后报404是什么原因呢？"></a>vue项目本地开发完成后部署到服务器后报404是什么原因呢？</h2><p>项目使用<code>history</code>需要后端搭配进行配置,当我们在地址栏输入 <code>www.xxx.com</code> 时，这时会打开我们 <code>dist</code> 目录下的 <code>index.html</code> 文件，然后我们在跳转路由进入到 <code>www.xxx.com/login</code></p><p>关键在这里，当我们在 <code>website.com/login</code> 页执行刷新操作，<code>nginx location</code> 是没有相关配置的，所以就会出现 404 的情况</p><p>修改规则无论我们访问任何页面都会重定向到<code>index.html</code></p><h2 id="你是怎么处理vue项目中的错误的？"><a href="#你是怎么处理vue项目中的错误的？" class="headerlink" title="你是怎么处理vue项目中的错误的？"></a>你是怎么处理vue项目中的错误的？</h2><h2 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h2><p>1.加载渲染过程</p><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p>2.子组件更新过程</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>3.父组件更新过程</p><p>父beforeUpdate-&gt;父updated</p><p>4.销毁过程</p><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h2 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h2><p>在Vue中，你可以使用”watch”特性来监听对象或数组中某个属性的变化。对于对象，你可以使用<code>$watch</code>方法，而对于数组，你可以使用<code>$watch</code>方法或者直接使用<code>Vue.Set</code>来确保数组变动也被观察到。以下是一些示例：</p><h3 id="对象属性的监听"><a href="#对象属性的监听" class="headerlink" title="对象属性的监听"></a>对象属性的监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;Change Name&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        name: &#x27;John&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.user.name = &#x27;Doe&#x27;; // 这里修改了对象的属性</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#x27;user.name&#x27;: function(newVal, oldVal) &#123;</span><br><span class="line">      console.log(`Name changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在上述例子中，通过<code>watch</code>选项，我们监听了<code>user.name</code>的变化。</p><h3 id="数组元素的监听"><a href="#数组元素的监听" class="headerlink" title="数组元素的监听"></a>数组元素的监听</h3><h4 id="使用-watch"><a href="#使用-watch" class="headerlink" title="使用 $watch"></a>使用 <code>$watch</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;button @click=&quot;changeItem(index)&quot;&gt;Change Item&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Cherry&#x27;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeItem(index) &#123;</span><br><span class="line">      this.$`Set`(this.items, index, &#x27;New Value&#x27;); // 使用$`Set`确保变化被观察</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    items: function(newVal, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;Array changed&#x27;, newVal, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-Vue-Set"><a href="#使用-Vue-Set" class="headerlink" title="使用 Vue.Set"></a>使用 Vue.Set</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;button @click=&quot;changeItem(index)&quot;&gt;Change Item&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Cherry&#x27;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeItem(index) &#123;</span><br><span class="line">      Vue.Set(this.items, index, &#x27;New Value&#x27;); // 直接使用Vue.Set</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    items: function(newVal, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;Array changed&#x27;, newVal, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这两个数组的例子中，我们通过<code>watch</code>选项监听了整个数组的变化。如果你需要监听特定元素的变化，你可以使用更深层次的属性路径，就像在对象属性监听的例子中一样。</p><h2 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h2><p>相同点： assets 和 static 两个都是存放静态资源文件。项目中所 需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下 </p><p>不相同点：assets 中存放的静态资源文件在项目打包时，也就是运 行 npm run build 时会将 assets 中放置的静态资源文件进行打包 上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后 的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。</p><p>static 中放置的静态资源文件就不会要走打包 压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。 因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也 就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据 更大的空间。</p><p> 建议： </p><p>将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包这一流程。减少体积。</p><p>而项目中引入的第三方的 资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这 些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h2 id="VueRouter是什么-有那些组件"><a href="#VueRouter是什么-有那些组件" class="headerlink" title="VueRouter是什么, 有那些组件"></a>VueRouter是什么, 有那些组件</h2><h2 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h2><p>route相当于正在跳转的路由对象，可以从route里面获取[hash]，name ，path，query，matched等属性方法</p><p>router 是VueRouter的实例，router是一个全局的路由对象，里面有很多的属性和方法 ，比如：router.push,route.options等等</p><h2 id="路由开发的优缺点"><a href="#路由开发的优缺点" class="headerlink" title="路由开发的优缺点"></a>路由开发的优缺点</h2><p>优点：</p><p>● 整体不刷新页面，用户体验更好<br>● 数据传递容易, 开发效率高 </p><p>缺点：</p><p>●开发成本高(需要学习专门知识)<br>●首次加载会比较慢一点。不利于seo</p><h2 id="VueRouter的使用方式"><a href="#VueRouter的使用方式" class="headerlink" title="VueRouter的使用方式"></a>VueRouter的使用方式</h2><p>1使用Vue.use( )将VueRouter插入<br>2创建路由规则<br>3创建路由对象<br>4将路由对象挂到 Vue 实例上<br>5设置路由挂载点</p><h2 id="路由跳转有那些方式"><a href="#路由跳转有那些方式" class="headerlink" title="路由跳转有那些方式"></a>路由跳转有那些方式</h2><ol><li><p><strong>通过 <code>this.$router.push</code> 方法：</strong></p><ul><li>在Vue组件中，你可以通过<code>this.$router.push</code>方法进行编程式的导航。可以传递一个路径或一个描述地址的对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 字符串路径</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/path&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>该方法会导致路由的切换，类似于用户点击浏览器的前进或后退按钮。</p></li><li><p><strong>通过 <code>this.$router.replace</code> 方法：</strong></p><ul><li>与<code>push</code>方法类似，但是不会留下历史记录，不会在浏览器的历史堆栈中创建新的记录。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 <code>this.$router.go</code> 方法：</strong></p><ul><li>用于在浏览器的历史记录中前进或后退指定步数。可以传递一个负数表示后退，正数表示前进。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// 后退一步</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="number">1</span>);  <span class="comment">// 前进一步</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="编程式导航使用的方法以及常用的方法"><a href="#编程式导航使用的方法以及常用的方法" class="headerlink" title="编程式导航使用的方法以及常用的方法"></a>编程式导航使用的方法以及常用的方法</h2><ol><li><p><strong>使用 <code>$router.push</code>：</strong></p><ul><li><code>$router.push</code> 方法用于向 history 栈添加一个新的记录，然后导航到该记录。它接受一个字符串路径或一个描述地址的对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 字符串路径</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/path&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>$router.replace</code>：</strong></p><ul><li><code>$router.replace</code> 方法与 <code>$router.push</code> 类似，但是它不会留下历史记录，而是替换当前的记录。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>$router.go</code>：</strong></p><ul><li><code>$router.go</code> 方法用于在浏览器的历史记录中前进或后退指定步数。可以传递一个负数表示后退，正数表示前进。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// 后退一步</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="number">1</span>);  <span class="comment">// 前进一步</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>$router.back</code> 和 <code>$router.forward</code>：</strong></p><ul><li><code>$router.back</code> 方法相当于 <code>$router.go(-1)</code>，用于后退一步。<code>$router.forward</code> 方法相当于 <code>$router.go(1)</code>，用于前进一步。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>();    <span class="comment">// 后退一步</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>(); <span class="comment">// 前进一步</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="路由的传参方式"><a href="#路由的传参方式" class="headerlink" title="路由的传参方式"></a>路由的传参方式</h2><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.png"></p><h2 id="路由重定向和404"><a href="#路由重定向和404" class="headerlink" title="路由重定向和404"></a>路由重定向和404</h2><p>1 匹配path后, 强制切换到另一个目标path上<br>2 redirect 是设置要重定向到哪个路由路径<br>3 网页默认打开, 匹配路由”&#x2F;“, 强制切换到”&#x2F;find”上<br>4 redirect配置项, 值为要强制切换的路由路径<br>5 强制重定向后, 还会重新来数组里匹配一次规则</p><h2 id="路由配置项常用的属性及作用"><a href="#路由配置项常用的属性及作用" class="headerlink" title="路由配置项常用的属性及作用"></a>路由配置项常用的属性及作用</h2><p>路由配置参数：</p><p> path : 跳转路径  </p><p> component : 路径相对于的组件   </p><p>name:命名路由   </p><p>children:子路由的配置参数(路由嵌套)   </p><p>props:路由解耦   </p><p>redirect : 重定向路由</p><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol><li><p><strong>全局前置守卫 (<code>beforeEach</code>)：</strong></p><ul><li><code>beforeEach</code> 全局前置守卫会在路由切换开始前被调用。可以用来进行一些全局的权限校验或导航控制。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 在路由切换前执行一些逻辑</span><br><span class="line">  if (to.meta.requiresAuth &amp;&amp; !auth.loggedIn) &#123;</span><br><span class="line">    next(&#x27;/login&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>全局解析守卫 (<code>beforeResolve</code>)：</strong></p><ul><li><code>beforeResolve</code> 全局解析守卫会在导航被确认之前，解析异步组件。它类似于 <code>beforeEach</code>，但是在全局后置守卫之前调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">  // 在导航被确认之前执行一些逻辑</span><br><span class="line">  // ...</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>全局后置守卫 (<code>afterEach</code>)：</strong></p><ul><li><code>afterEach</code> 全局后置守卫会在路由切换完成后被调用。可以用来进行一些清理或日志记录等操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // 在路由切换后执行一些逻辑</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>路由独享守卫 (<code>beforeEnter</code>)：</strong></p><ul><li><code>beforeEnter</code> 路由独享守卫可以直接在路由配置中定义，仅对该路由生效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> const route = &#123;</span><br><span class="line">  path: &#x27;/example&#x27;,</span><br><span class="line">  component: Example,</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    // 在进入路由前执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>组件内守卫 (<code>beforeRouteEnter</code>, <code>beforeRouteUpdate</code>, <code>beforeRouteLeave</code>)：</strong></p><ul><li>这些守卫钩子是在组件内部定义的。<code>beforeRouteEnter</code> 在路由进入时调用，<code>beforeRouteUpdate</code> 在路由更新时调用，<code>beforeRouteLeave</code> 在路由离开时调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">  beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">    // 在路由进入时执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, from, next) &#123;</span><br><span class="line">    // 在路由更新时执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">    // 在路由离开时执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="说说你对vuex的理解"><a href="#说说你对vuex的理解" class="headerlink" title="说说你对vuex的理解"></a>说说你对vuex的理解</h2><ol><li><strong>状态 (State):</strong><ul><li>Vuex 的核心就是一个全局的状态存储，即存放所有组件共享的数据。这些数据被称为状态 (state)，通常以一个 JavaScript 对象的形式存在。</li></ul></li><li><strong>状态的改变 (Mutations):</strong><ul><li>状态的变更必须通过 mutations 进行。mutations 是包含一系列对状态进行操作的方法。每个 mutation 都有一个字符串的事件类型 (type) 和一个回调函数，负责实际修改状态。</li></ul></li><li><strong>动作 (Actions):</strong><ul><li>Actions 用于处理异步操作，通过提交 mutations 来修改状态。Actions 提供了一种将业务逻辑和异步操作从组件中抽离的方式，使得代码更容易维护和测试。</li></ul></li><li><strong>模块 (Modules):</strong><ul><li>为了应对大型应用中的状态管理问题，Vuex 允许将 store 分割成模块 (modules)。每个模块可以有自己的 state、mutations、actions、getters，使得代码组织更加灵活。</li></ul></li><li><strong>Getter:</strong><ul><li>Getters 允许你在访问状态时进行一些计算，类似于 Vue 中的计算属性。它们对 store 中的状态进行派生，返回新的值。</li></ul></li><li><strong>单一状态树 (Single State Tree):</strong><ul><li>Vuex 使用单一状态树来存储整个应用的状态。这使得状态的变化变得可追踪，方便调试和查看整个应用的状态。</li></ul></li><li><strong>严格模式 (Strict Mode):</strong><ul><li>Vuex 提供了严格模式，可以在开发环境中检测状态的修改是否是通过 mutations 进行的。这有助于捕获在组件外部直接修改状态的错误。</li></ul></li><li><strong>插件 (Plugins):</strong><ul><li>Vuex 允许通过插件的方式扩展其功能。你可以编写插件来添加额外的特性，例如日志、持久化存储等。</li></ul></li></ol><h2 id="数据不响应的情况有哪些-如何解决"><a href="#数据不响应的情况有哪些-如何解决" class="headerlink" title="数据不响应的情况有哪些,如何解决"></a>数据不响应的情况有哪些,如何解决</h2><ol><li><p><strong>直接赋值：</strong></p><ul><li>如果你直接使用<code>=</code>对一个对象或数组进行赋值，Vue 无法检测到变化。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    myObject: &#123; key: &#x27;value&#x27; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  updateObject() &#123;</span><br><span class="line">    // 这样的赋值不会触发响应式更新</span><br><span class="line">    this.myObject = &#123; newKey: &#x27;newValue&#x27; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong> 使用 <code>Vue.Set</code> 方法或者扩展运算符 (…) 来确保对象的属性或数组的元素被观察到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 使用 Vue.`Set`</span><br><span class="line">Vue.`Set`(this.myObject, &#x27;newKey&#x27;, &#x27;newValue&#x27;);</span><br><span class="line"></span><br><span class="line">// 或者使用扩展运算符</span><br><span class="line">this.myObject = &#123; ...this.myObject, newKey: &#x27;newValue&#x27; &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>新增属性或元素：</strong></p><ul><li>如果你在对象或数组上新增属性或元素，Vue 也无法检测到变化。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    myArray: [1, 2, 3]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  addElement() &#123;</span><br><span class="line">    // 这样新增的元素不会触发响应式更新</span><br><span class="line">    this.myArray.push(4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong> 同样，使用 <code>Vue.Set</code> 方法或者扩展运算符来确保变化被观察到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 使用 Vue.`Set`</span><br><span class="line">Vue.set(this.myArray, this.myArray.length, 4);</span><br><span class="line"></span><br><span class="line">// 或者使用扩展运算符</span><br><span class="line">this.myArray = [...this.myArray, 4];</span><br></pre></td></tr></table></figure></li><li><p><strong>异步更新问题：</strong></p><ul><li>当在一个异步操作中修改数据时，Vue 也可能无法立即检测到变化。例如，在回调函数中修改数据：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    message: &#x27;Hello&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  asyncUpdate() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 这样的修改可能无法触发响应式更新</span><br><span class="line">      this.message = &#x27;Updated Message&#x27;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong> 使用 <code>this.$nextTick</code> 来确保在下一次 DOM 更新循环中修改数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> asyncUpdate() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">      this.message = &#x27;Updated Message&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="vue-use的原理"><a href="#vue-use的原理" class="headerlink" title="vue.use的原理"></a>vue.use的原理</h2><p><code>Vue.use</code> 是用来注册 Vue.js 插件的方法。当你使用 <code>Vue.use</code> 注册一个插件时，实际上它调用了插件的 <code>install</code> 方法。这个方法可以用来添加全局级别的功能，如全局组件、指令、过滤器，或者向Vue的原型中添加方法。</p><p>具体来说，<code>Vue.use</code> 的原理主要包括以下步骤：</p><ol><li><p><strong>检查插件是否已经被安装：</strong></p><ul><li><code>Vue.use</code> 方法内部会检查插件是否已经被安装，避免重复注册。</li></ul></li><li><p><strong>调用插件的 <code>install</code> 方法：</strong></p><ul><li>如果插件尚未安装，<code>Vue.use</code> 会调用插件的 <code>install</code> 方法。这个方法通常在插件的主文件中定义。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span>(<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 在这里添加全局功能</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>install</code> 方法的第一个参数是 Vue 构造函数，第二个参数是插件的选项。你可以在这个方法中添加全局组件、指令、过滤器，或者向Vue的原型中添加方法。</p></li><li><p><strong>标记插件已安装：</strong></p><ul><li>一旦插件的 <code>install</code> 方法被调用，<code>Vue.use</code> 会标记插件已经被安装，避免重复注册。</li></ul></li><li><p><strong>全局注册组件、指令、过滤器：</strong></p><ul><li>在 <code>install</code> 方法中，你可以利用 Vue 的 API 全局注册组件、指令、过滤器。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span>(<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, <span class="title class_">MyComponent</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册指令</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, <span class="title class_">MyDirective</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册过滤器</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;my-filter&#x27;</span>, <span class="title class_">MyFilter</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>总的来说，<code>Vue.use</code> 的实现非常简单，它主要是通过调用插件的 <code>install</code> 方法来完成插件的注册和安装工作。这样做的好处是可以让插件的使用变得简单而一致，通过一行代码就能完成插件的注册。</p><h2 id="mixin的作用-和组件冲突的优先级"><a href="#mixin的作用-和组件冲突的优先级" class="headerlink" title="mixin的作用,和组件冲突的优先级"></a>mixin的作用,和组件冲突的优先级</h2><p><code>mixin</code> 是 Vue 中一种重用组件选项的方式。它允许你在多个组件之间共享组件选项，从而实现代码的复用。<code>mixin</code> 对象可以包含组件选项，如 <code>data</code>、<code>methods</code>、<code>computed</code> 等，以及生命周期钩子。</p><h3 id="mixin-的作用："><a href="#mixin-的作用：" class="headerlink" title="mixin 的作用："></a><code>mixin</code> 的作用：</h3><ol><li><strong>代码复用：</strong><ul><li>通过使用 <code>mixin</code>，你可以将一些组件选项提取出来，使其可以在多个组件中重复使用。这在一些具有相似功能或行为的组件中特别有用。</li></ul></li><li><strong>逻辑分离：</strong><ul><li>将一些通用的逻辑从组件中抽离，通过 <code>mixin</code> 进行管理，有助于使组件更加清晰、易于维护。</li></ul></li><li><strong>动态混入：</strong><ul><li><code>mixin</code> 可以动态地混入到组件中，实现更灵活的组合方式。</li></ul></li></ol><h3 id="组件和-mixin-冲突的优先级："><a href="#组件和-mixin-冲突的优先级：" class="headerlink" title="组件和 mixin 冲突的优先级："></a>组件和 <code>mixin</code> 冲突的优先级：</h3><p>当一个组件和一个或多个 <code>mixin</code> 都定义了相同的选项时，它们之间的优先级是有规则的。以下是优先级的规则：</p><ol><li><strong>全局 <code>mixin</code>：</strong><ul><li>如果有全局 <code>mixin</code>，它将首先被应用，其选项将被混入到每个组件中。</li></ul></li><li><strong>局部 <code>mixin</code>：</strong><ul><li>接下来，如果在组件中使用了局部 <code>mixin</code>，那么局部 <code>mixin</code> 的选项将覆盖全局 <code>mixin</code> 的选项。</li></ul></li><li><strong>组件本身：</strong><ul><li>最后，组件本身的选项将覆盖全局 <code>mixin</code> 和局部 <code>mixin</code> 的选项。</li></ul></li></ol><p>这意味着，如果组件和 <code>mixin</code> 定义了相同的选项，组件的定义将具有最高的优先级，其选项将覆盖 <code>mixin</code> 中相同选项的值。</p><h2 id="如何强制更新vue组件"><a href="#如何强制更新vue组件" class="headerlink" title="如何强制更新vue组件"></a>如何强制更新vue组件</h2><h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1><h2 id="vue3-0的设计目标是什么？做了哪些优化"><a href="#vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="vue3.0的设计目标是什么？做了哪些优化"></a>vue3.0的设计目标是什么？做了哪些优化</h2><p>（1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的 反应性跟踪。 </p><p>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的 很多限制： </p><p>（2）只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、<code>Set</code>、WeakMap 和 Weak<code>Set</code>。</p><p> （3）模板 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染， 而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重 新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方 便习惯直接使用 api 来生成 vdom 。</p><p> （4）对象式的组件声明方式 vue2.x 中 的 组 件 是 通 过 声 明 的 方 式 传 入 一 系 列 option， 和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功 能，但是比较麻烦。 68 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易 </p><p>（5）其它方面的更改 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</p><p> 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。</p><p> 基于 tree shaking 优化，提供了更多的内置功能。</p><h2 id="vue3-0性能的提升主要通过那几个方面体现的"><a href="#vue3-0性能的提升主要通过那几个方面体现的" class="headerlink" title="vue3.0性能的提升主要通过那几个方面体现的"></a>vue3.0性能的提升主要通过那几个方面体现的</h2><h2 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 Set 、get 和 deleteProperty 等 处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截， 有以下特点∶ </p><p>不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 </p><p>全方位的数组变化检测，消除了 Vue2 无效的边界情况。</p><p> 支持 Map，Set，WeakMap 和 Weakset。 </p><p>Proxy 实现的响应式原理与 Vue2 的实现原理相同，实现方式大同小 异∶</p><p>get 收集依赖 </p><p>Set、delete 等触发依赖 对于集合类型，就是对集合对象的方法做一层包装：</p><p>原方法执行后执 行依赖相关的收集或触发逻辑。</p><h2 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h2><h3 id="1-组织代码的方式："><a href="#1-组织代码的方式：" class="headerlink" title="1. 组织代码的方式："></a>1. <strong>组织代码的方式：</strong></h3><ul><li><p><strong>Options API：</strong></p><ul><li>Options API 使用选项对象（options object）的方式组织代码。在一个组件中，数据、计算属性、方法、生命周期钩子等都被放在一个对象中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello, Vue!&#x27;,</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    doubleCount() &#123;</span><br><span class="line">      return this.count * 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Composition API：</strong></p><ul><li>Composition API 允许开发者按照功能划分代码，将相关的代码逻辑组织在一起，而不是按照选项的形式组织。每个功能可以通过 &#96;&#96;Set<code>up</code> 函数中的返回值来进行导出和重用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  Setup() &#123;</span><br><span class="line">    const message = ref(&#x27;Hello, Vue!&#x27;);</span><br><span class="line">    const count = ref(0);</span><br><span class="line"></span><br><span class="line">    const doubleCount = computed(() =&gt; count.value * 2);</span><br><span class="line"></span><br><span class="line">    const increment = () =&gt; &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      message,</span><br><span class="line">      count,</span><br><span class="line">      doubleCount,</span><br><span class="line">      increment</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-响应式数据的声明："><a href="#2-响应式数据的声明：" class="headerlink" title="2. 响应式数据的声明："></a>2. <strong>响应式数据的声明：</strong></h3><ul><li><p><strong>Options API：</strong></p><ul><li>在 Options API 中，响应式数据通常通过 <code>data</code> 方法返回的对象进行声明。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    message: &#x27;Hello, Vue!&#x27;,</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Composition API：</strong></p><ul><li>在 Composition API 中，可以使用 <code>ref</code>、<code>reactive</code> 等函数来声明响应式数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const message = ref(&#x27;Hello, Vue!&#x27;);</span><br><span class="line">const count = ref(0);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-生命周期钩子："><a href="#3-生命周期钩子：" class="headerlink" title="3. 生命周期钩子："></a>3. <strong>生命周期钩子：</strong></h3><ul><li><p><strong>Options API：</strong></p><ul><li>在 Options API 中，生命周期钩子直接作为对象的属性进行声明。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#x27;Component created&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUnmount() &#123;</span><br><span class="line">    console.log(&#x27;Component will be unmounted&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Composition API：</strong></p><ul><li>在 Composition API 中，生命周期钩子使用 <code>onXXX</code> 的形式进行声明。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; onMounted, onBeforeUnmount &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">onBeforeUnmount(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Component will be unmounted&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-代码重用："><a href="#4-代码重用：" class="headerlink" title="4. 代码重用："></a>4. <strong>代码重用：</strong></h3><ul><li><strong>Options API：</strong><ul><li>在 Options API 中，代码重用通常通过混入（mixins）来实现，但有时可能会导致命名冲突或复杂性。</li></ul></li><li><strong>Composition API：</strong><ul><li>Composition API 明确支持逻辑的提取和重用，通过将相关逻辑放在一个函数内，并在 <code>Setup</code> 中导入和调用。</li></ul></li></ul><h3 id="5-Typescript-支持："><a href="#5-Typescript-支持：" class="headerlink" title="5. Typescript 支持："></a>5. <strong>Typescript 支持：</strong></h3><ul><li><strong>Options API：</strong><ul><li>Options API 中的 TypeScript 支持通常需要在组件的选项对象上进行类型声明，有时可能不够直观。</li></ul></li><li><strong>Composition API：</strong><ul><li>Composition API 在 TypeScript 下更直观，通过函数参数的类型推断可以更好地支持类型检查。</li></ul></li></ul><h2 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h2><p>Vue 3.0 中引入了 Tree-shaking 特性，这是一项优化技术，用于在构建时剔除未使用的代码，从而减小最终打包文件的体积。Tree-shaking 主要依赖于静态分析，通过分析模块的依赖关系，识别和去除未使用的部分。</p><p>在 Vue 3.0 中，Tree-shaking 特性主要表现在以下方面：</p><ol><li><strong>模块的标记：</strong><ul><li>Vue 3.0 的模块系统使用了 ESM（ECMAScript 模块）规范，这使得 JavaScript 引擎能够更好地理解和优化模块的导入和导出。这种标准的模块系统有助于静态分析，提高了 Tree-shaking 的效果。</li></ul></li><li><strong>编译时标记：</strong><ul><li>Vue 3.0 的编译器在编译阶段会标记出哪些代码是可以被 Tree-shaking 的。这种标记是基于编译时的静态分析，可以准确地识别不会被使用的部分。</li></ul></li></ol><h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><p>考虑以下简单的 Vue 3.0 组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String,</span><br><span class="line">    content: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    someUnusedMethod() &#123;</span><br><span class="line">      // 未被使用的方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在这个组件中，有一个未被使用的方法 <code>someUnusedMethod</code>。由于 Vue 3.0 的 Tree-shaking 特性，如果这个方法没有在组件内被使用，那么在构建时它将被剔除，不会出现在最终打包的代码中。</p><p>这样，即使你在组件内定义了一些方法或变量，只要它们在实际渲染的过程中没有被使用，它们就不会被包含在最终的打包文件中。这对于减小应用的体积非常有帮助，特别是在大型应用中，很多时候我们可能引入了一些库或组件，但只使用了其中的一部分功能。通过 Tree-shaking，未使用的部分将被自动去除，减小了不必要的资源加载。</p><h2 id="用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？"><a href="#用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？" class="headerlink" title="用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？"></a>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="你了解axios原理吗？有看过源码吗？"><a href="#你了解axios原理吗？有看过源码吗？" class="headerlink" title="你了解axios原理吗？有看过源码吗？"></a>你了解axios原理吗？有看过源码吗？</h2><h2 id="SSR解决了什么问题？有做过吗？如何做的"><a href="#SSR解决了什么问题？有做过吗？如何做的" class="headerlink" title="SSR解决了什么问题？有做过吗？如何做的"></a>SSR解决了什么问题？有做过吗？如何做的</h2><h2 id="说说vue项目目录结构，若是大型项目如何划分组件及结构"><a href="#说说vue项目目录结构，若是大型项目如何划分组件及结构" class="headerlink" title="说说vue项目目录结构，若是大型项目如何划分组件及结构"></a>说说vue项目目录结构，若是大型项目如何划分组件及结构</h2><h2 id="权限管理如何做？控制到按钮级别的权限如何做？"><a href="#权限管理如何做？控制到按钮级别的权限如何做？" class="headerlink" title="权限管理如何做？控制到按钮级别的权限如何做？"></a>权限管理如何做？控制到按钮级别的权限如何做？</h2><p>封装自定义权限指令实现按钮级别的权限控制</p><p>在<code>main.js</code>全局注册自定义指令，（第一个参数是自定义指令名，第二个参数是<code>inserted</code>回调函数,绑定了该指令的元素被插入到<code>dom</code>上时就会自动执行）通过第二个参数获取其对应的权限点的<code>value</code>属性，然后在<code>vuex</code>中的用户信息里进行筛选看用户是否具有该权限，使用<code>v-if</code>来决定是否显示对应的元素</p><h2 id="浏览器底层原理"><a href="#浏览器底层原理" class="headerlink" title="浏览器底层原理"></a>浏览器底层原理</h2><h2 id="浏览器是如何解析css选择器的"><a href="#浏览器是如何解析css选择器的" class="headerlink" title="浏览器是如何解析css选择器的"></a>浏览器是如何解析css选择器的</h2><h2 id="浏览器是如何进行界面渲染的"><a href="#浏览器是如何进行界面渲染的" class="headerlink" title="浏览器是如何进行界面渲染的"></a>浏览器是如何进行界面渲染的</h2><p>浏览器进行界面渲染的过程可以分为以下几个关键步骤：</p><ol><li><strong>构建 DOM 树：</strong><ul><li>当浏览器接收到 HTML 文件时，它会解析 HTML，并构建 DOM（文档对象模型）树。DOM 树是一个由节点（元素、文本等）构成的层次结构，表示了页面的结构。</li></ul></li><li><strong>构建 CSSOM 树：</strong><ul><li>浏览器解析样式表（CSS 文件或内嵌样式），并构建 CSSOM（CSS 对象模型）树。CSSOM 树表示了页面中各个元素的样式信息，包括它们的样式属性和如何相互影响。</li></ul></li><li><strong>构建 Render 树：</strong><ul><li>DOM 树和 CSSOM 树结合起来构建 Render 树。Render 树是由浏览器用于渲染的树结构，它只包含需要显示的节点和这些节点的样式信息。一些不可见的元素（例如<code>display: none</code>的元素）不会包含在 Render 树中。</li></ul></li><li><strong>布局（Layout）：</strong><ul><li>在构建 Render 树后，浏览器进行布局过程，确定每个节点在屏幕上的确切位置和大小。这个过程也称为回流（reflow）。浏览器需要考虑各种因素，如盒模型、文档流、浮动等，来计算元素的准确位置。</li></ul></li><li><strong>绘制（Painting）：</strong><ul><li>在布局完成后，浏览器进行绘制过程，将页面的内容绘制到屏幕上。这个过程也称为重绘（repaint）。绘制阶段使用绘图引擎将每个元素绘制成像素，考虑元素的颜色、边框、阴影等样式属性。</li></ul></li><li><strong>合成（Composite）：</strong><ul><li>浏览器将不同层的绘制结果合成在一起，形成最终的页面。现代浏览器通常使用图层来提高页面的性能。图层是一个独立的绘制表面，可以单独绘制和合成，这样在页面更新时只需要重新绘制和合成发生变化的图层，而不是整个页面。</li></ul></li><li><strong>渲染刷新：</strong><ul><li>当页面内容发生变化、用户触发交互或浏览器窗口大小改变时，浏览器会重新执行上述渲染流程，以确保页面保持最新。</li></ul></li></ol><p>这个整个渲染过程是一个逐步的、增量的过程。浏览器采用这种方式，以提高页面渲染的性能和用户体验。</p><h2 id="前端如何实现实时通讯"><a href="#前端如何实现实时通讯" class="headerlink" title="前端如何实现实时通讯?"></a>前端如何实现实时通讯?</h2><p>WebSocket（通常缩写为 WS）是一种在单个 TCP 连接上进行全双工通信的协议。与传统的 HTTP 请求-响应模型不同，WebSocket 允许在同一连接上同时进行双向数据传输，实现实时通信。WebSocket 协议最初由 IETF 标准化，目前的标准版本是 RFC 6455。</p><p>以下是 WebSocket 的一些重要特性和工作原理：</p><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ol><li><strong>全双工通信：</strong> WebSocket 允许客户端和服务器之间建立持久的连接，实现双向实时通信，而不是像 HTTP 请求-响应那样需要不断地发起新的请求。</li><li><strong>低延迟：</strong> 由于使用了单个 TCP 连接，WebSocket 可以减少因为建立和关闭连接而引入的延迟。</li><li><strong>轻量级：</strong> WebSocket 的协议头较小，通信过程较简单，相对于传统的 HTTP 协议，WebSocket 的开销较小。</li><li><strong>跨域支持：</strong> WebSocket 支持跨域通信，允许在浏览器中进行跨域实时通信。</li></ol><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li><strong>握手阶段：</strong> WebSocket 连接的建立始于一个 HTTP 请求，通常称为握手阶段。客户端发起一个 HTTP 请求，请求头中包含协议升级的信息，服务器接受后会响应一个包含握手成功信息的 HTTP 响应。之后，连接协议升级为 WebSocket。</li><li><strong>数据帧传输：</strong> 握手成功后，客户端和服务器之间的通信就进入了数据帧传输阶段。WebSocket 通信使用帧（frame）的概念，每个帧可以携带文本、二进制数据等信息。帧的传输是双向的，客户端和服务器可以同时发送和接收帧。</li><li><strong>帧格式：</strong> WebSocket 帧的格式相对简单，通常包含一个头部和一个数据部分。头部包含帧的类型、长度等信息，数据部分则是实际的传输数据。</li><li><strong>关闭连接：</strong> 当需要关闭连接时，客户端或服务器可以发送一个关闭帧，通知对方关闭连接。收到关闭帧的一方也会发送一个关闭帧，双方最终关闭连接。</li></ol><h3 id="JavaScript-中的使用："><a href="#JavaScript-中的使用：" class="headerlink" title="JavaScript 中的使用："></a>JavaScript 中的使用：</h3><p>在浏览器中，可以使用 JavaScript 的 <code>WebSocket</code> API 来创建 WebSocket 连接。以下是一个简单的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建 WebSocket 连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://example.com/socket&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开事件</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection opened:&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收到消息事件</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection closed:&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello, WebSocket!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>onopen</code>、<code>onmessage</code>、<code>onclose</code> 等是 <code>WebSocket</code> 对象的事件处理函数，用于处理连接打开、接收消息、连接关闭等事件。<code>send</code> 方法用于向服务器发送消息。</p><h2 id="什么是浏览器同源策略"><a href="#什么是浏览器同源策略" class="headerlink" title="什么是浏览器同源策略?"></a>什么是浏览器同源策略?</h2><p>同源策略（Same-Origin Policy）是浏览器的一种安全策略，用于限制一个网页文档或脚本如何能够与其他源的资源进行交互。同源策略的核心思想是：不同源的客户端脚本在没有明确授权的情况下，不能读取对方的资源。</p><p>同源是指协议（如 http 和 https）、域名和端口号都相同。如果有任何一个不同，就被视为不同源。</p><p>同源策略的主要目的是防止恶意网站通过脚本等方式窃取数据，保护用户的隐私和安全。</p><h2 id="如何实现跨域获取数据"><a href="#如何实现跨域获取数据" class="headerlink" title="如何实现跨域获取数据"></a>如何实现跨域获取数据</h2><p>后端配置cors</p><p>前端使用代理转发</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="说说JavaScript中的数据类型？存储上的差别？"><a href="#说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="说说JavaScript中的数据类型？存储上的差别？"></a>说说JavaScript中的数据类型？存储上的差别？</h2><p><code>js</code>的数据类型主要分为&#x3D;&#x3D;基本数据类型&#x3D;&#x3D;和&#x3D;&#x3D;引用数据类型&#x3D;&#x3D;</p><h5 id="基本数据类型-7种"><a href="#基本数据类型-7种" class="headerlink" title="基本数据类型:7种"></a>基本数据类型:7种</h5><p>1.<code>string</code></p><p>字符串可以使用双引号<code>&quot; &quot;</code>、单引号<code>&#39; &#39;</code>或反引号  &#96;  标示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure><p>2.<code>number</code></p><p>3.<code>null</code></p><p><code>null</code>表示有值但是值为空,可以理解为就是一个毛坯房里面什么东西都没有,通常用来占据位置,未来要往里面赋值</p><p>4.<code>undefind</code></p><p>使用<code>let</code>或是<code>var</code>声明了变量但是没有初始化,那么这个变量的值就是<code>undefined</code></p><p>5.<code>boolean</code></p><p>只有两个<code>true</code>和<code>false</code></p><p>6.<code>bigInt</code>(es11新增)</p><p>表示任意大的整数类型</p><p>普通的整数类型（<code>number</code>）只能安全地存储和运算 -2^53^ -1 到 2^53^-1 这个范围之间的整数，而<code>bigint</code>则没有这个限制。</p><p>7.<code>symbol</code>(es6新增)</p><p><code>symbol</code>是一种唯一的、不可变的数据类型，经常用于作为对象属性的键。它的主要特点是每次创建都会生成一个唯一的值，即使使用相同的字符串也无法创建出相同的<code>symbol</code>。</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>1.<code>function</code></p><p>是一种特殊类型的对象，可以执行代码块。</p><p>2.<code>array</code></p><p>是一种特殊类型的对象，用于按顺序存储多个值。</p><p>3.<code>object</code></p><p>用于存储复杂的数据结构，可以包含属性和方法。</p><h4 id="js数据类型的检测"><a href="#js数据类型的检测" class="headerlink" title="js数据类型的检测"></a>js数据类型的检测</h4><p>1.typeof</p><ul><li><code>typeof</code> 操作符用于确定变量或表达式的数据类型，返回一个表示数据类型的字符串。例如：<code>typeof variableName</code>。返回的结果可以是以下字符串之一：<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;undefined&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>、<code>&quot;symbol&quot;</code> 或 <code>&quot;bigint&quot;</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;Hello&quot;</span> <span class="comment">// 返回 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> <span class="comment">// 返回 &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 返回 &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 返回 &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 返回 &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 返回 &quot;function&quot;</span></span><br></pre></td></tr></table></figure><p>2.instanceof</p><ul><li><code>instanceof</code> 操作符用于检查一个对象是否是某个构造函数的实例。它通常用于检测自定义的对象类型。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><p>3.constructor 属性</p><ul><li>可以使用对象的 <code>constructor</code> 属性来检测其构造函数。这通常用于检测自定义对象类型。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj 是一个对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>Object.prototype.toString.call() 方法</strong>：</p><ul><li>这是一种通用的方法，可以用于检测任何数据类型，包括原始数据类型和引用数据类型。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// 返回 &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>) <span class="comment">// 返回 &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// 返回 &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">// 返回 &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><p>5.Array.isArray() 方法：</p><ul><li>用于检测一个值是否是数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><p>6.isNaN() 函数：</p><p>用于检测一个值是否为 NaN（非数字值）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><h2 id="数组的常用方法有哪些？"><a href="#数组的常用方法有哪些？" class="headerlink" title="数组的常用方法有哪些？"></a>数组的常用方法有哪些？</h2><p>操作方法</p><p>增</p><p><code>push()</code>方法接收任意数量的参数，并将它们添加到<strong>数组末尾</strong>，返回数组的最新长度</p><p><code>unshift()</code>在数组开头<strong>添加任意多个值</strong>，然后返回新的数组长度</p><p><code>splice()</code> 传入三个参数，分别是开始位置、要删除的元素数量、增加的元素，返回一个空数组</p><p>删</p><p><font color="red"><strong>修改原数组</strong></font></p><p><code>pop()</code> 方法用于删除数组的<strong>最后一项</strong>，同时减少数组的<code>length</code> 值，返回被删除的项</p><p><code>shift()</code>方法用于删除数组的<strong>第一项</strong>，同时减少数组的<code>length</code> 值，返回被删除的项</p><p><code>splice()</code>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p><p>改</p><p>查</p><p><code>indexof()</code>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p><p><code>includes()</code>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p><p> <code>find()</code>返回第一个匹配的元素</p><p>排序方法</p><p>数组翻转<code>reverse()</code></p><p>数组排序<code>sort()</code>方法接受一个比较函数，用于判断哪个值应该排在前面</p><p>转换方法</p><p><code>join()</code> 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p><p>迭代方法</p><p><code>some()</code>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p><p><code>every()</code>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p><p><code>forEach()</code>对数组每一项都运行传入的函数，没有返回值</p><p><code>filter()</code>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p><p><code>map()</code>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p><h2 id="JavaScript字符串的常用方法有哪些？"><a href="#JavaScript字符串的常用方法有哪些？" class="headerlink" title="JavaScript字符串的常用方法有哪些？"></a>JavaScript字符串的常用方法有哪些？</h2><p><code>trim()</code>删除前、后或前后所有空格符，再返回新的字符串</p><p><code>aplit()</code>把字符串按照指定的分割符，拆分成数组中的每一项</p><h2 id="和-区别，分别在什么情况使用"><a href="#和-区别，分别在什么情况使用" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用</h2><h3 id="（相等操作符）："><a href="#（相等操作符）：" class="headerlink" title="==（相等操作符）："></a><code>==</code>（相等操作符）：</h3><ul><li><p><strong>比较过程：</strong> <code>==</code> 进行比较时，会进行类型转换，尝试将比较的两个值转换为相同的类型，然后再进行比较。</p></li><li><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;5&#x27;</span> == <span class="number">5</span>; <span class="comment">// true，因为字符串 &#x27;5&#x27; 会被转换为数字 5</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true，因为布尔值 false 会被转换为数字 0</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true，它们被视为相等</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="（严格相等操作符）："><a href="#（严格相等操作符）：" class="headerlink" title="===（严格相等操作符）："></a><code>===</code>（严格相等操作符）：</h3><ul><li><p><strong>比较过程：</strong> <code>===</code> 进行比较时，不会进行类型转换。只有在两个值的类型和值都相等的情况下，<code>===</code> 才会返回 <code>true</code>。</p></li><li><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;5&#x27;</span> === <span class="number">5</span>; <span class="comment">// false，因为它们的类型不同</span></span><br><span class="line"><span class="number">0</span> === <span class="literal">false</span>; <span class="comment">// false，因为它们的类型不同</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="comment">// false，它们的类型相同，但值不同</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="如何选择使用："><a href="#如何选择使用：" class="headerlink" title="如何选择使用："></a>如何选择使用：</h3><ul><li>推荐使用 <code>===</code>，因为它避免了类型转换带来的一些意外行为，更加严格和可靠。</li><li>在特定情况下，如果你明确需要进行类型转换，或者想要利用 JavaScript 的隐式类型转换规则，可以使用 <code>==</code>。但需要小心因为类型转换可能导致不直观的结果。</li><li>一般来说，为了代码的清晰和可读性，最好养成使用 <code>===</code> 的习惯，以避免因为隐式类型转换而引起的错误。</li></ul><h2 id="深拷贝浅拷贝的区别？如何实现一个深拷贝？"><a href="#深拷贝浅拷贝的区别？如何实现一个深拷贝？" class="headerlink" title="深拷贝浅拷贝的区别？如何实现一个深拷贝？"></a>深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2><h2 id="说说你对闭包的理解？闭包使用场景"><a href="#说说你对闭包的理解？闭包使用场景" class="headerlink" title="说说你对闭包的理解？闭包使用场景"></a>说说你对闭包的理解？闭包使用场景</h2><p>闭包简单来说就是一个嵌套的函数内层函数能够访问外层函数的局部变量,这个时候就发生了闭包</p><p>优点:</p><ul><li>变量私有化,延长变量的生命周期</li></ul><p>缺点</p><ul><li>变量没有被及时的释放会造成内存泄漏,需要手动进行释放</li></ul><p>使用场景</p><h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h2><p>说作用域之前先说一说这个作用域,作用域一般分为三种分别是</p><p>块级作用域</p><p>在ES6中引入的<code>let</code>和<code>const</code>变量的声明方式具有块级作用域,即在<code>&#123; &#125;</code>包裹的范围之内都可以被访问到,<code>&#123; &#125;</code>之外不可以</p><p>函数作用域</p><p>函数作用域只有在函数内部可以被访问到,外部无法访问</p><p>全局作用域</p><p>全局作用域下声明的变量是在任何位置都是可以被访问到的</p><p>作用域链: </p><p>当JavaScript在执行代码访问变量的时候会优先在自身当前作用域查找看有没有,如果没有就会到父级作用域依次逐级向上查找,直到全局作用域,这时如果还是没有找到在非严格模式下会隐式的声明该变量,或者是直接报错</p><h2 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h2><p>原型:</p><p>每一个构造函数和通过构造函数创建出来的实例对象都有一个共同的原型对象</p><p>构造函数是通过<code>prototype</code>属性来访问,实例对象通过<code>__proto__</code>属性来访问原型对象</p><p>原型链:</p><p>简单来说它可以实现对象之间属性和方法的继承和共享</p><p>当一个对象访问其身上的属性和方法的时候,它会优先在自身查找如果没有就会到原型对象身上去查找,如果还没有就会逐级向上到<code>object</code>的原型对象身上查找,直到找到或是到达原型链的末端<code>Object.prototype</code>,这时如果还没有找到就会返回<code>null</code>,这样一个链式查找的过程就叫作原型链</p><h2 id="Javascript如何实现继承？"><a href="#Javascript如何实现继承？" class="headerlink" title="Javascript如何实现继承？"></a>Javascript如何实现继承？</h2><p>在父类的原型上添加共有的属性或者是方法,使用<code>father.prototype = Object.create(son.prototype)</code>创建了一个新的对象建立起关联</p><p>比如说我们创建一个人类person的构造函数,给它添加了一个sayHello的方法</p><p>然后我们又创建了一个学生Student的构造函数,给它添加了一个study方法</p><p>使用student.prototype &#x3D; object.create(person.prototype)建立起关联,使其原型链指向person.prototype</p><p>这样当我们既可以使用使用学生自身的study方法,也可以使用它原型对象身上的sayHello方法,因为学生自己身上是没有sayHello方法的,就会去原型对象身上去查找,这样就实现了原型的继承</p><h2 id="cookie-、localstorage-、-sessionstrorage-之间有什么区别？"><a href="#cookie-、localstorage-、-sessionstrorage-之间有什么区别？" class="headerlink" title="cookie 、localstorage 、 sessionstrorage 之间有什么区别？"></a>cookie 、localstorage 、 sessionstrorage 之间有什么区别？</h2><p>大小</p><p>cookie,大小大概为4kb左右</p><p>而localstorage和sessionstroage的存储空间比cookie要大,大概5m左右</p><p>到期时间</p><p>cookie可以设置到期时间,在到期时间没过之前一直有效</p><p>localstroage将数据永久存储到本地,页面和浏览器关闭后不会丢失</p><p>sessionstroage 当浏览器或是页面关闭后存储的数据就会丢失</p><h2 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a>谈谈this对象的理解</h2><p>this的指向在不同的函数里面this的指向是不一样的</p><p>全局:this指向全局对象也就是window</p><p>普通函数:普通函数被当做方法调用的时候指向事件源</p><p>箭头函数: 箭头函数的this指向是固定的它会继续沿用上一层作用域中的this指向</p><p>构造函数: 构造函数的this指向新创建的实例对象</p><p>this指向也是也可以通过 call bind 和apply方法来进行修改的</p><h2 id="JavaScript中执行上下文和执行栈是什么？"><a href="#JavaScript中执行上下文和执行栈是什么？" class="headerlink" title="JavaScript中执行上下文和执行栈是什么？"></a>JavaScript中执行上下文和执行栈是什么？</h2><h2 id="说说JavaScript中的事件模型"><a href="#说说JavaScript中的事件模型" class="headerlink" title="说说JavaScript中的事件模型"></a>说说JavaScript中的事件模型</h2><h2 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h2><p>typeof 检测基本数据类型</p><p>instanceof 检测引用数据类型</p><p>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p><h2 id="解释下什么是事件代理？应用场景？"><a href="#解释下什么是事件代理？应用场景？" class="headerlink" title="解释下什么是事件代理？应用场景？"></a>解释下什么是事件代理？应用场景？</h2><h2 id="说说new操作符具体干了什么？"><a href="#说说new操作符具体干了什么？" class="headerlink" title="说说new操作符具体干了什么？"></a>说说new操作符具体干了什么？</h2><ol><li>创建一个空的 <code>JavaScript</code> 对象。<ul><li>一个新的空对象被创建，这个对象被称为构造函数的实例对象。</li></ul></li><li>将新对象的 <code>__proto__</code> 属性指向构造函数的原型对象。<ul><li>每个 JavaScript 函数都有一个特殊的属性称为 <code>prototype</code>，这个属性是一个指向对象的引用。<code>new</code>操作符会将新对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code> 属性，这样新对象就可以访问构造函数原型对象上的属性和方法。</li></ul></li><li>执行构造函数，将新对象绑定到 <code>this</code>。<ul><li>构造函数内部的代码被执行，<code>this</code> 关键字指向新创建的对象。这允许构造函数将属性和方法添加到新对象上。</li></ul></li><li>如果构造函数没有显式返回一个对象，那么 <code>new</code> 操作符会返回新创建的对象。<ul><li>如果构造函数没有使用 <code>return</code> 关键字返回一个对象，则<code>new</code>操作符会返回新创建的对象。如果构造函数返回一个对象（不管是显式返回的还是通过构造函数中的代码生成的），则<code>new</code>操作符会返回该对象，而不是新创建的对象。</li></ul></li></ol><h2 id="ajax原理是什么？如何实现？"><a href="#ajax原理是什么？如何实现？" class="headerlink" title="ajax原理是什么？如何实现？"></a>ajax原理是什么？如何实现？</h2><h2 id="bind、call、apply-区别？如何实现一个bind"><a href="#bind、call、apply-区别？如何实现一个bind" class="headerlink" title="bind、call、apply 区别？如何实现一个bind?"></a>bind、call、apply 区别？如何实现一个bind?</h2><p>call bind apply都是用来改变this的指向</p><p>主要有三个方面的修改this指向的时长不一样</p><p>call 和 apply 只会改变一次this的指向,并且立即执行</p><p>bind,不会立即执行,是返回一个改变this指向之后的一个新的函数</p><p>传参方式不一样</p><p>call apply是数组列表传参</p><p>bind 是 伪数组传参可以分为多传入</p><h2 id="说说你对正则表达式的理解？应用场景？"><a href="#说说你对正则表达式的理解？应用场景？" class="headerlink" title="说说你对正则表达式的理解？应用场景？"></a>说说你对正则表达式的理解？应用场景？</h2><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><p>js是一门单线程语言,这就意味这在同一时间只能执行一件任务,遇到异步任务就会造成代码的阻塞</p><p>所以js里面所有的任务被分为同步任务和异步任务</p><p>代码从上到下执行,会先进入到调用栈执行,遇到异步任务就会交给宿主环境(node.js,浏览器)去执行,执行完成之后放到任务队列中进行排队,接着执行同步任务</p><p>等待所有的异步任务执行完毕之后,就会到任务队列中去读取执行,输出结果</p><p>异步任务里面又有微任务和宏任务,微任务的优先级比微任务要高,会在任务队列之前插队执行</p><p>如此不断循环往复的流程就是事件循环</p><h2 id="DOM常见的操作有哪些？"><a href="#DOM常见的操作有哪些？" class="headerlink" title="DOM常见的操作有哪些？"></a>DOM常见的操作有哪些？</h2><h2 id="说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>说说你对BOM的理解，常见的BOM对象你了解哪些？</h2><h2 id="举例说明你对尾递归的理解，有哪些应用场景"><a href="#举例说明你对尾递归的理解，有哪些应用场景" class="headerlink" title="举例说明你对尾递归的理解，有哪些应用场景"></a>举例说明你对尾递归的理解，有哪些应用场景</h2><h2 id="说说-JavaScript-中内存泄漏的几种情况？"><a href="#说说-JavaScript-中内存泄漏的几种情况？" class="headerlink" title="说说 JavaScript 中内存泄漏的几种情况？"></a>说说 JavaScript 中内存泄漏的几种情况？</h2><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><h2 id="说说你对函数式编程的理解？优缺点？"><a href="#说说你对函数式编程的理解？优缺点？" class="headerlink" title="说说你对函数式编程的理解？优缺点？"></a>说说你对函数式编程的理解？优缺点？</h2><h2 id="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"><a href="#Javascript中如何实现函数缓存？函数缓存有哪些应用场景？" class="headerlink" title="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"></a>Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</h2><h2 id="说说-Javascript-数字精度丢失的问题，如何解决？"><a href="#说说-Javascript-数字精度丢失的问题，如何解决？" class="headerlink" title="说说 Javascript 数字精度丢失的问题，如何解决？"></a>说说 Javascript 数字精度丢失的问题，如何解决？</h2><p><code>tofixed()</code></p><h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h2><p>一种性能优化手段</p><p>防抖:在单位时间内一个事件被多次触发只会执行最后一次</p><p>节流:早单位时间内一个事件被多次触发只会执行一次,第二次触发就会重新开始计时,当限制时间过了之后才会执行第二次</p><p>实现原理:</p><p>防抖</p><p>利用settimeout函数开启一个来实现当事件被点击了之后就清除掉原来的定时器重新开启一个新的定时器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>应用场景: 手机号,邮箱的验证,窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染</p><p>节流</p><p>在执行settimeout函数之前给他设置一个默认的开关或者是阀门为true,当事件被点击了之后立马把这个变量设置为false,只有在等延时时间过了之后就再次把开关设置为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>应用场景: html页面滚动的电梯导航,搜索框，搜索联想功能</p><h2 id="如何判断一个元素是否在可视区域中？"><a href="#如何判断一个元素是否在可视区域中？" class="headerlink" title="如何判断一个元素是否在可视区域中？"></a>如何判断一个元素是否在可视区域中？</h2><h2 id="大文件上传如何做断点续传？"><a href="#大文件上传如何做断点续传？" class="headerlink" title="大文件上传如何做断点续传？"></a>大文件上传如何做断点续传？</h2><h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p><p>文件上传简单，文件变大就复杂</p><p>上传大文件时，以下几个变量会影响我们的用户体验</p><ul><li>服务器处理数据的能力</li><li>请求超时</li><li>网络波动</li></ul><p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p><p>为了解决上述问题，我们需要对大文件上传单独处理</p><p>这里涉及到分片上传及断点续传两个概念</p><h3 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h3><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p><p>如下图</p><p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p><p>大致流程如下：</p><ol><li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li><li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li><li>按照一定的策略（串行或并行）发送各个分片数据块；</li><li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li></ol><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p><p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p><p>一般实现方式有两种：</p><ul><li>服务器端返回，告知从哪开始</li><li>浏览器端自行处理</li></ul><p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p><p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p><h2 id="如何实现上拉加载，下拉刷新？"><a href="#如何实现上拉加载，下拉刷新？" class="headerlink" title="如何实现上拉加载，下拉刷新？"></a>如何实现上拉加载，下拉刷新？</h2><h2 id="什么是单点登录？如何实现？"><a href="#什么是单点登录？如何实现？" class="headerlink" title="什么是单点登录？如何实现？"></a>什么是单点登录？如何实现？</h2><h2 id="web常见的攻击方式有哪些？如何防御？"><a href="#web常见的攻击方式有哪些？如何防御？" class="headerlink" title="web常见的攻击方式有哪些？如何防御？"></a>web常见的攻击方式有哪些？如何防御？</h2><h2 id="解释下什么是变量声明提升"><a href="#解释下什么是变量声明提升" class="headerlink" title="解释下什么是变量声明提升"></a>解释下什么是变量声明提升</h2><p>变量声明提升是JavaScript中的一种行为，它使得在代码执行前，变量和函数的声明被提升到当前作用域的顶部。这意味着可以在声明之前访问这些变量或函数。</p><p>在JavaScript中，有两种声明方式：<code>var</code>关键字和<code>function</code>关键字。对于<code>var</code>声明的变量和使用<code>function</code>声明的函数，它们的声明会被提升。</p><p>下面是一个简单的例子，演示了变量声明提升：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，虽然<code>console.log(x)</code>在<code>var x = 5</code>之前被调用，但由于变量声明提升，<code>x</code>在该语句执行时已经被声明，只是尚未被赋值，因此输出<code>undefined</code>。而在后续的赋值语句之后，<code>console.log(x)</code>输出了<code>5</code>。</p><p>注意，只有声明会被提升，赋值不会。如果一个变量在声明之前被访问，它的值会是<code>undefined</code>。</p><p>函数声明也会被提升，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_">foo</span>(); <span class="comment">// 输出: &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>foo()</code>在函数声明之前被调用，但由于函数声明提升，程序会正常输出”Hello, World!”。</p><p>需要注意的是，使用<code>let</code>和<code>const</code>关键字声明的变量也有提升，但与<code>var</code>不同，它们在提升阶段不会被初始化，访问时会报错。这被称为”暂时性死区”（Temporal Dead Zone，简称TDZ）。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 报错：Cannot access &#x27;x&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>总的来说，变量声明提升是<code>JavaScript</code>语言中的一种特性，了解它有助于避免在代码中出现一些意外的行为。在编写代码时，建议将变量和函数的声明放在当前作用域的顶部，以提高代码的可读性和可维护性。</p><h2 id="js的参数是以什么方式进行传递的"><a href="#js的参数是以什么方式进行传递的" class="headerlink" title="js的参数是以什么方式进行传递的"></a>js的参数是以什么方式进行传递的</h2><h2 id="js的垃圾回收机制是怎么做的"><a href="#js的垃圾回收机制是怎么做的" class="headerlink" title="js的垃圾回收机制是怎么做的"></a>js的垃圾回收机制是怎么做的</h2><h2 id="谈谈你平时都用了哪些方法进行性能优化？"><a href="#谈谈你平时都用了哪些方法进行性能优化？" class="headerlink" title="谈谈你平时都用了哪些方法进行性能优化？"></a>谈谈你平时都用了哪些方法进行性能优化？</h2><p>减少http请求次数、打包压缩上线代码、使用懒加载、使用雪碧图、动态渲染组件、CDN加载包。</p><h2 id="谈谈你对继承的理解"><a href="#谈谈你对继承的理解" class="headerlink" title="谈谈你对继承的理解"></a>谈谈你对继承的理解</h2><p>继承是面向对象编程（OOP）中的一个重要概念，它允许一个对象（子类&#x2F;派生类）获得另一个对象（父类&#x2F;基类）的属性和方法。继承是为了实现代码的重用和扩展，使得代码更加模块化、可维护和可扩展。</p><h3 id="继承的主要类型："><a href="#继承的主要类型：" class="headerlink" title="继承的主要类型："></a>继承的主要类型：</h3><ol><li><strong>单一继承：</strong><ul><li>一个子类只能继承自一个父类。这是一种简单的继承关系，存在较低的复杂性，但有时可能会限制灵活性。</li></ul></li><li><strong>多重继承：</strong><ul><li>一个子类可以同时继承自多个父类。这样可以更灵活地组合不同的功能，但也可能导致复杂性增加，引发一些设计上的问题。</li></ul></li><li><strong>多层继承：</strong><ul><li>类型之间形成一个层次结构，子类可以继承自父类，父类又可以继承自更上层的父类。这样的继承关系可以形成一个层次结构。</li></ul></li></ol><h3 id="继承的实现方式："><a href="#继承的实现方式：" class="headerlink" title="继承的实现方式："></a>继承的实现方式：</h3><ol><li>原型链继承：<ul><li>通过将子类的原型设置为父类的实例，从而让子类共享父类的属性和方法。但存在共享引用类型属性的问题，且无法传递参数给父类构造函数。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>构造函数继承（借用构造函数）：<ul><li>在子类的构造函数中调用父类的构造函数，通过 <code>call</code> 或 <code>apply</code> 方法来实现。解决了原型链继承的引用类型问题，但无法实现原型链上方法的复用。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 借用构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>组合继承：<ul><li>结合原型链继承和构造函数继承，既可以共享原型链上的方法，又可以解决构造函数继承的问题。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 借用构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(); <span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>原型式继承：<ul><li>利用一个简单的函数创建一个临时构造函数，然后将该构造函数的实例作为子类的原型。ES5 中可以使用 <code>Object.create</code> 方法实现。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Animal&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="title class_">Object</span>.<span class="title function_">create</span>(animal);</span><br><span class="line">dog.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>ES6 中的类继承：<ul><li>使用 <code>class</code> 关键字定义类，通过 <code>extends</code> 关键字实现继承。ES6 的类继承更接近传统的面向对象语言的实现方式，语法更简洁。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="继承的优缺点："><a href="#继承的优缺点：" class="headerlink" title="继承的优缺点："></a>继承的优缺点：</h3><p><strong>优点：</strong></p><ul><li><strong>代码复用：</strong> 继承允许子类重用父类的属性和方法，减少代码冗余。</li><li><strong>扩展性：</strong> 可以通过继承来扩展或修改现有类的行为。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>耦合性增加：</strong> 高度耦合的继承关系可能导致一个类的改变影响到其他相关的类。</li><li><strong>可读性下降：</strong> 复杂的继承关系可能使代码难以理解和维护。</li><li><strong>创建对象时的灵活性受限：</strong> 子类通常依赖于父类的实现，而不能灵活地改变或替换父类的实现。</li></ul><h2 id="如何判断是否为数组"><a href="#如何判断是否为数组" class="headerlink" title="如何判断是否为数组"></a>如何判断是否为数组</h2><ol><li><p><strong>Array.isArray() 方法：</strong></p><ul><li><code>Array.isArray()</code> 是最推荐的方法，它是ES5引入的，用于确定传递的值是否是一个数组。返回一个布尔值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(myArray)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>instanceof 操作符：</strong></p><ul><li><code>instanceof</code> 操作符用于检测构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意：<code>instanceof</code> 可能在涉及多个全局执行上下文的情况下失效，因此在跨框架或跨窗口的环境中不是很可靠。</p></li><li><p><strong>使用 Object.prototype.toString.call() 方法：</strong></p><ul><li><code>Object.prototype.toString.call()</code> 方法可以返回一个表示对象的字符串，其中包含了对象的类型信息。对于数组，返回的字符串应该是 <code>&quot;[object Array]&quot;</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(myArray) === <span class="string">&#x27;[object Array]&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><p>这三种方法中，推荐使用 <code>Array.isArray()</code>，因为它是专门用于检查是否为数组的方法，且更直观。在兼容性较好的环境中，这是最佳选择。如果需要更通用的方法，<code>Object.prototype.toString.call()</code> 也是一种可靠的选择。</p><h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h2><p>调用resolve 结果带到实例方法.then成功的回调里面</p><p>reject   结果带到实例方法.catch 失败的回调</p><p>race 优先输出第一个异步任务的结果</p><p>all 等待所有的异步任务执行完毕之后执行的回调</p><h2 id="微任务-宏任务是什么"><a href="#微任务-宏任务是什么" class="headerlink" title="微任务&#x2F;宏任务是什么?"></a>微任务&#x2F;宏任务是什么?</h2><h2 id="async-await是什么-相较于Promise有什么优势"><a href="#async-await是什么-相较于Promise有什么优势" class="headerlink" title="async&#x2F;await是什么?相较于Promise有什么优势"></a>async&#x2F;await是什么?相较于Promise有什么优势</h2><p>promise的语法糖</p><p>解决promise函数调用的回调地狱</p><p>async关键字是asynchronous(异步)的简写,用来声明一个函数是异步函数,写在函数的最前面,他会返回一个<code>promise</code>对象</p><p><code>await</code>可以理解为asynchronous wait(等待异步),他会等待一个异步任务返回的结果</p><p>下面这两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await</p><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise </code>对象，返回该对象的结果。如果不是 <code>Promise </code>对象，就直接返回对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1 fn2 3 2 </span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async </code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p><h2 id="请写出至少两种常见的数组排序的方法（原生js）"><a href="#请写出至少两种常见的数组排序的方法（原生js）" class="headerlink" title="请写出至少两种常见的数组排序的方法（原生js）"></a>请写出至少两种常见的数组排序的方法（原生js）</h2><h2 id="请写至少三种数组去重的方法？（原生js）"><a href="#请写至少三种数组去重的方法？（原生js）" class="headerlink" title="请写至少三种数组去重的方法？（原生js）"></a>请写至少三种数组去重的方法？（原生js）</h2><h2 id="知道lodash吗？它有哪些常见的API-？"><a href="#知道lodash吗？它有哪些常见的API-？" class="headerlink" title="知道lodash吗？它有哪些常见的API  ？"></a>知道lodash吗？它有哪些常见的API  ？</h2><p>clone()浅拷贝</p><p>clonedeep() 深拷贝</p><h2 id="平时都是用那些工具进行打包的？babel是什么？"><a href="#平时都是用那些工具进行打包的？babel是什么？" class="headerlink" title="平时都是用那些工具进行打包的？babel是什么？"></a>平时都是用那些工具进行打包的？babel是什么？</h2><p>webpack</p><p>对代码进行语法降级,解决兼容性</p><h2 id="谈谈Set-、-map-是什么？"><a href="#谈谈Set-、-map-是什么？" class="headerlink" title="谈谈Set 、 map 是什么？"></a>谈谈Set 、 map 是什么？</h2><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a><code>Set</code>（集合）</h3><ul><li><strong>定义：</strong> <code>Set</code> 是一种值的有序列表，其中的值必须是唯一的，不允许重复。</li><li><strong>特点：</strong><ul><li>不允许重复的值。</li><li><code>Set</code> 中的元素是有序的，插入顺序即为遍历顺序。</li><li>可以包含任意数据类型，包括基本类型和对象引用。</li></ul></li><li><strong>常用操作：</strong><ul><li><code>add(value)</code>: 向集合中添加一个新元素。</li><li><code>delete(value)</code>: 从集合中删除一个元素。</li><li><code>has(value)</code>: 判断集合中是否包含某个元素。</li><li><code>size</code>: 获取集合中元素的个数。</li><li><code>clear()</code>: 清空集合中的所有元素。</li></ul></li></ul><h3 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a>Map（映射）</h3><ul><li><strong>定义：</strong> <code>Map</code> 是一种键值对的集合，每个键对应一个值。</li><li><strong>特点：</strong><ul><li>键和值可以是任意数据类型。</li><li>与对象不同，<code>Map</code> 保留了键的插入顺序。</li><li><code>Map</code> 的键是唯一的，每个键只能对应一个值。</li></ul></li><li><strong>常用操作：</strong><ul><li>&#96;&#96;Set<code>(key, value)</code>: 设置键值对。</li><li><code>get(key)</code>: 获取键对应的值。</li><li><code>delete(key)</code>: 删除键值对。</li><li><code>has(key)</code>: 判断是否包含某个键。</li><li><code>size</code>: 获取 Map 中键值对的个数。</li><li><code>clear()</code>: 清空 Map 中的所有键值对。</li></ul></li></ul><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><code>Set</code> 的使用场景：<ul><li>去重：利用 <code>Set</code> 的唯一性可以轻松实现数组去重。</li><li>判断值是否存在。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uniqueArray = [...<span class="keyword">new</span> <span class="string">`Set`</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li>Map 的使用场景：<ul><li>存储和查找键值对数据。</li><li>保持键的顺序。</li><li>与对象相比，键可以是任意数据类型，不仅限于字符串。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">myMap.<span class="string">`Set`</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line">myMap.<span class="string">`Set`</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// &#x27;John&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="property">size</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="图片懒加载是怎么实现的？"><a href="#图片懒加载是怎么实现的？" class="headerlink" title="图片懒加载是怎么实现的？"></a>图片懒加载是怎么实现的？</h2><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用<code>HTML5</code> 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p><p>注意：<code>data-xxx</code> 中的xxx可以自定义，这里我们使用<code>data-src</code>来定义。</p><p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p><p>使用原生<code>JavaScript</code>实现懒加载：<br>知识点：<br>（1）<code>window.innerHeight</code> 是浏览器可视区的高度<br>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离<br>（3）<code>imgs.off</code>Set<code>Top</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）<br>（4）图片加载条件：<code>img.offSetTop &lt; window.innerHeight + document.body.scrollTop;</code><br>图示：</p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0" style="zoom:50%;" /><h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a>for in 和 for of 的区别</h2><p><code>for in</code>遍历对象的键也就是属性名,返回的是对应的索引下标</p><p><code>for of</code> 遍历的是可迭代对象的元素也就是值</p><h2 id="slice和aplice的区别"><a href="#slice和aplice的区别" class="headerlink" title="slice和aplice的区别"></a>slice和aplice的区别</h2><h3 id="slice-方法："><a href="#slice-方法：" class="headerlink" title="slice 方法："></a><code>slice</code> 方法：</h3><ol><li><p><strong>作用</strong>：</p><ul><li><code>slice</code> 方法用于创建一个新的数组，其中包含从原始数组中选择的元素。</li></ul></li><li><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">array.<span class="title function_">slice</span>(start, end)</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><ul><li><code>start</code>：开始提取元素的位置（包含该位置的元素）。</li><li><code>end</code>：提取元素的结束位置（不包含该位置的元素）。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>不修改原始数组，而是返回一个新的数组。</li><li>如果省略 <code>end</code> 参数，<code>slice</code> 方法会提取从 <code>start</code> 位置到数组末尾的所有元素。</li><li>参数可以是负数，表示从数组末尾开始计数的位置。</li></ul></li></ol><h3 id="splice-方法："><a href="#splice-方法：" class="headerlink" title="splice 方法："></a><code>splice</code> 方法：</h3><ol><li><p><strong>作用</strong>：</p><ul><li><code>splice</code> 方法用于在数组中添加或删除元素，可以修改原始数组。</li></ul></li><li><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">array.<span class="title function_">splice</span>(start, deleteCount, item1, item2, ...)</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><ul><li><code>start</code>：开始改变数组的位置。</li><li><code>deleteCount</code>：要移除的元素个数（可选，如果设置为 0，则不会删除元素）。</li><li><code>item1, item2, ...</code>：要添加到数组的新元素（可选）。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>修改原始数组，返回被删除的元素组成的数组。</li><li>如果 <code>deleteCount</code> 为 0，<code>splice</code> 可以用于插入新元素。</li><li>参数可以是负数，表示从数组末尾开始计数的位置。</li></ul></li></ol><h3 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h3><ul><li><code>slice</code> 不会改变原始数组，而是返回一个新的数组。</li><li><code>splice</code> 会改变原始数组，返回被删除的元素组成的数组。</li><li><code>slice</code> 用于提取数组的一部分，而不影响原数组。</li><li><code>splice</code> 用于添加、删除或替换数组的元素，并且会直接修改原数组。</li><li><code>slice</code> 的第二个参数是结束位置（不包含该位置的元素），而 <code>splice</code> 的第二个参数是要删除的元素个数。</li><li><code>splice</code> 还可以接受多个参数，用于在指定位置插入新的元素。</li></ul><h2 id="substr和substring的区别"><a href="#substr和substring的区别" class="headerlink" title="substr和substring的区别"></a>substr和substring的区别</h2><h3 id="substr-方法："><a href="#substr-方法：" class="headerlink" title="substr 方法："></a><code>substr</code> 方法：</h3><ol><li><p><strong>作用</strong>：</p><ul><li><code>substr</code> 方法用于返回字符串中从指定位置开始的指定长度的子字符串。</li></ul></li><li><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">substr</span>(start, length)</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><ul><li><code>start</code>：开始提取字符的位置，可以是正整数或负整数。如果是负数，表示从字符串末尾开始计算。</li><li><code>length</code>：可选，要提取的字符数。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>如果省略 <code>length</code> 参数，<code>substr</code> 会一直提取到字符串的末尾。</li><li>如果 <code>start</code> 是负数，它将被视为从字符串末尾开始的位置。</li><li>如果 <code>length</code> 是负数或零，它会被视为零。</li></ul></li></ol><h3 id="substring-方法："><a href="#substring-方法：" class="headerlink" title="substring 方法："></a><code>substring</code> 方法：</h3><ol><li><p><strong>作用</strong>：</p><ul><li><code>substring</code> 方法用于返回字符串中在两个指定下标之间的子字符串。</li></ul></li><li><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">string.<span class="title function_">substring</span>(start, end)</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><ul><li><code>start</code>：必须是非负整数，指定子字符串的开始位置。</li><li><code>end</code>：可选，必须是非负整数，指定子字符串的结束位置（不包含该位置的字符）。</li></ul></li><li><p><strong>特点</strong>：</p><ul><li>如果省略 <code>end</code> 参数，<code>substring</code> 会一直提取到字符串的末尾。</li><li><code>substring</code> 不接受负数参数，如果出现负数，会被视为零。</li><li>如果 <code>start</code> 大于 <code>end</code>，<code>substring</code> 会自动交换这两个参数。</li></ul></li></ol><h3 id="区别总结：-1"><a href="#区别总结：-1" class="headerlink" title="区别总结："></a>区别总结：</h3><ul><li><code>substr</code> 的第二个参数是要提取的字符数，而 <code>substring</code> 的第二个参数是子字符串的结束位置。</li><li><code>substr</code> 允许使用负数作为起始位置，而 <code>substring</code> 不接受负数参数。</li><li>如果省略第二个参数，<code>substr</code> 会一直提取到字符串的末尾，而 <code>substring</code> 也会一直提取到末尾，直到字符串的长度。</li><li>如果 <code>start</code> 大于 <code>end</code>，<code>substring</code> 会自动交换这两个参数；而对于 <code>substr</code>，如果 <code>start</code> 大于字符串的长度，返回空字符串。</li></ul><h2 id="能修改原数组的方法有哪些"><a href="#能修改原数组的方法有哪些" class="headerlink" title="能修改原数组的方法有哪些?"></a>能修改原数组的方法有哪些?</h2><ol><li><p><strong>push</strong>：</p><ul><li>在数组末尾添加一个或多个元素，并返回修改后数组的长度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// arr 现在为 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>pop</strong>：</p><ul><li>移除数组末尾的元素，并返回被移除的元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> removedElement = arr.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// arr 现在为 [1, 2, 3, 4]，removedElement 为 5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>shift</strong>：</p><ul><li>移除数组的第一个元素，并返回被移除的元素。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> removedElement = arr.<span class="title function_">shift</span>();</span><br><span class="line"><span class="comment">// arr 现在为 [2, 3, 4, 5]，removedElement 为 1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>unshift</strong>：</p><ul><li>在数组的开头添加一个或多个元素，并返回修改后数组的长度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// arr 现在为 [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>splice</strong>：</p><ul><li>通过删除或替换现有元素或者添加新元素来修改数组。该方法返回被删除的元素组成的数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> removedElements = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// arr 现在为 [1, 6, 7, 4, 5]，removedElements 为 [2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>reverse</strong>：</p><ul><li>颠倒数组中元素的顺序。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="comment">// arr 现在为 [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure></li><li><p><strong>sort</strong>：</p><ul><li>对数组元素进行排序，可以接受一个比较函数作为参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">// arr 现在为 [1, 2, 4, 5, 8]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="说一下你对事件委托的理解"><a href="#说一下你对事件委托的理解" class="headerlink" title="说一下你对事件委托的理解"></a>说一下你对事件委托的理解</h2><h2 id="说一说事件的执行过程"><a href="#说一说事件的执行过程" class="headerlink" title="说一说事件的执行过程"></a>说一说事件的执行过程</h2><h2 id="中断循环的方式-如何中断forEach"><a href="#中断循环的方式-如何中断forEach" class="headerlink" title="中断循环的方式,如何中断forEach"></a>中断循环的方式,如何中断forEach</h2><h2 id="如何判断后台返回的数据是一个空对象"><a href="#如何判断后台返回的数据是一个空对象" class="headerlink" title="如何判断后台返回的数据是一个空对象"></a>如何判断后台返回的数据是一个空对象</h2><h2 id="数组、对象解构如何实现"><a href="#数组、对象解构如何实现" class="headerlink" title="数组、对象解构如何实现"></a>数组、对象解构如何实现</h2><h2 id="如何二次封装axios"><a href="#如何二次封装axios" class="headerlink" title="如何二次封装axios"></a>如何二次封装axios</h2><h2 id="如何进行接口联调"><a href="#如何进行接口联调" class="headerlink" title="如何进行接口联调"></a>如何进行接口联调</h2><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a><strong>promise</strong></h2><h4 id="promise-是什么"><a href="#promise-是什么" class="headerlink" title="promise 是什么?"></a>promise 是什么?</h4><p>概念：**<code>Promise</code>** 对象表示异步操作最终的完成（或失败）以及其结果值</p><p>这是引用MDN上面的概念，十分的晦涩难懂,简单来说，所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，它可以获取异步操作的消息</p><p>它是ES6新增的语法,主要是为了解决异步函数的层层调用带来的回调地狱问题</p><h4 id="promise-的API"><a href="#promise-的API" class="headerlink" title="promise 的API"></a>promise 的API</h4><p>静态方法</p><p>&#x3D;&#x3D;resolve&#x3D;&#x3D;</p><p>在异步任务执行成功时会执行,并最终会把结果作为参数带到外面的<code>promise</code>对象实例的<code>.then</code>方法里</p><p>&#x3D;&#x3D;reject&#x3D;&#x3D;</p><p>在异步任务执行失败时会执行,并最终会把结果作为参数带到外面的<code>promise</code>对象实例的<code>.catch</code>方法里*</p><p>&#x3D;&#x3D;all&#x3D;&#x3D;</p><p>并行执行多个异步任务,并且会在所有的异步任务执行完毕之后执行回调,他会接收一个数组异步函数作为参数,它也是会进行异步执行的等上一个任务执行完毕之后才会执行第二个异步任务函数,最终会等数组里面所有的异步任务函数执行完毕后返回一个结果</p><p>&#x3D;&#x3D;race&#x3D;&#x3D;</p><p><code>.all</code>方法是以谁跑的慢以谁为执行标准,它会等待所有的异步任务执行完毕后,再执行实例对象的<code>.then</code>方法输出结果</p><p>而<code>.race</code>方法和<code>.all</code>方法相反,它会看哪一个任务执行完毕了之后,就直接执行了实例对象的<code>.then</code>方法输出结果</p><p>实例方法</p><p>&#x3D;&#x3D;then&#x3D;&#x3D;</p><p>&#x3D;&#x3D;catch&#x3D;&#x3D;</p><h2 id="如何改变-promise-的状态"><a href="#如何改变-promise-的状态" class="headerlink" title="如何改变 promise 的状态"></a>如何改变 promise 的状态</h2><p>前面说过<code>promise</code>是一个对象,他会接收一个回调函数作为参数,并且会立即执行</p><p>里面的回调函数有两个参数:（由 <code>JavaScript</code> 引擎提供，不用自己部署）</p><p>参数1: <code>resolve</code> 函数,将<code>Promise</code> 表示从发送请求时的<code>pending</code>状态变为<code>fullfiled</code>，会在异步操作成功时调用，并将结果作为参数传递出去</p><p>参数2: <code>reject</code> 函数, 将<code>Promise</code> 表示从发送请求时的<code>pending</code>状态变为<code>reject</code>，会在异步操作失败时调用，并将结果作为参数传递出去</p><h2 id="链式调用-promises-A-规范"><a href="#链式调用-promises-A-规范" class="headerlink" title="链式调用: promises&#x2F;A+规范"></a>链式调用: promises&#x2F;A+规范</h2><h1 id="手写系列"><a href="#手写系列" class="headerlink" title="手写系列"></a>手写系列</h1><h2 id="手写-promise"><a href="#手写-promise" class="headerlink" title="手写 promise"></a>手写 promise</h2><h2 id="手写闭包"><a href="#手写闭包" class="headerlink" title="手写闭包"></a>手写闭包</h2><h2 id="手写递归"><a href="#手写递归" class="headerlink" title="手写递归"></a>手写递归</h2><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="说说var、let、const之间的区别"><a href="#说说var、let、const之间的区别" class="headerlink" title="说说var、let、const之间的区别"></a>说说var、let、const之间的区别</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var声明的变量是全局变量,也就是顶级对象</p><p>var声明的变量会进行变量提升,在对代码进行编译的时候会把变量的声明提升到代码最前面,</p><p>可以对变量重新赋值,后面的变量会覆盖前面的</p><p>函数内声明的变量是局部变量,如果不使用var那么变量就是全局的</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let声明的变量有块级作用域</p><p>无法重复赋值会报错</p><p>变量声声明前都是不可用的,也就是暂时性死区</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>只读的一个常量,一旦声明不可以被改变</p><p>const声明的变量必须要进行初始化</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><p><strong>1.变量提升</strong></p><p>var会进行变量提升,可以在变量在声明之前被调用,值为undefind</p><p>let,const不会</p><p><strong>2.暂时性死区</strong></p><p>var没有暂时性死区</p><p>let和const存在暂时性死区,也就是只会在代码执行到变量声明的那一行才可以获取到值</p><p><strong>3.块级作用域</strong></p><p>var没有块级作用域</p><p>let和cost有块级作用域</p><p><strong>4.重复声明</strong></p><p>var可以重复声明</p><p>let和const在同一作用域下不能重复声明</p><p><strong>5.变量声明的修改</strong></p><p>let和var可以修改声明的变量</p><p>const声明的是一个常量,一旦声明不可以被修改,修改会报错</p><h2 id="ES6中数组新增了哪些扩展"><a href="#ES6中数组新增了哪些扩展" class="headerlink" title="ES6中数组新增了哪些扩展?"></a>ES6中数组新增了哪些扩展?</h2><h2 id="ES6中对象新增了哪些扩展"><a href="#ES6中对象新增了哪些扩展" class="headerlink" title="ES6中对象新增了哪些扩展?"></a>ES6中对象新增了哪些扩展?</h2><h2 id="ES6中函数新增了哪些扩展"><a href="#ES6中函数新增了哪些扩展" class="headerlink" title="ES6中函数新增了哪些扩展?"></a>ES6中函数新增了哪些扩展?</h2><h2 id="ES6中新增的Set、Map两种数据结构怎么理解"><a href="#ES6中新增的Set、Map两种数据结构怎么理解" class="headerlink" title="ES6中新增的Set、Map两种数据结构怎么理解?"></a>ES6中新增的<code>Set</code>、Map两种数据结构怎么理解?</h2><h2 id="你是怎么理解ES6中-Promise的？使用场景？"><a href="#你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Promise的？使用场景？"></a>你是怎么理解ES6中 Promise的？使用场景？</h2><h2 id="怎么理解ES6中-Generator的？使用场景？"><a href="#怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="怎么理解ES6中 Generator的？使用场景？"></a>怎么理解ES6中 Generator的？使用场景？</h2><h2 id="你是怎么理解ES6中Proxy的？使用场景"><a href="#你是怎么理解ES6中Proxy的？使用场景" class="headerlink" title="你是怎么理解ES6中Proxy的？使用场景?"></a>你是怎么理解ES6中Proxy的？使用场景?</h2><h2 id="你是怎么理解ES6中Module的？使用场景？"><a href="#你是怎么理解ES6中Module的？使用场景？" class="headerlink" title="你是怎么理解ES6中Module的？使用场景？"></a>你是怎么理解ES6中Module的？使用场景？</h2><h2 id="你是怎么理解ES6中-Decorator-的？使用场景？"><a href="#你是怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Decorator 的？使用场景？"></a>你是怎么理解ES6中 Decorator 的？使用场景？</h2><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a>ES6有哪些新特性？</h2><ol><li><p><strong>箭头函数</strong>：</p><ul><li>箭头函数提供了更简洁的函数定义语法，并且绑定了词法作用域的 this。</li></ul></li><li><p><strong>let 和 const</strong>：</p><ul><li><code>let</code> 和 <code>const</code> 替代了 <code>var</code>，<code>let</code> 声明的变量具有块级作用域，<code>const</code> 声明常量，其值不可修改。</li></ul></li><li><p><strong>模板字符串</strong>：</p><ul><li>使用反引号 (&#96;&#96;) 定义字符串模板，可以跨行书写，支持变量插值和表达式。</li></ul></li><li><p><strong>解构赋值</strong>：</p><ul><li>方便地从数组或对象中提取数据，赋值给变量。</li></ul></li><li><p><strong>默认参数</strong>：</p><ul><li>函数参数可以设置默认值，简化函数的调用。</li></ul></li><li><p><strong>展开运算符（Spread Operator）</strong>：</p><ul><li><p>可以在数组、对象等可迭代对象中展开元素，简化数组拼接和对象合并等操作。</p><p>…</p></li></ul></li></ol><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="说说你对盒子模型的理解"><a href="#说说你对盒子模型的理解" class="headerlink" title="说说你对盒子模型的理解?"></a>说说你对盒子模型的理解?</h2><h2 id="css选择器有哪些？优先级？哪些属性可以继承？"><a href="#css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="css选择器有哪些？优先级？哪些属性可以继承？"></a>css选择器有哪些？优先级？哪些属性可以继承？</h2><p>CSS选择器用于选择要样式化的HTML元素。以下是一些常见的CSS选择器：</p><ol><li><p><strong>元素选择器：</strong></p><ul><li>通过元素名称选择元素。例如，<code>p</code> 选择所有段落元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类选择器：</strong></p><ul><li>通过类名选择元素。以点（<code>.</code>）开头，例如，<code>.my-class</code> 选择所有具有 <code>my-class</code> 类的元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.my-class &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ID 选择器：</strong></p><ul><li>通过元素的ID选择元素。以井号（<code>#</code>）开头，例如 <code>#my-id</code> 选择具有 <code>my-id</code> ID 的元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#my-id &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>属性选择器：</strong></p><ul><li>通过元素的属性选择元素。例如，<code>[type=&quot;text&quot;]</code> 选择所有 <code>type</code> 属性为 <code>text</code> 的元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[type=&quot;text&quot;] &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>后代选择器：</strong></p><ul><li>选择元素的后代。例如，<code>ul li</code> 选择所有 <code>ul</code> 元素下的 <code>li</code> 元素。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>伪类选择器：</strong></p><ul><li>选择元素的特定状态。例如，<code>:hover</code> 选择鼠标悬停在元素上的状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:hover &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>伪元素选择器：</strong></p><ul><li>选择元素的特定部分。例如，<code>::before</code> 在元素前添加内容。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p::before &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>CSS规定了不同选择器的优先级。优先级决定了当多个规则应用到同一元素时，哪个规则的样式将被应用。优先级从高到低依次是：</p><ol><li><p><strong>!important：</strong></p><ul><li>通过在样式规则中使用 <code>!important</code> 标志，可以将其优先级提升到最高。尽量少使用，因为它会增加维护难度。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    color: red !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>内联样式：</strong></p><ul><li>使用 <code>style</code> 属性直接在元素上定义的样式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color: blue;&quot;&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>ID 选择器：</strong></p><ul><li>通过ID选择器定义的样式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#my-id &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类选择器、属性选择器、伪类选择器：</strong></p><ul><li>类、属性、伪类选择器的优先级相同，按照出现的顺序来决定。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.my-class &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[type=&quot;text&quot;] &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>元素选择器、伪元素选择器：</strong></p><ul><li>元素选择器和伪元素选择器的优先级相同，按照出现的顺序来决定。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p::before &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h2><p>一些CSS属性可以被子元素继承。这意味着如果父元素具有特定样式，子元素将继承这些样式，除非子元素有自己的样式规则。常见的可继承属性包括：</p><ol><li><strong>字体相关属性：</strong><ul><li><code>font-family</code>、<code>font-size</code>、<code>font-weight</code>等。</li></ul></li><li><strong>文本相关属性：</strong><ul><li><code>color</code>、<code>line-height</code>、<code>text-align</code>等。</li></ul></li><li><strong>列表相关属性：</strong><ul><li><code>list-style-type</code>、<code>list-style-image</code>等。</li></ul></li><li><strong>表格相关属性：</strong><ul><li><code>border-collapse</code>、<code>border-spacing</code>等。</li></ul></li><li><strong>链接相关属性：</strong><ul><li><code>text-decoration</code>、<code>color</code>（在<code>a</code>标签中）等。</li></ul></li><li><strong>生成内容属性：</strong><ul><li><code>content</code>（在伪元素中）。</li></ul></li></ol><h2 id="说说em-px-rem-vh-vw区别"><a href="#说说em-px-rem-vh-vw区别" class="headerlink" title="说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?"></a>说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?</h2><h3 id="em："><a href="#em：" class="headerlink" title="em："></a>em：</h3><ul><li><p><strong>相对单位：</strong> <code>em</code> 是相对于其父元素的字体大小的单位。</p></li><li><p><strong>继承性：</strong> <code>em</code> 具有继承性，如果一个元素的字体大小是 <code>1.5em</code>，那么它将是父元素字体大小的1.5倍。</p></li><li><p><strong>用途：</strong> 常用于设置字体大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>; <span class="comment">/* 1.2 * 16px = 19.2px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="px："><a href="#px：" class="headerlink" title="px："></a>px：</h3><ul><li><p><strong>绝对单位：</strong> <code>px</code> 是绝对单位，表示像素。</p></li><li><p><strong>固定大小：</strong> <code>px</code> 的大小在不同设备上是固定的。</p></li><li><p><strong>用途：</strong> 常用于设置固定大小的元素，如边框、内外边距等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h3><ul><li><p><strong>相对根元素：</strong> <code>rem</code> 是相对于根元素（<code>html</code>）的字体大小的单位。</p></li><li><p><strong>相对一致：</strong> <code>rem</code> 的大小相对于根元素，使得在整个页面中保持一致。</p></li><li><p><strong>用途：</strong> 用于实现响应式布局，特别是对于整个页面的缩放。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>; <span class="comment">/* 1 * 16px = 16px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vh（视窗高度单位）："><a href="#vh（视窗高度单位）：" class="headerlink" title="vh（视窗高度单位）："></a>vh（视窗高度单位）：</h3><ul><li><p><strong>相对视窗高度：</strong> <code>vh</code> 表示相对于视窗高度的百分比。</p></li><li><p><strong>相对一致：</strong> 1vh 等于视窗高度的1%。</p></li><li><p><strong>用途：</strong> 常用于制作具有视窗高度相关布局的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50vh</span>; <span class="comment">/* 视窗高度的50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="vw（视窗宽度单位）："><a href="#vw（视窗宽度单位）：" class="headerlink" title="vw（视窗宽度单位）："></a>vw（视窗宽度单位）：</h3><ul><li><p><strong>相对视窗宽度：</strong> <code>vw</code> 表示相对于视窗宽度的百分比。</p></li><li><p><strong>相对一致：</strong> 1vw 等于视窗宽度的1%。</p></li><li><p><strong>用途：</strong> 常用于制作具有视窗宽度相关布局的元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25vw</span>; <span class="comment">/* 视窗宽度的25% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="区别总结：-2"><a href="#区别总结：-2" class="headerlink" title="区别总结："></a>区别总结：</h3><ul><li><strong>em：</strong> 相对于父元素的字体大小。</li><li><strong>px：</strong> 绝对单位，固定大小。</li><li><strong>rem：</strong> 相对于根元素的字体大小，用于实现整体页面的缩放。</li><li><strong>vh：</strong> 相对于视窗高度的百分比，用于视窗高度相关布局。</li><li><strong>vw：</strong> 相对于视窗宽度的百分比，用于视窗宽度相关布局。</li></ul><h2 id="说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？"></a>说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？</h2><h2 id="谈谈你对BFC的理解？"><a href="#谈谈你对BFC的理解？" class="headerlink" title="谈谈你对BFC的理解？"></a>谈谈你对BFC的理解？</h2><p>BFC，即块级格式化上下文（Block Formatting Context），是CSS中一个重要的概念。BFC是页面上的一个独立的渲染区域，规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。</p><h3 id="BFC的特性："><a href="#BFC的特性：" class="headerlink" title="BFC的特性："></a>BFC的特性：</h3><ol><li><strong>块级盒子：</strong> BFC内部的所有元素都是块级盒子，这意味着它们按照块级盒子的标准布局。</li><li><strong>上下文独立：</strong> BFC内部的元素不会影响到外部元素，反之亦然。这意味着BFC内外的布局互不影响，使得页面布局更加灵活。</li><li><strong>阻止外边距重叠：</strong> 在同一个BFC中，相邻块级元素的外边距不会发生重叠。</li><li><strong>包含浮动：</strong> BFC会包含其内部的浮动元素，使得父元素可以自适应其内部浮动元素的高度。</li><li><strong>阻止文字环绕：</strong> BFC可以阻止文字环绕浮动元素，使得文字不会环绕在浮动元素的周围。</li></ol><h3 id="创建BFC的条件："><a href="#创建BFC的条件：" class="headerlink" title="创建BFC的条件："></a>创建BFC的条件：</h3><ol><li><strong>根元素：</strong> 页面的根元素（<code>&lt;html&gt;</code>）即为一个BFC。</li><li><strong>浮动元素：</strong> 元素的 <code>float</code> 属性不为 <code>none</code>。</li><li><strong>绝对定位元素：</strong> 元素的 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>。</li><li><strong>行内块元素：</strong> 元素的 <code>display</code> 属性为 <code>inline-block</code>。</li><li><strong>表格单元格元素：</strong> 元素的 <code>display</code> 属性为 <code>table-cell</code>。</li><li><strong>弹性盒子（Flex container）：</strong> 元素的 <code>display</code> 属性为 <code>flex</code> 或 <code>inline-flex</code>。</li><li><strong>网格布局容器（Grid container）：</strong> 元素的 <code>display</code> 属性为 <code>grid</code> 或 <code>inline-grid</code>。</li></ol><h3 id="BFC的应用场景："><a href="#BFC的应用场景：" class="headerlink" title="BFC的应用场景："></a>BFC的应用场景：</h3><ol><li><p><strong>清除浮动：</strong> 使用BFC可以清除浮动，避免父元素塌陷。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>防止外边距重叠：</strong> 在需要阻止外边距重叠的情况下，可以使用BFC。</p></li><li><p><strong>自适应两栏布局：</strong> 通过将父元素设为BFC，可以包含内部浮动元素，实现自适应两栏布局。</p></li><li><p><strong>阻止文字环绕：</strong> 在需要阻止文字环绕浮动元素的情况下，可以使用BFC。</p></li></ol><h2 id="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h2><h3 id="元素水平垂直居中的方法："><a href="#元素水平垂直居中的方法：" class="headerlink" title="元素水平垂直居中的方法："></a>元素水平垂直居中的方法：</h3><ol><li><p><strong>使用Flexbox：</strong></p><ul><li>对于容器，设置 <code>display: flex;</code> 和 <code>justify-content: center; align-items: center;</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Grid布局：</strong></p><ul><li>对于容器，设置 <code>display: grid;</code> 和 <code>place-items: center;</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用绝对定位和负边距：</strong></p><ul><li>对于需要居中的元素，设置 <code>position: absolute;</code>，然后通过负边距和 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code> 组合实现居中。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用表格布局：</strong></p><ul><li>对于容器，设置 <code>display: table;</code>，然后对子元素设置 <code>display: table-cell; vertical-align: middle; text-align: center;</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="元素不定宽高的水平垂直居中："><a href="#元素不定宽高的水平垂直居中：" class="headerlink" title="元素不定宽高的水平垂直居中："></a>元素不定宽高的水平垂直居中：</h3><ol><li><p><strong>使用Flexbox和margin: auto：</strong></p><ul><li>对于容器，设置 <code>display: flex;</code> 和 <code>justify-content: center; align-items: center;</code>，然后对子元素设置 <code>margin: auto;</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用绝对定位和transform：</strong></p><ul><li>对于需要居中的元素，设置 <code>position: absolute;</code> 和 <code>transform: translate(-50%, -50%);</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Flexbox和百分比定位：</strong></p><ul><li>对于容器，设置 <code>display: flex;</code> 和 <code>justify-content: center; align-items: center;</code>，然后对子元素设置 <code>position: relative;</code> 和 <code>top: 50%; left: 50%; transform: translate(-50%, -50%);</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"><a href="#如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？" class="headerlink" title="如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"></a>如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</h2><h3 id="两栏布局，右侧自适应："><a href="#两栏布局，右侧自适应：" class="headerlink" title="两栏布局，右侧自适应："></a>两栏布局，右侧自适应：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">char</span>`<span class="attr">Set</span>`=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 固定宽度左侧栏 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 右侧自适应 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Two Column Layout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Main Content (Right Sidebar)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三栏布局，中间自适应："><a href="#三栏布局，中间自适应：" class="headerlink" title="三栏布局，中间自适应："></a>三栏布局，中间自适应：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">char</span>`<span class="attr">Set</span>`=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 固定宽度左右栏 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 中间自适应 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Three Column Layout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>Main Content (Center)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Right Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="说说flexbox（弹性盒布局模型）-以及适用场景？"><a href="#说说flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="说说flexbox（弹性盒布局模型）,以及适用场景？"></a>说说flexbox（弹性盒布局模型）,以及适用场景？</h2><h2 id="介绍一下grid网格布局"><a href="#介绍一下grid网格布局" class="headerlink" title="介绍一下grid网格布局"></a>介绍一下grid网格布局</h2><h2 id="CSS3新增了哪些新特性？"><a href="#CSS3新增了哪些新特性？" class="headerlink" title="CSS3新增了哪些新特性？"></a>CSS3新增了哪些新特性？</h2><p>1.颜色:rgba和hsla模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.5</span>) <span class="comment">//白色半透明</span></span><br></pre></td></tr></table></figure><p>HSL和HSLA颜色：HSL代表色相、饱和度和亮度，而HSLA添加了Alpha通道。这种颜色表示方法更直观，允许你在颜色的基础上进行更精确的调整。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-<span class="attr">color</span>: <span class="title function_">hsl</span>(<span class="number">120</span>, <span class="number">100</span>%, <span class="number">50</span>%); <span class="comment">/* 设置绿色背景 */</span></span><br></pre></td></tr></table></figure><p>2.文字阴影<code>text-shadow</code></p><p>3.边框圆角<code>border-radius</code>,盒子阴影<code>box-shadow</code></p><p>4.盒子模型 <code>box-sizing</code></p><p>5.字体图标 <code>iconfont</code></p><p>6.弹性布局 <code>flex</code></p><h2 id="css3动画有哪些？"><a href="#css3动画有哪些？" class="headerlink" title="css3动画有哪些？"></a>css3动画有哪些？</h2><h2 id="怎么理解回流跟重绘？什么场景下会触发？"><a href="#怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="怎么理解回流跟重绘？什么场景下会触发？"></a>怎么理解回流跟重绘？什么场景下会触发？</h2><h3 id="回流（Reflow）："><a href="#回流（Reflow）：" class="headerlink" title="回流（Reflow）："></a>回流（Reflow）：</h3><ul><li><strong>定义：</strong> 回流是浏览器为了重新渲染部分或全部页面而重新计算元素的位置和几何结构的过程。</li><li><strong>触发场景：</strong> 回流会在以下情况下触发：<ol><li>添加或删除可见的DOM元素。</li><li>元素位置发生变化。</li><li>元素的尺寸发生变化（包括边距、填充、边框、宽度和高度变化）。</li><li>浏览器窗口尺寸发生变化。</li></ol></li><li><strong>影响：</strong> 回流是一种代价高昂的操作，会触发布局的重新计算，影响整个页面的渲染性能。</li></ul><h3 id="重绘（Repaint）："><a href="#重绘（Repaint）：" class="headerlink" title="重绘（Repaint）："></a>重绘（Repaint）：</h3><ul><li><strong>定义：</strong> 重绘是当元素样式发生改变，但不影响其布局时，浏览器将之前绘制的内容重新绘制的过程。</li><li><strong>触发场景：</strong> 重绘会在以下情况下触发：<ol><li>修改元素的颜色。</li><li>修改元素的背景。</li><li>修改元素的可见性。</li><li>修改元素的轮廓（边框）。</li></ol></li><li><strong>影响：</strong> 重绘的性能开销相对较小，因为它不会影响元素的布局，只需重新绘制颜色等样式信息。</li></ul><h3 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a>优化建议：</h3><ol><li><strong>避免直接操作样式：</strong> 使用<code>classList</code>等方法修改类名，一次性更改样式，减少回流和重绘的次数。</li><li><strong>使用文档片段：</strong> 对多次 DOM 操作，可以使用文档片段（DocumentFragment）来减少回流。</li><li><strong>离线操作：</strong> 在对 DOM 进行复杂操作时，可以将元素脱离文档流，完成操作后再放回文档流。</li><li><strong>使用定时器：</strong> 对于某些频繁触发的操作，可以使用定时器将其延迟执行，合并多次操作。</li><li><strong>优化动画：</strong> 对于频繁发生的动画，使用<code>transform</code>和<code>opacity</code>等属性进行优化，避免影响布局。</li></ol><h2 id="什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何做？</h2><h2 id="如果要做优化，CSS提高性能的方法有哪些？"><a href="#如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="如果要做优化，CSS提高性能的方法有哪些？"></a>如果要做优化，CSS提高性能的方法有哪些？</h2><h2 id="如何实现单行／多行文本溢出的省略样式？"><a href="#如何实现单行／多行文本溢出的省略样式？" class="headerlink" title="如何实现单行／多行文本溢出的省略样式？"></a>如何实现单行／多行文本溢出的省略样式？</h2><h2 id="如何使用css完成视差滚动效果"><a href="#如何使用css完成视差滚动效果" class="headerlink" title="如何使用css完成视差滚动效果?"></a>如何使用css完成视差滚动效果?</h2><h2 id="CSS如何画一个三角形？原理是什么？"><a href="#CSS如何画一个三角形？原理是什么？" class="headerlink" title="CSS如何画一个三角形？原理是什么？"></a>CSS如何画一个三角形？原理是什么？</h2><h2 id="让Chrome支持小于12px-的文字方式有哪些？区别？"><a href="#让Chrome支持小于12px-的文字方式有哪些？区别？" class="headerlink" title="让Chrome支持小于12px 的文字方式有哪些？区别？"></a>让Chrome支持小于12px 的文字方式有哪些？区别？</h2><h2 id="说说对Css预编语言的理解？有哪些区别"><a href="#说说对Css预编语言的理解？有哪些区别" class="headerlink" title="说说对Css预编语言的理解？有哪些区别?"></a>说说对Css预编语言的理解？有哪些区别?</h2><h2 id="在css中有哪些定位方式"><a href="#在css中有哪些定位方式" class="headerlink" title="在css中有哪些定位方式"></a>在css中有哪些定位方式</h2><ol><li><strong>Static（静态定位）：</strong><ul><li><code>position: static;</code></li><li>默认值，元素在正常文档流中定位，不受 top, right, bottom, left 属性的影响。</li></ul></li><li><strong>Relative（相对定位）：</strong><ul><li><code>position: relative;</code></li><li>相对于元素在正常文档流中的位置进行定位。通过设置 top, right, bottom, left 属性可以使元素相对于其正常位置进行移动。</li></ul></li><li><strong>Absolute（绝对定位）：</strong><ul><li><code>position: absolute;</code></li><li>相对于最近的已定位祖先元素（不包括 static 定位的元素），如果没有已定位的祖先元素，则相对于最初的包含块（通常是 <code>&lt;html&gt;</code> 元素）进行定位。</li></ul></li><li><strong>Fixed（固定定位）：</strong><ul><li><code>position: fixed;</code></li><li>相对于浏览器窗口进行定位，即使页面滚动，元素位置也不会改变。</li></ul></li><li><strong>Sticky（粘性定位）：</strong><ul><li><code>position: sticky;</code></li><li>相对于用户滚动的容器（滚动时相对于视窗，不滚动时相对于最近的块级祖先）进行定位。在容器滚动到某个阈值之前，元素为相对定位；之后，元素为固定定位。</li></ul></li></ol><h2 id="如何理解z-index"><a href="#如何理解z-index" class="headerlink" title="如何理解z-index?"></a>如何理解z-index?</h2><h2 id="如何画一个0-5像素的线"><a href="#如何画一个0-5像素的线" class="headerlink" title="如何画一个0.5像素的线"></a>如何画一个0.5像素的线</h2><h3 id="1-使用半透明颜色："><a href="#1-使用半透明颜色：" class="headerlink" title="1. 使用半透明颜色："></a>1. 使用半透明颜色：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 半透明黑色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，线条看起来会比较淡，模拟出0.5像素的效果。</p><h3 id="2-使用box-shadow："><a href="#2-使用box-shadow：" class="headerlink" title="2. 使用box-shadow："></a>2. 使用box-shadow：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.5px</span> <span class="number">0</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* 垂直偏移0.5像素的阴影，颜色为黑色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式利用 <code>box-shadow</code> 的模糊效果来实现，同样也可以模拟出较细的线条。</p><h2 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动?"></a>如何清除浮动?</h2><h2 id="你对媒体查询的理解"><a href="#你对媒体查询的理解" class="headerlink" title="你对媒体查询的理解"></a>你对媒体查询的理解</h2><h2 id="标准盒模型和怪异盒模型有哪些区别"><a href="#标准盒模型和怪异盒模型有哪些区别" class="headerlink" title="标准盒模型和怪异盒模型有哪些区别?"></a>标准盒模型和怪异盒模型有哪些区别?</h2><h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="什么是HTTP-HTTP-和-HTTPS-的区别"><a href="#什么是HTTP-HTTP-和-HTTPS-的区别" class="headerlink" title="什么是HTTP? HTTP 和 HTTPS 的区别?"></a>什么是HTTP? HTTP 和 HTTPS 的区别?</h2><p>在回答这个问题时，你可以提供以下基本信息：</p><ol><li><strong>HTTP（Hypertext Transfer Protocol）：HTTP（超文本传输协议）：</strong><ul><li>HTTP是一种用于在Web上进行数据传输的协议。</li><li>它基于客户端-服务器模型，客户端发送请求，服务器返回响应。</li></ul></li><li><strong>HTTPS（Hypertext Transfer Protocol Secure）：HTTPS（安全超文本传输协议）：</strong><ul><li>HTTPS是HTTP的安全版本，通过加密通信内容来提高安全性。</li><li>它使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议来保护数据传输的安全性。</li></ul></li><li><strong>区别：</strong><ul><li><strong>安全性：</strong> HTTP是明文传输的，数据不加密，容易被中间人攻击。而HTTPS通过加密通信内容，确保数据的保密性和完整性，防止窃听和篡改。</li><li><strong>协议：</strong> HTTP使用标准的HTTP协议，而HTTPS在HTTP的基础上加入了SSL或TLS协议，通过这两种协议进行数据加密。</li><li><strong>端口：</strong> HTTP默认使用端口80，而HTTPS默认使用端口443。</li><li><strong>证书：</strong> 在使用HTTPS时，服务器需要获得一个数字证书，由可信任的证书颁发机构（CA）签发，用于验证服务器身份。而HTTP通信过程中无法验证服务器的真实性。</li></ul></li></ol><h2 id="为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？"><a href="#为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？" class="headerlink" title="为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？"></a>为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</h2><ol><li><strong>加密传输：</strong> HTTPS使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密。这意味着在数据传输过程中，即使被截获，也难以被解读，因为只有具备解密密钥的接收方才能还原原始数据。这有助于防止窃听和数据篡改攻击。</li><li><strong>身份验证：</strong> 使用HTTPS的服务器需要获得数字证书，由可信任的证书颁发机构（CA）签发。这个证书用于验证服务器的身份。这种机制有助于防止中间人攻击，确保用户与服务器之间的通信是与正确的服务器建立的连接。</li><li><strong>数据完整性：</strong> 在HTTPS通信中，数据的完整性得到了保护，因为SSL&#x2F;TLS协议使用哈希函数对传输的数据进行摘要，确保数据在传输过程中没有被篡改或损坏。</li><li><strong>防范混合内容攻击：</strong> HTTPS可以防止混合内容攻击，即阻止非安全来源（HTTP）的内容与安全来源（HTTPS）的内容混合在同一个页面上，提高了整体安全性。</li></ol><h2 id="如何理解UDP-和-TCP-区别-应用场景"><a href="#如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="如何理解UDP 和 TCP? 区别? 应用场景?"></a>如何理解UDP 和 TCP? 区别? 应用场景?</h2><ol><li><strong>理解 UDP 和 TCP：</strong><ul><li><strong>UDP（User Datagram Protocol）：UDP（用户数据报协议）：</strong><ul><li>UDP是一种无连接的协议，它不提供像TCP那样的可靠性和顺序传输。</li><li>UDP通过数据包（Datagram）的方式发送数据，每个数据包都是一个独立的实体，相互之间没有关联。</li><li>UDP不保证数据的可靠性和顺序性，但由于其简单性和低开销，适用于一些实时性要求较高的应用场景。</li></ul></li><li><strong>TCP（Transmission Control Protocol）：TCP（传输控制协议）：</strong><ul><li>TCP是一种面向连接的协议，提供可靠的、有序的数据传输服务。</li><li>TCP通过建立连接、数据传输和断开连接的三个阶段来确保数据的完整性和有序性。</li><li>TCP使用流（Stream）的方式传输数据，数据被划分为小的数据块，并确保它们按照顺序传送到目标。</li></ul></li></ul></li><li><strong>区别：</strong><ul><li><strong>可靠性：</strong><ul><li>UDP是不可靠的，不保证数据的可靠性和顺序性。</li><li>TCP是可靠的，通过确认机制和重传机制确保数据的可靠传输。</li></ul></li><li><strong>连接性：</strong><ul><li>UDP是无连接的，每个数据包独立处理，相互之间没有关联。</li><li>TCP是面向连接的，通过建立连接来确保数据传输的完整性。</li></ul></li><li><strong>开销：</strong><ul><li>UDP的开销相对较低，适用于对实时性要求较高的场景。</li><li>TCP的开销较大，但能够提供可靠的、有序的数据传输。</li></ul></li></ul></li><li><strong>应用场景：</strong><ul><li><strong>UDP：</strong><ul><li>适用于实时性要求较高、可以容忍少量数据丢失的场景，如音频和视频流的传输、在线游戏等。</li><li>由于UDP的简单性和低开销，也常用于广播和多播通信。</li></ul></li><li><strong>TCP：传输控制协议：</strong><ul><li>适用于对数据完整性和有序性要求较高的场景，如文件传输、Web页面加载、电子邮件等。</li><li>在需要确保每个数据包都能被正确接收的情况下，使用TCP更为合适。</li></ul></li></ul></li></ol><h2 id="如何理解OSI七层模型"><a href="#如何理解OSI七层模型" class="headerlink" title="如何理解OSI七层模型?"></a>如何理解OSI七层模型?</h2><ol><li><strong>OSI 七层模型概述：</strong><ul><li>OSI七层模型是国际标准化组织（ISO）定义的网络体系结构模型，用于指导不同厂商的网络设备和协议的开发。</li><li>它将网络通信划分为七个逻辑层次，每个层次负责特定的功能，每个层次的功能都建立在下一层提供的服务之上。</li></ul></li><li><strong>七个层次及其功能：</strong><ol><li><strong>物理层（Physical Layer）：</strong><ul><li>主要关注数据的物理传输，例如电缆、光纤、物理连接等。</li><li>定义了数据的传输速率、电压等物理特性。</li></ul></li><li><strong>数据链路层（Data Link Layer）：</strong><ul><li>提供了可靠的点对点和点对多点通信。</li><li>通过帧（Frame）定义数据的格式，进行错误检测和纠正。</li></ul></li><li><strong>网络层（Network Layer）：</strong><ul><li>负责数据的路由和寻址，实现不同网络之间的通信。</li><li>使用IP地址标识网络上的设备，进行数据包的转发。</li></ul></li><li><strong>传输层（Transport Layer）：</strong><ul><li>提供端到端的通信服务，确保数据的可靠传输。</li><li>通过TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）实现数据的流控制和错误处理。</li></ul></li><li><strong>会话层（Session Layer）：</strong><ul><li>管理不同设备之间的通信会话，确保数据的有序传输。</li><li>提供建立、维护和关闭会话的功能。</li></ul></li><li><strong>表示层（Presentation Layer）：</strong><ul><li>负责数据的格式转换、加密和解密，确保数据的格式一致性。</li><li>处理数据的语法和语义问题。</li></ul></li><li><strong>应用层（Application Layer）：</strong><ul><li>提供网络服务和应用程序之间的接口。</li><li>包括用户界面、网络协议和各种应用。</li></ul></li></ol></li><li><strong>理解七层模型的好处：</strong><ul><li><strong>模块化设计：</strong> 每个层次都有特定的功能，使得网络设计更具模块化和可扩展性。</li><li><strong>标准化：</strong> 每个层次的功能都有明确定义的标准，促使了不同厂商设备和协议的互操作性。</li><li><strong>问题定位：</strong> 当网络出现问题时，七层模型有助于迅速定位问题所在的层次。</li></ul></li></ol><h2 id="如何理解TCP-IP协议"><a href="#如何理解TCP-IP协议" class="headerlink" title="如何理解TCP&#x2F;IP协议?"></a>如何理解TCP&#x2F;IP协议?</h2><ol><li><strong>TCP&#x2F;IP协议概述：</strong><ul><li>TCP&#x2F;IP是一组用于互联网通信的协议，包括Transmission Control Protocol (TCP) 和 Internet Protocol (IP)。</li><li>它是互联网的基础通信协议，被用于在网络中传输数据。</li></ul></li><li><strong>TCP 和 IP 的角色：</strong><ul><li><strong>TCP（Transmission Control Protocol）：TCP（传输控制协议）：</strong><ul><li>提供可靠的、面向连接的通信服务。</li><li>确保数据的可靠性、有序性和完整性，通过确认机制和重传机制实现。</li></ul></li><li><strong>IP（Internet Protocol）：IP（互联网协议）：</strong><ul><li>负责数据包的寻址和路由。</li><li>定义了数据包在网络中的传输方式，通过IP地址标识设备和网络。</li></ul></li></ul></li><li><strong>TCP&#x2F;IP协议族：</strong><ul><li>TCP&#x2F;IP协议族包含多个协议，不仅限于TCP和IP，还包括一系列支持网络通信的协议，如UDP、ICMP、ARP等。</li></ul></li><li><strong>分层结构：</strong><ul><li>TCP&#x2F;IP协议以分层结构组织，分为四个层次，分别是应用层、传输层、网络层和数据链路层。</li><li>这种分层结构有助于实现模块化设计和互操作性。</li></ul></li><li><strong>应用场景：</strong><ul><li>TCP&#x2F;IP协议被广泛应用于互联网，支持各种应用，包括Web浏览、电子邮件、文件传输等。</li><li>它也是局域网（LAN）和广域网（WAN）中常用的协议。</li></ul></li><li><strong>开放标准：</strong><ul><li>TCP&#x2F;IP是一个开放标准，使得不同厂商的设备和软件可以互相通信，促进了互联网的发展和扩展。</li></ul></li></ol><h2 id="DNS协议-是什么？说说DNS-完整的查询过程"><a href="#DNS协议-是什么？说说DNS-完整的查询过程" class="headerlink" title="DNS协议 是什么？说说DNS 完整的查询过程?"></a>DNS协议 是什么？说说DNS 完整的查询过程?</h2><p>DNS（Domain Name System）是一种用于将域名（例如<a href="http://www.example.com)转换为对应ip地址的分布式命名系统.它是互联网中用于解析域名的一种关键服务./">www.example.com）转换为对应IP地址的分布式命名系统。它是互联网中用于解析域名的一种关键服务。</a></p><p>DNS查询过程涉及多个步骤，以下是DNS完整的查询过程：</p><ol><li><strong>本地缓存查询：</strong><ul><li>首先，计算机会检查本地缓存，查看之前解析过的域名是否存在于缓存中。如果存在，且尚未过期，就直接使用缓存中的IP地址，从而避免了向DNS服务器发送请求。</li></ul></li><li><strong>递归查询：</strong><ul><li>如果本地缓存中没有相应的记录，计算机将向本地DNS服务器发起递归查询。本地DNS服务器通常由Internet服务提供商（ISP）或其他网络服务提供商提供。</li></ul></li><li><strong>本地DNS服务器查询根域名服务器：</strong><ul><li>如果本地DNS服务器无法解析域名，它将向根域名服务器发送查询请求。根域名服务器是全球DNS体系结构的起始点，负责指导DNS查询进入正确的顶级域名服务器。</li></ul></li><li><strong>根域名服务器返回顶级域名服务器地址：</strong><ul><li>根域名服务器收到请求后，返回顶级域名服务器的地址。顶级域名服务器负责管理特定顶级域（如.com、.org）下的域名信息。</li></ul></li><li><strong>本地DNS服务器查询顶级域名服务器：</strong><ul><li>本地DNS服务器向顶级域名服务器发起查询请求，请求该域名对应的下一级域名服务器的地址。</li></ul></li><li><strong>顶级域名服务器返回权威域名服务器地址：</strong><ul><li>顶级域名服务器返回包含权威域名服务器地址的响应。权威域名服务器是负责管理特定域的具体域名解析信息的服务器。</li></ul></li><li><strong>本地DNS服务器查询权威域名服务器：</strong><ul><li>本地DNS服务器向权威域名服务器发起查询请求，请求解析特定域名的IP地址。</li></ul></li><li><strong>权威域名服务器返回解析结果：</strong><ul><li>权威域名服务器返回包含目标域名的IP地址的响应给本地DNS服务器。</li></ul></li><li><strong>本地DNS服务器缓存结果：</strong><ul><li>本地DNS服务器将从权威域名服务器获取的IP地址存储在缓存中，以备将来使用，并将解析结果返回给计算机。</li></ul></li><li><strong>计算机使用IP地址访问目标网站：</strong><ul><li>最后，计算机获得了域名对应的IP地址，并可以使用该IP地址与目标服务器建立连接，实现数据传输。</li></ul></li></ol><h2 id="如何理解CDN？说说实现原理？"><a href="#如何理解CDN？说说实现原理？" class="headerlink" title="如何理解CDN？说说实现原理？"></a>如何理解CDN？说说实现原理？</h2><p>CDN（Content Delivery Network）是一种用于提高网络性能、减少加载时间以及增强网站安全性的分布式服务。CDN的主要目标是通过在全球范围内部署多个服务器节点，将网站的静态资源（如图像、样式表、脚本等）缓存到这些节点上，从而使用户可以从离他们更近的服务器获取这些资源，提高访问速度和用户体验。</p><p>CDN的实现原理包括以下关键步骤：</p><ol><li><strong>内容缓存和分发：</strong><ul><li>CDN提供商将网站的静态内容（如图片、视频、CSS、JavaScript等）复制到位于全球各地的多个服务器节点上。这些节点通常分布在不同的地理位置，覆盖各个大洲和国家。</li></ul></li><li><strong>DNS解析优化：</strong><ul><li>当用户发起访问请求时，CDN通过DNS解析确定用户的地理位置，并将用户的请求引导到离用户最近的CDN服务器。这通过将域名映射到最近的CDN服务器IP地址来实现。</li></ul></li><li><strong>请求处理和内容提供：</strong><ul><li>用户的请求被发送到最近的CDN服务器，该服务器检查是否已缓存所请求的内容。如果缓存中存在，则直接返回缓存的内容；如果不存在，则向源服务器请求内容，并将内容缓存起来，供将来的请求使用。</li></ul></li><li><strong>动态内容优化：</strong><ul><li>对于动态内容（如个性化的用户数据、动态生成的页面等），CDN提供商可能使用一些技术，如边缘计算（Edge Computing）或者将请求转发到源服务器。这确保了即使是动态生成的内容也能在用户附近快速响应。</li></ul></li><li><strong>负载均衡：</strong><ul><li>CDN使用负载均衡算法来分配用户请求到不同的服务器节点，以确保每个节点都能平均处理请求负荷，提高整体的性能和可靠性。</li></ul></li><li><strong>安全性增强：</strong><ul><li>CDN通常提供安全功能，如DDoS攻击防护、SSL加密等，以增强网站的安全性。</li></ul></li><li><strong>实时监控和分析：</strong><ul><li>CDN提供商通常通过实时监控和分析来了解网络状况，根据流量负载和性能指标动态调整服务器节点的分发策略，以最优化内容传递。</li></ul></li></ol><h2 id="说说-HTTP1-0-1-1-2-0-的区别"><a href="#说说-HTTP1-0-1-1-2-0-的区别" class="headerlink" title="说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?"></a>说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</h2><ol><li><strong>HTTP 1.0：</strong><ul><li><strong>连接管理：</strong> 使用短连接（short-lived connections），每个请求&#x2F;响应都需要建立一个新的TCP连接。这导致了高延迟和性能低效。</li><li><strong>性能：</strong> 每个请求只能得到一个响应，不能复用连接，导致性能相对较差。</li><li><strong>无状态：</strong> HTTP 1.0是无状态的，每个请求都是独立的，服务器不会保留任何关于客户端状态的信息。</li></ul></li><li><strong>HTTP 1.1：</strong><ul><li><strong>持久连接：</strong> 引入了持久连接（persistent connections），允许在单个TCP连接上发送多个请求和响应，减少了连接建立的开销。</li><li><strong>管道化：</strong> 支持请求&#x2F;响应的管道化，可以在一个连接上同时发送多个请求，但由于实现的复杂性和一些潜在的问题，该特性并没有被广泛采用。</li><li><strong>分块传输编码：</strong> 支持分块传输编码（chunked transfer encoding），允许服务器逐块发送响应，而不需要等到整个响应生成完成。</li></ul></li><li><strong>HTTP 2.0：</strong><ul><li><strong>多路复用：</strong> 最显著的改变是引入了多路复用（multiplexing），允许在单个连接上同时发送多个请求和响应，解决了头阻塞问题，提高了性能。</li><li><strong>二进制协议：</strong> 使用二进制格式替代了文本格式，提高了解析的效率。</li><li><strong>头部压缩：</strong> 引入了头部压缩（header compression），减小了传输的开销。</li><li><strong>服务器推送：</strong> 支持服务器推送，服务器可以在客户端请求之前将额外的资源推送给客户端，提高性能。</li></ul></li></ol><h2 id="说说-HTTP-常见的状态码有哪些，适用场景？"><a href="#说说-HTTP-常见的状态码有哪些，适用场景？" class="headerlink" title="说说 HTTP 常见的状态码有哪些，适用场景？"></a>说说 HTTP 常见的状态码有哪些，适用场景？</h2><p>200 表示请求成功</p><p>301访问地址永久重定向</p><p>302 临时重定向</p><p>400-499 客户端错误</p><p>401 表示未授权</p><p>403 表示禁止访问,没有权限</p><p>404 表示请求地址错误,没有对应的资源文件</p><p>500 表示服务端错误</p><h2 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h2><ol><li><strong>用途：</strong><ul><li><strong>GET：</strong> 主要用于请求获取资源，参数通常附加在URL的末尾，通过查询字符串传递。GET请求应该是幂等的，即多次请求的结果应该是一致的，不应该有副作用。</li><li><strong>POST：</strong> 主要用于向服务器提交数据，通常通过请求体传递参数。POST请求可以用于更新服务器上的资源，可能有副作用，不一定是幂等的。</li></ul></li><li><strong>数据传输方式：</strong><ul><li><strong>GET：</strong> 数据通过URL的查询字符串传递，可见于URL中，有长度限制。适合传递少量的非敏感数据。</li><li><strong>POST：</strong> 数据传递在请求体中，对传输的数据类型没有限制，可以传递大量数据，更安全，因为数据不会出现在URL中。</li></ul></li><li><strong>安全性：</strong><ul><li><strong>GET：</strong> 因为数据在URL中可见，不适合传递敏感信息，例如密码等。GET请求更容易被缓存，被浏览器记录，不适合用于传输敏感信息。</li><li><strong>POST：</strong> 数据传递在请求体中，相对于GET更安全，适合用于传输敏感信息，如登录凭据。</li></ul></li><li><strong>可缓存性：</strong><ul><li><strong>GET：</strong> 请求结果容易被缓存，可以被浏览器添加到浏览器历史记录。</li><li><strong>POST：</strong> 请求结果不容易被缓存，不会被浏览器添加到浏览器历史记录。</li></ul></li><li><strong>幂等性：</strong><ul><li><strong>GET：</strong> 应该是幂等的，多次请求的结果应该是一致的。</li><li><strong>POST：</strong> 不要求幂等性，多次请求可能导致不同的结果。</li></ul></li></ol><h2 id="说说-HTTP-常见的请求头有哪些-作用？"><a href="#说说-HTTP-常见的请求头有哪些-作用？" class="headerlink" title="说说 HTTP 常见的请求头有哪些? 作用？"></a>说说 HTTP 常见的请求头有哪些? 作用？</h2><ol><li><strong>Host:</strong><ul><li><strong>作用：</strong> 指定服务器的域名和端口号，告诉服务器请求的目标是哪个主机。</li><li><strong>示例：</strong> <code>Host: www.example.com</code></li></ul></li><li><strong>User-Agent:</strong><ul><li><strong>作用：</strong> 标识客户端的类型和版本，帮助服务器了解请求的来源。</li><li><strong>示例：</strong> <code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</code></li></ul></li><li><strong>Accept:</strong><ul><li><strong>作用：</strong> 告诉服务器客户端能够处理哪些类型的响应数据，通常是指MIME类型。</li><li><strong>示例：</strong> <code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</code></li></ul></li><li><strong>Accept-Language:</strong><ul><li><strong>作用：</strong> 指定客户端能够接受的语言类型，用于服务器选择合适的语言返回响应。</li><li><strong>示例：</strong> <code>Accept-Language: en-US,en;q=0.5</code></li></ul></li><li><strong>Accept-Encoding:</strong><ul><li><strong>作用：</strong> 指定客户端支持的内容编码方式，服务器可以使用这些编码来压缩响应数据。</li><li><strong>示例：</strong> <code>Accept-Encoding: gzip, deflate</code></li></ul></li><li><strong>Connection:</strong><ul><li><strong>作用：</strong> 控制是否需要持久连接，或者在请求完成后关闭连接。</li><li><strong>示例：</strong> <code>Connection: keep-alive</code></li></ul></li><li><strong>Referer:</strong><ul><li><strong>作用：</strong> 表示请求的来源，即当前请求是从哪个URL过来的。</li><li><strong>示例：</strong> <code>Referer: http://www.example.com/page</code></li></ul></li><li><strong>Cookie:</strong><ul><li><strong>作用：</strong> 包含客户端的Cookie信息，用于在请求中传递会话信息等状态。</li><li><strong>示例：</strong> <code>Cookie: username=johndoe; sessionid=abc123</code></li></ul></li><li><strong>Authorization:</strong><ul><li><strong>作用：</strong> 包含了用于进行身份验证的凭证信息，例如用户名和密码。</li><li><strong>示例：</strong> <code>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</code></li></ul></li><li><strong>Content-Type:</strong><ul><li><strong>作用：</strong> 指定请求体的媒体类型，用于告诉服务器发送的数据的格式。</li><li><strong>示例：</strong> <code>Content-Type: application/json</code></li></ul></li></ol><h2 id="说说地址栏输入-URL-敲下回车后发生了什么？"><a href="#说说地址栏输入-URL-敲下回车后发生了什么？" class="headerlink" title="说说地址栏输入 URL 敲下回车后发生了什么？"></a>说说地址栏输入 URL 敲下回车后发生了什么？</h2><p>当在浏览器地址栏输入URL并按下回车时，发生的过程可以简要概括为以下几个步骤：</p><ol><li><strong>URL解析：</strong><ul><li>浏览器首先对输入的URL进行解析，提取出协议、主机名、端口号、路径和查询参数等信息。</li></ul></li><li><strong>DNS解析：</strong><ul><li>浏览器通过DNS（Domain Name System）解析获取服务器的IP地址，以便建立TCP连接。如果浏览器缓存中没有对应的IP地址，将发起DNS查询请求。</li></ul></li><li><strong>建立TCP连接：</strong><ul><li>浏览器通过使用HTTP或HTTPS等协议，与服务器建立TCP连接。对于HTTPS，还需要进行SSL&#x2F;TLS握手过程建立安全连接。</li></ul></li><li><strong>发起HTTP请求：</strong><ul><li>浏览器向服务器发送HTTP请求，包括请求方法（GET、POST等）、路径、请求头、可能的请求体等信息。</li></ul></li><li><strong>服务器处理请求：</strong><ul><li>服务器接收到请求后，根据路径和其他信息，处理相应的业务逻辑，可能涉及到数据库查询、动态页面生成等。</li></ul></li><li><strong>服务器发送HTTP响应：</strong><ul><li>服务器生成HTTP响应，包括状态码、响应头、响应体等，并将其发送回给浏览器。</li></ul></li><li><strong>浏览器接收响应：</strong><ul><li>浏览器接收到服务器的响应后，根据响应头中的信息判断如何处理响应，可能包括渲染HTML、执行JavaScript、加载资源等。</li></ul></li><li><strong>渲染页面：</strong><ul><li>如果响应是HTML，浏览器开始解析HTML文档，构建DOM树；同时，解析CSS创建样式规则，构建CSSOM树；最终，将DOM树和CSSOM树结合，生成渲染树，然后进行布局和绘制，最终将页面显示在用户界面上。</li></ul></li><li><strong>执行JavaScript：</strong><ul><li>如果HTML中包含了JavaScript，浏览器会执行相应的JavaScript代码，可能导致对DOM的修改、发起新的网络请求等操作。</li></ul></li><li><strong>加载资源：</strong><ul><li>页面可能包含引用的其他资源，如图片、样式表、脚本文件等，浏览器会根据需要加载这些资源。</li></ul></li></ol><p>整个过程中，浏览器和服务器之间的通信主要依赖于HTTP协议，而浏览器通过解析HTML、执行JavaScript等来呈现最终的用户界面。这一系列的步骤被称为“HTTP请求-响应周期”或“浏览器渲染流程”。</p><h2 id="说说TCP为什么需要三次握手和四次挥手？"><a href="#说说TCP为什么需要三次握手和四次挥手？" class="headerlink" title="说说TCP为什么需要三次握手和四次挥手？"></a>说说TCP为什么需要三次握手和四次挥手？</h2><p>TCP（Transmission Control Protocol）是一种面向连接的协议，为了确保可靠的数据传输，建立和终止连接时采用了三次握手和四次挥手的过程。</p><h3 id="三次握手（Three-Way-Handshake）："><a href="#三次握手（Three-Way-Handshake）：" class="headerlink" title="三次握手（Three-Way Handshake）："></a>三次握手（Three-Way Handshake）：</h3><ol><li><strong>第一次握手（SYN）：</strong><ul><li>客户端发送一个TCP报文，其中标志位SYN（同步序列编号）被置为1，同时选择一个初始序列号（ISN）。</li></ul></li><li><strong>第二次握手（SYN + ACK）：</strong><ul><li>服务器收到客户端的SYN报文后，会回复一个带有SYN和ACK标志位的报文，表示同意建立连接，并同时选择自己的初始序列号。</li></ul></li><li><strong>第三次握手（ACK）：</strong><ul><li>客户端收到服务器的SYN + ACK报文后，向服务器发送一个带有ACK标志位的报文，表示握手过程完成。</li></ul></li></ol><p><strong>原因：</strong></p><ul><li>第一次握手：建立连接时，客户端告诉服务器自己要发送数据了。</li><li>第二次握手：服务器收到客户端的请求，准备好并告诉客户端可以发送数据了。</li><li>第三次握手：客户端收到服务器的同意，此时连接建立，双方可以开始进行数据传输。</li></ul><h3 id="四次挥手（Four-Way-Handshake）："><a href="#四次挥手（Four-Way-Handshake）：" class="headerlink" title="四次挥手（Four-Way Handshake）："></a>四次挥手（Four-Way Handshake）：</h3><ol><li><strong>第一次挥手（FIN）：</strong><ul><li>客户端发送一个TCP报文，其中标志位FIN（终止连接）被置为1，表示客户端没有数据要发送了。</li></ul></li><li><strong>第二次挥手（ACK）：</strong><ul><li>服务器收到客户端的FIN报文后，向客户端发送一个带有ACK标志位的报文，表示已经收到了客户端的关闭请求。</li></ul></li><li><strong>第三次挥手（FIN）：</strong><ul><li>服务器关闭与客户端的连接，发送一个带有FIN标志位的报文，告知客户端服务器也准备好关闭连接。</li></ul></li><li><strong>第四次挥手（ACK）：</strong><ul><li>客户端收到服务器的FIN报文后，向服务器发送一个带有ACK标志位的报文，表示已经收到了服务器的关闭请求。</li></ul></li></ol><p><strong>原因：</strong></p><ul><li>第一次挥手：客户端没有数据要发送了，告诉服务器可以关闭连接。</li><li>第二次挥手：服务器收到客户端的关闭请求，告诉客户端自己也准备好关闭连接。</li><li>第三次挥手：服务器关闭连接，告知客户端可以安全关闭了。</li><li>第四次挥手：客户端收到服务器的关闭请求，向服务器发送确认，完成关闭过程。</li></ul><p>这样的设计可以确保在连接的建立和断开过程中，双方都能够明确地知道彼此的状态，从而确保数据的可靠传输和连接的正确关闭。</p><h2 id="说说对WebSocket的理解？应用场景？"><a href="#说说对WebSocket的理解？应用场景？" class="headerlink" title="说说对WebSocket的理解？应用场景？"></a>说说对WebSocket的理解？应用场景？</h2><p>WebSocket是一种在单个TCP连接上提供全双工通信的协议，它允许在客户端和服务器之间进行实时、双向的数据传输。WebSocket协议相对于传统的HTTP通信有更低的延迟和更小的开销，因为它避免了在每次通信时都建立新的连接。</p><h3 id="WebSocket的特点和工作原理："><a href="#WebSocket的特点和工作原理：" class="headerlink" title="WebSocket的特点和工作原理："></a>WebSocket的特点和工作原理：</h3><ol><li><strong>全双工通信：</strong> WebSocket允许客户端和服务器之间双向实时通信，可以同时发送和接收数据，而不需要等待对方的响应。</li><li><strong>持久连接：</strong> WebSocket连接一旦建立，可以保持持久性，不需要重复的握手和断开。</li><li><strong>低延迟：</strong> 相对于传统的HTTP轮询或长轮询，WebSocket可以实现更低的延迟，因为通信是即时的，而不需要等待定时轮询。</li><li><strong>轻量级：</strong> 与HTTP相比，WebSocket协议的头部开销较小，减少了通信的数据量。</li></ol><h3 id="WebSocket的工作过程："><a href="#WebSocket的工作过程：" class="headerlink" title="WebSocket的工作过程："></a>WebSocket的工作过程：</h3><ol><li><strong>握手阶段：</strong><ul><li>客户端发起WebSocket连接请求，请求中包含Upgrade头，服务器返回101状态码表示同意升级协议，之后WebSocket连接建立。</li></ul></li><li><strong>数据传输阶段：</strong><ul><li>客户端和服务器可以通过WebSocket连接进行双向的实时数据传输，可以同时发送和接收消息。</li></ul></li><li><strong>关闭阶段：</strong><ul><li>要关闭连接，一方发送一个带有关闭标志的数据帧，另一方接收到后也发送一个带有关闭标志的数据帧，连接就被关闭。</li></ul></li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol><li><strong>即时通讯：</strong> WebSocket适用于实时通讯应用，如在线聊天、消息推送等，因为它允许双方实时发送消息而无需不断建立新的连接。</li><li><strong>在线游戏：</strong> 在线游戏通常需要实时的双向通信，WebSocket可以提供低延迟和高效的数据传输。</li><li><strong>实时协作：</strong> 在协作应用中，多个用户可以实时地编辑和查看共享的文档或画布，WebSocket可以用于同步用户的操作。</li><li><strong>金融交易：</strong> 在金融领域，实时性是非常重要的，WebSocket可以用于实时更新股票价格、交易信息等。</li><li><strong>实时监控：</strong> WebSocket可以用于实时监控系统，及时推送监控数据和报警信息。</li></ol><p>总体而言，WebSocket适用于需要实时、双向通信的场景，它提供了更为高效和低延迟的解决方案，相对于传统的HTTP通信在某些应用场景中具有明显的优势。</p><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h2 id="说说你对微信小程序的理解？优缺点？"><a href="#说说你对微信小程序的理解？优缺点？" class="headerlink" title="说说你对微信小程序的理解？优缺点？"></a>说说你对微信小程序的理解？优缺点？</h2><p>体积小，无需安装，直接在微信里面使用方便用户</p><h2 id="小程序里面怎么发请求？"><a href="#小程序里面怎么发请求？" class="headerlink" title="小程序里面怎么发请求？"></a>小程序里面怎么发请求？</h2><p>这个是最麻烦的，微信小程序原生有<code>wx.request</code>使用回调函数的方式发请求，不支持promise，更没有axios，所以写起来比较麻烦，</p><ul><li>我之前在原生开发的时候下载了一个第三方包，包名好像叫<code>wx_network</code>， <code>wechat_http</code>，有点忘记了，可以支持<code>promise</code>，支持写请求和响应拦截器等，好用</li><li>在uni-app里面开发的时候，使用的是<code>uni.request</code>，这个方法被<code>uni-app</code>自己封装为了 <code>promise</code>的版本，但是返回值是一个数组的形式， <code>const [err, res] = await uni.request(&#39;xxxx&#39;)</code>,也不是很好用</li><li>最后，我在上份工作里面，用的是<code>uview-ui</code>组件库， 这个框架除了给我们提供了组件以外，还给全局的<code>uni</code>绑定了一些 优化请求的方式， <code>uni.$u.http</code>。 我们就可以配置请求的基地址 ，请求响应拦截器。 后面的工作一直用的是它</li></ul><h2 id="小程序有跨域吗？"><a href="#小程序有跨域吗？" class="headerlink" title="小程序有跨域吗？"></a>小程序有跨域吗？</h2><p>没有，只有浏览器有跨域的说法，服务器和小程序都没有跨域，跨域是浏览器这个软件的安全策略</p><ul><li>小程序开发的时候： 在开发者工具勾选一个不校验<code>http</code>的选项就可以了、</li><li>上线以后怎么办： 小程序的后台网站，开发设置里面配置一下对应的域名，好像可以添加200个</li></ul><h2 id="小程序常见的组件通信方式"><a href="#小程序常见的组件通信方式" class="headerlink" title="小程序常见的组件通信方式"></a>小程序常见的组件通信方式</h2><ul><li>父子通信：类似于vue，父向子 <code>properties</code>，子向父通信 <code>triggerEvent</code></li><li>全局数据<code>getApp</code>： 我们一般在小程序里面，将多个组件都需要使用的数据，放到<code>app.js</code>里面，然后通过<code>getApp()</code> 去用</li></ul><h2 id="使用过哪些小程序原生的组件和Api"><a href="#使用过哪些小程序原生的组件和Api" class="headerlink" title="使用过哪些小程序原生的组件和Api"></a>使用过哪些小程序原生的组件和Api</h2><p>这个就很多了，我记不大清了，</p><ul><li>常用的组件比如 <code>view text rich-text navagator导航 swiper轮播图</code> 比较复杂的就是 <code>媒体组件 image 地图组件map等</code></li><li>常用的api就很多了，我自己用过<ul><li>印象比较深刻的就是：<code>微信登录 wx.login 微信支付 wx.requestPayment</code></li><li>其他比较简单的就是：<code>发请求 wx.request, 编程式导航wx.navigateTo, 获取基本信息getUserInfo</code> 其他的记不太清了，看文档直接用，比较简单</li></ul></li></ul><h2 id="uni-app开发的特点"><a href="#uni-app开发的特点" class="headerlink" title="uni-app开发的特点"></a>uni-app开发的特点</h2><ul><li>uni-app 可以编写一套代码，打包成14个平台，节约公司成本，快速搭建各个平台的产品。 我之前公司就用这个写过 微信小程序和 h5的项目，还比较好用，就是有些兼容性，有些细节需要注意</li><li>全部是vue的语法写小程序，上手无压力</li><li>注册时使用组件的时候，支持 easycom的模式。只要符合了基本的结构，不需要导入和注册，直接使用即可</li><li>技术选型是uni-app+uview-ui ； 原生小程序就是 原生语法+vantUI</li></ul><h2 id="说说微信小程序的生命周期函数有哪些？"><a href="#说说微信小程序的生命周期函数有哪些？" class="headerlink" title="说说微信小程序的生命周期函数有哪些？"></a>说说微信小程序的生命周期函数有哪些？</h2><p>首先小程序的生命周期有很多种，应用级别，页面界别和组件级别。开发uni-app的时候因为是vue的语法，所以还有vue的生命周期在里面。所以我们小程序 应用界别和页面级别的采用 小程序的生命周期。自定义组件 采用vue的生命周期</p><ul><li>应用级别(小程序的)，onLaunch —- App.vue文件里面</li><li>页面级别（小程序）,onLoad —– 定义在pages数组里面或者分包里面的 vue文件</li><li>组件级别（vue的）,created</li></ul><p><strong>整个小程序的生命周期：</strong></p><ol><li><strong>onLaunch：</strong> 小程序初始化时触发，全局只触发一次。</li><li><strong>onShow：</strong> 小程序启动或从后台进入前台时触发。</li></ol><p><strong>页面的生命周期：</strong></p><ol><li><strong>onLoad：</strong> 页面加载时触发，一个页面只会调用一次。</li><li><strong>onShow：</strong> 页面显示&#x2F;切入前台时触发。</li><li><strong>onReady：</strong> 页面初次渲染完成时触发，一个页面只会调用一次。</li></ol><p><strong>当从当前页面切换到其他页面：</strong></p><ol><li><strong>onHide：</strong> 当前页面隐藏&#x2F;切入后台时触发。</li></ol><p><strong>当从其他页面返回到当前页面：</strong></p><ol><li><strong>onShow：</strong> 当前页面重新显示&#x2F;切入前台时触发。</li></ol><p><strong>当关闭当前页面或跳转到其他页面时：</strong></p><ol><li><strong>onUnload：</strong> 页面卸载时触发。</li></ol><p><strong>当整个小程序被切入后台或被关闭时：</strong></p><ol><li><strong>onHide：</strong> 小程序从前台进入后台时触发。</li><li><strong>onUnload：</strong> 小程序销毁时触发。</li></ol><h2 id="说说微信小程序中路由跳转的方式有哪些？区别？"><a href="#说说微信小程序中路由跳转的方式有哪些？区别？" class="headerlink" title="说说微信小程序中路由跳转的方式有哪些？区别？"></a>说说微信小程序中路由跳转的方式有哪些？区别？</h2><ol><li><strong>wx.navigateTo:</strong><ul><li>通过该方式进行页面跳转，会保留当前页面，新页面入栈。</li><li>应用场景：一般用于不同业务逻辑的页面之间的跳转，保留当前页面的状态，可以通过返回按钮返回上一页。</li></ul></li><li><strong>wx.redirectTo:</strong><ul><li>通过该方式进行页面跳转，会关闭当前页面，新页面替换当前页面。</li><li>应用场景：用于替换当前页面，适用于一些不需要保留上一页状态的情况。</li></ul></li><li><strong>wx.reLaunch:</strong><ul><li>关闭所有页面，打开到应用内的某个页面。</li><li>应用场景：适用于一些重新登录、进入新的模块等需要清空页面栈的情况。</li></ul></li><li><strong>wx.switchTab:</strong><ul><li>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</li><li>应用场景：用于跳转到 tabBar 页面，比如从其他业务页面返回到首页。</li></ul></li><li><strong>wx.navigateBack:</strong><ul><li>关闭当前页面，返回上一页面或多级页面。</li><li>应用场景：用于返回上一页或多级页面，可以指定返回的层级。</li></ul></li></ol><h2 id="说说提高微信小程序的应用速度的手段有哪些？"><a href="#说说提高微信小程序的应用速度的手段有哪些？" class="headerlink" title="说说提高微信小程序的应用速度的手段有哪些？"></a>说说提高微信小程序的应用速度的手段有哪些？</h2><p>提高微信小程序应用速度的效果可以通过以下手段来实现：</p><ol><li><strong>优化图片：</strong><ul><li>压缩图片：使用适当的图片压缩工具，减小图片文件大小。</li><li>使用合适的图片格式：选择适合场景的图片格式，如JPEG、PNG等。</li><li>使用小程序提供的图片CDN服务，加速图片加载。</li></ul></li><li><strong>减少HTTP请求：</strong><ul><li>尽量减少页面请求的资源数，合并和精简CSS、JavaScript文件。</li><li>使用小程序的本地存储功能，减少对服务器的频繁请求。</li></ul></li><li><strong>合理使用缓存：</strong><ul><li>合理使用小程序的缓存机制，减少重复请求。</li><li>对于不常变化的数据，可以通过缓存在本地减少网络请求次数。</li></ul></li><li><strong>异步加载：</strong><ul><li>使用异步加载方式，减小首屏加载时间。</li><li>对于一些不是首屏必需的内容，可以使用异步加载方式，提高页面渲染速度。</li></ul></li><li><strong>避免使用全局样式：</strong><ul><li>尽量避免使用全局样式，减少对整体样式的重新计算和渲染。</li><li>使用局部样式，限定渲染范围，提高渲染效率。</li></ul></li><li><strong>使用分包加载：</strong><ul><li>对于大型小程序，可以使用分包加载机制，将不同功能的页面分割成不同的包，减小首次加载时的体积。</li></ul></li></ol><h2 id="小程序分包流程"><a href="#小程序分包流程" class="headerlink" title="小程序分包流程"></a>小程序分包流程</h2><h2 id="小程序实现导航栏自定义"><a href="#小程序实现导航栏自定义" class="headerlink" title="小程序实现导航栏自定义"></a>小程序实现导航栏自定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;navigationStyle&quot;</span>: <span class="string">&quot;custom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说微信小程序的登录流程？"><a href="#说说微信小程序的登录流程？" class="headerlink" title="说说微信小程序的登录流程？"></a>说说微信小程序的登录流程？</h2><img src="https://static.vue-js.com/b60638c0-3428-11ec-a752-75723a64e8f5.png" style="zoom:50%;" /><ul><li>通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据</li><li>由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息</li><li>通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到</li><li>微信服务器返回了 openid 及本次登录的会话密钥 session_key</li><li>后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走</li><li>session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输</li><li>然后生成 session并返回给小程序</li><li>小程序把 session 存到 storage 里面</li><li>下次请求时，先从 storage 里面读取，然后带给服务端</li><li>服务端对比 session 对应的记录，然后校验有效期</li></ul><h2 id="说说微信小程序的发布流程？"><a href="#说说微信小程序的发布流程？" class="headerlink" title="说说微信小程序的发布流程？"></a>说说微信小程序的发布流程？</h2><h2 id="说说微信小程序的支付流程？"><a href="#说说微信小程序的支付流程？" class="headerlink" title="说说微信小程序的支付流程？"></a>说说微信小程序的支付流程？</h2><img src="https://static.vue-js.com/76b66780-34a0-11ec-8e64-91fdec0f05a1.png" style="zoom:50%;" /><ul><li>打开某小程序，点击直接下单</li><li>wx.login获取用户临时登录凭证code，发送到后端服务器换取openId</li><li>在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器</li><li>服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息</li><li>小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付</li><li>接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付</li><li>鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示</li><li>推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态</li></ul><p>调用支付接口的五个参数:</p><ol><li><strong>appId（小程序ID）：</strong> 这是你的微信小程序的唯一标识符，每个小程序都有一个独特的App ID。</li><li><strong>timeStamp（时间戳）：</strong> 一个从1970年1月1日00:00:00至今的秒数，即当前的时间戳。</li><li><strong>nonceStr（随机字符串）：</strong> 随机生成的字符串，用于防止重放攻击。</li><li><strong>package（数据包）：</strong> 统一下单接口返回的 prepay_id 参数值，具体内容格式由微信支付定义。</li><li><strong>signType（签名类型）：</strong> 签名算法，目前支持 HMAC-SHA256 和 MD5。</li></ol><h2 id="小程序和h5和pc端开发有什么不一样？"><a href="#小程序和h5和pc端开发有什么不一样？" class="headerlink" title="小程序和h5和pc端开发有什么不一样？"></a>小程序和h5和pc端开发有什么不一样？</h2><p>不一样的主要是交互方式上面，因为小程序屏幕比较小，很多pc电脑上的交互，手机上都用不了</p><ul><li><p>小程序和h5有 上拉刷新，下拉加载的操作</p></li><li><p>小程序和h5有 左滑 右滑的操作， 做一些收藏和删除的业务 （自己打开pdd，京东购物车去操作一遍）</p></li><li><p>小程序和h5有 针对与 iphoneX 那种 刘海屏，底部安全区域的单独设置等等. <strong>constant env 具体的我忘记了</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-in`Set`-bottom); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-in`Set`-bottom); <span class="comment">/* iOS 11.2 */</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>说说你对版本管理的理解？常用的版本管理工具有哪些？</h2><p>版本管理是一种软件开发中重要的实践，用于追踪、管理和协调项目中的代码变更。版本管理有助于团队协作、追踪项目历史、恢复先前的状态，同时提供了一种备份和协同开发的机制。</p><p>分布式管理工具 git</p><p>集中式管理工具 svn</p><h2 id="说说你对Git的理解？"><a href="#说说你对Git的理解？" class="headerlink" title="说说你对Git的理解？"></a>说说你对Git的理解？</h2><h2 id="说说Git中-fork-clone-branch这三个概念，有什么区别"><a href="#说说Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="说说Git中 fork, clone,branch这三个概念，有什么区别?"></a>说说Git中 fork, clone,branch这三个概念，有什么区别?</h2><ol><li><strong>Fork：</strong><ul><li><strong>概念：</strong> Fork是在代码托管平台（如GitHub）上的一个操作，它创建了原始仓库的一个副本，这个副本在你的个人账户下。</li><li><strong>用途：</strong> 主要用于贡献代码或在独立的分支上进行实验性开发。你可以在你自己的Fork中进行修改，然后通过Pull Request（PR）请求将你的修改合并到原始仓库中。</li></ul></li><li><strong>Clone：</strong><ul><li><strong>概念：</strong> Clone是从一个现有的Git仓库中复制整个仓库到本地。</li><li><strong>用途：</strong> 用于获取代码的完整副本，以便在本地进行开发、测试和修改。Clone操作创建了一个连接到原始仓库的本地副本。</li></ul></li><li><strong>Branch：</strong><ul><li><strong>概念：</strong> Branch是指在一个Git仓库中创建的一个独立的分支，分支是仓库中的一个独立的开发路径。</li><li><strong>用途：</strong> 用于在项目中并行开发多个功能或修复不同的bug。每个分支都可以有不同的提交历史，但它们可以在需要时合并在一起。</li></ul></li></ol><p><strong>区别总结：</strong></p><ul><li><strong>Fork：</strong> 在代码托管平台上创建一个原始仓库的副本，通常用于贡献代码和提出修改请求。</li><li><strong>Clone：</strong> 从一个现有的Git仓库中复制整个仓库到本地，用于在本地进行开发和修改。</li><li><strong>Branch：</strong> 在一个Git仓库中创建的一个独立的开发路径，用于并行开发多个功能或修复不同的bug。</li></ul><h2 id="说说Git常用的命令有哪些？"><a href="#说说Git常用的命令有哪些？" class="headerlink" title="说说Git常用的命令有哪些？"></a>说说Git常用的命令有哪些？</h2><p>git branch 分支名  新建新分支</p><p>git checkout 分支名 切换到指定分支</p><p>git remote add 远程分支名 远程仓库地址 建立远程仓库关联</p><p>git merge 分支名 分支合并</p><p>git init 初始化git 仓库</p><p>git add . 提交到暂存区</p><p>git commit -m “提交日志”  提交到本地git 仓库 </p><p>git push 本地仓库推送到远程仓库</p><p>git pull 拉取远程仓库</p><p>git state 查看本地文件状态</p><p>git log 查看文件提交记录</p><h2 id="说说Git-中-HEAD、工作树和索引之间的区别？"><a href="#说说Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="说说Git 中 HEAD、工作树和索引之间的区别？"></a>说说Git 中 HEAD、工作树和索引之间的区别？</h2><ol><li><strong>HEAD：</strong><ul><li><strong>概念：</strong> <code>HEAD</code>是指向当前所在分支的引用，或者指向某个具体的提交（commit）。</li><li><strong>作用：</strong> 在Git中，<code>HEAD</code>用于标识当前工作目录所在的提交版本，也可以用于切换分支、查看历史提交等操作。在HEAD所指向的提交上进行的修改将会成为新的提交。</li></ul></li><li><strong>工作树（Working Tree）：</strong><ul><li><strong>概念：</strong> 工作树是指包含项目实际文件的目录，也就是你在本地计算机上的项目副本。</li><li><strong>作用：</strong> 工作树中的文件可以进行编辑和修改，这些修改会在提交（commit）时被保存到Git仓库。工作树是开发者进行实际工作的地方，也是代码的可视化部分。</li></ul></li><li><strong>索引（Index）：</strong><ul><li><strong>概念：</strong> 索引是一个暂存区域，用于存储将要提交到Git仓库的修改。它是一个缓存区域，记录了工作树中所有文件的状态信息。</li><li><strong>作用：</strong> 在进行提交前，可以通过将文件的修改添加到索引中，形成一个预备提交的状态。这样可以选择性地提交文件的部分修改，而不是一次性提交所有修改。</li></ul></li></ol><p><strong>区别总结：</strong></p><ul><li><strong>HEAD：</strong> 表示当前所在分支的引用或者指向某个具体的提交，标识了当前工作目录所在的版本。</li><li><strong>工作树（Working Tree）：</strong> 是包含实际项目文件的目录，是开发者进行实际工作的地方，可以编辑和修改文件。</li><li><strong>索引（Index）：</strong> 是一个缓存区域，记录了将要提交到Git仓库的修改，可以选择性地添加和提交文件的部分修改。</li></ul><h2 id="说说对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#说说对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="说说对git pull 和 git fetch 的理解？有什么区别？"></a>说说对git pull 和 git fetch 的理解？有什么区别？</h2><ol><li><strong><code>git pull</code>：</strong><ul><li><strong>作用：</strong> <code>git pull</code> 是一条综合命令，它包含了从远程仓库获取更新（<code>git fetch</code>）和合并（<code>git merge</code>）两个步骤。</li><li><strong>使用场景：</strong> 当你希望获取远程仓库的更新并将它们合并到本地分支时，可以使用 <code>git pull</code>。例如，<code>git pull origin master</code> 将从远程的 <code>origin</code> 仓库的 <code>master</code> 分支获取更新并合并到当前本地分支。</li></ul></li><li><strong><code>git fetch</code>：</strong><ul><li><strong>作用：</strong> <code>git fetch</code> 用于从远程仓库获取更新，但它并不会自动合并这些更新到当前分支。</li><li><strong>使用场景：</strong> 当你只希望查看远程仓库的更新，而不进行合并操作时，可以使用 <code>git fetch</code>。它将远程仓库的变更下载到本地，但并不自动修改你的工作目录或当前分支。</li></ul></li></ol><p><strong>区别总结：</strong></p><ul><li><code>git pull</code> 从远程仓库获取更新并尝试自动合并到当前分支，是<code>git fetch</code> 和 <code>git merge</code> 的综合命令。</li><li><code>git fetch</code> 从远程仓库获取更新，但不会自动合并到当前分支。这使得你可以预览远程仓库的变更，然后决定是否进行合并。</li></ul><p>使用 <code>git fetch</code> 的一个常见场景是查看远程仓库的变更情况，然后再决定是否执行 <code>git merge</code> 或 <code>git rebase</code> 将变更合并到本地分支。这样可以避免意外的合并，给予开发者更大的控制权。</p><h2 id="说说你对git-stash-的理解？应用场景？"><a href="#说说你对git-stash-的理解？应用场景？" class="headerlink" title="说说你对git stash 的理解？应用场景？"></a>说说你对git stash 的理解？应用场景？</h2><p><code>git stash</code> 是一个用于保存当前工作目录和暂存区状态的命令。它允许开发者在切换分支或者处理其他任务之前，将未提交的修改暂时存储起来，以便后续恢复。</p><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景：</strong></h4><ol><li><p><strong>临时切换分支：</strong></p><ul><li>当你正在某个分支上工作，但需要切换到其他分支进行紧急修复或测试时，可以使用 <code>git stash</code> 保存当前工作进度，切换分支，完成操作后再通过 <code>git stash apply</code> 恢复。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">egit stash          <span class="comment"># 保存当前工作进度</span></span><br><span class="line">git checkout &lt;branch&gt;  <span class="comment"># 切换到其他分支</span></span><br><span class="line"><span class="comment"># 进行紧急修复或测试</span></span><br><span class="line">git checkout &lt;original-branch&gt;  <span class="comment"># 切回原来的分支</span></span><br><span class="line">git stash apply    <span class="comment"># 恢复之前保存的工作进度</span></span><br></pre></td></tr></table></figure></li><li><p><strong>保存未提交的修改：</strong></p><ul><li>当你在进行一些修改，但突然需要切换到其他任务时，可以使用 <code>git stash</code> 将未提交的修改暂时存储，以免影响其他操作。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash          <span class="comment"># 保存未提交的修改</span></span><br><span class="line"><span class="comment"># 进行其他任务</span></span><br><span class="line">git stash apply    <span class="comment"># 恢复之前保存的修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>避免合并冲突：</strong></p><ul><li>在合并分支之前，如果当前分支有未提交的修改，可以使用 <code>git stash</code> 避免与合并引起的冲突。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash          <span class="comment"># 保存当前分支的修改</span></span><br><span class="line">git pull origin &lt;branch&gt;  <span class="comment"># 从远程拉取最新代码并合并</span></span><br><span class="line">git stash apply    <span class="comment"># 恢复之前保存的修改</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h4><ul><li><code>git stash</code> 不仅会保存工作目录中的修改，还会保存暂存区（Index）的状态。</li><li><code>git stash</code> 默认会保存所有未提交的修改，包括新添加的文件和未追踪的文件。</li><li>可以使用 <code>git stash save &quot;message&quot;</code> 添加一条描述信息，以便在恢复时更容易理解每个 stash 的目的。</li></ul><h2 id="说说你对git-rebase-和-git-merge的理解？区别？"><a href="#说说你对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="说说你对git rebase 和 git merge的理解？区别？"></a>说说你对git rebase 和 git merge的理解？区别？</h2><ul><li><p><strong>Git Rebase：</strong></p><ul><li><code>git rebase</code> 是将一个分支的修改合并到另一个分支的过程。通过重新设置分支的基点，使得提交历史更为线性，避免了合并产生的额外的合并提交。通常用于保持提交历史的整洁。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure></li><li><p><strong>Git Merge：</strong></p><ul><li><code>git merge</code> 是将一个分支的修改合并到另一个分支的过程。它会创建一个新的合并提交，将两个分支的修改合并在一起。这会在提交历史中产生一个新的合并节点。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-branch</span><br></pre></td></tr></table></figure></li></ul><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h4><ol><li><strong>提交历史的形状：</strong><ul><li><strong>Rebase：</strong> 通过 <code>git rebase</code> 合并的提交历史更加线性，没有合并节点，看起来更加整洁。</li><li><strong>Merge：</strong> 通过 <code>git merge</code> 合并的提交历史中会产生合并节点，形成分叉的结构。</li></ul></li><li><strong>合并方式：</strong><ul><li><strong>Rebase：</strong> 会将被合并分支的提交在目标分支的最新提交之后逐个应用，形成一系列新的提交。</li><li><strong>Merge：</strong> 会创建一个新的合并提交，将两个分支的修改合并在一起，并在提交历史中生成一个合并节点。</li></ul></li><li><strong>历史清晰性：</strong><ul><li><strong>Rebase：</strong> 通过 <code>git rebase</code> 可以保持提交历史的整洁和线性，但可能会导致冲突。</li><li><strong>Merge：</strong> 通过 <code>git merge</code> 可以保留原始分支的完整历史，但会在提交历史中产生合并节点。</li></ul></li><li><strong>冲突处理：</strong><ul><li><strong>Rebase：</strong> 如果在 <code>git rebase</code> 过程中发生冲突，需要逐个解决每个冲突。</li><li><strong>Merge：</strong> 如果在 <code>git merge</code> 过程中发生冲突，需要解决一次合并冲突，然后提交。</li></ul></li></ol><h4 id="选择使用场景："><a href="#选择使用场景：" class="headerlink" title="选择使用场景："></a><strong>选择使用场景：</strong></h4><ul><li><p><strong>Rebase：</strong></p><ul><li>用于个人分支，以保持整洁的提交历史。</li><li>不推荐对已经共享给其他开发者的分支进行 rebase。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure></li><li><p><strong>Merge：</strong></p><ul><li>用于合并多个开发者共享的分支，以保留每个开发者的独立提交历史。</li><li>在进行合并时，可以使用 <code>--no-ff</code> 选项以保留合并提交。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-branch --no-ff</span><br></pre></td></tr></table></figure></li></ul><h2 id="说说-git-发生冲突的场景？如何解决？"><a href="#说说-git-发生冲突的场景？如何解决？" class="headerlink" title="说说 git 发生冲突的场景？如何解决？"></a>说说 git 发生冲突的场景？如何解决？</h2><h2 id="说说你对git-reset-和-git-revert-的理解？区别？"><a href="#说说你对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="说说你对git reset 和 git revert 的理解？区别？"></a>说说你对git reset 和 git revert 的理解？区别？</h2><ul><li><p><strong>Git Reset：</strong></p><ul><li><p><code>git re</code>Set&#96;&#96; 用于将当前分支的 HEAD 指针移动到指定的提交，并可选择是否更新工作目录和暂存区。它可以用于撤销提交、移动分支等操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Git Revert：</strong></p><ul><li><p><code>git revert</code> 用于创建新的提交，以撤销先前的提交。它不会移动分支，而是在提交历史中添加一个新的提交，该提交的变更是先前提交的逆操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a><strong>区别：</strong></h4><ol><li><strong>影响提交历史：</strong><ul><li><strong>Reset：</strong> 通过 <code>git reset</code> 可以修改提交历史，将 HEAD 指针移动到指定的提交，从而删除一些提交。这会改变提交历史，不建议对已共享的提交进行 reset 操作。</li><li><strong>Revert：</strong> 通过 <code>git revert</code> 创建一个新的提交，以保持提交历史的完整性。它不修改已有的提交，而是添加新的提交作为撤销操作的记录。</li></ul></li><li><strong>适用场景：</strong><ul><li><strong>Reset：</strong> 适用于本地仓库中的操作，特别是在分支上进行实验性的提交，但不建议在共享的分支上使用 reset。</li><li><strong>Revert：</strong> 适用于已经共享的分支，因为它不改变提交历史，而是添加新的提交来撤销之前的更改。</li></ul></li><li><strong>风险因素：</strong><ul><li><strong>Reset：</strong> 使用 <code>git reset</code> 可能会导致丢失提交，因为它会直接移动 HEAD 指针。</li><li><strong>Revert：</strong> 使用 <code>git revert</code> 通常比较安全，因为它不会改变原有的提交历史，而是创建新的提交来撤销变更。</li></ul></li></ol><h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><ul><li><p><strong>Reset：</strong></p><ul><li>用于本地分支上的实验性提交，当需要撤销一些提交时。</li><li>小组内的协作中，可以通过 re<code>Set</code> 撤销尚未共享的提交。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reSet HEAD~1  <span class="comment"># 撤销最后一次提交</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Revert：</strong></p><ul><li>用于共享的分支上，当需要撤销已经共享的提交时。</li><li>适用于已经推送到远程仓库的分支，以免影响其他开发者。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;  <span class="comment"># 撤销指定提交</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h4><ul><li>在使用 <code>git reset</code> 时，需要谨慎操作，因为它会修改提交历史，可能导致数据丢失。</li><li>在使用 <code>git revert</code> 时，需要处理可能发生的冲突，因为它会创建新的提交。</li></ul><h2 id="git分支规范"><a href="#git分支规范" class="headerlink" title="git分支规范"></a>git分支规范</h2><p>主分支 master&#x2F;main</p><p>测试分支 release</p><p>开发分支 dev</p><h2 id="git如何合并分支部分代码"><a href="#git如何合并分支部分代码" class="headerlink" title="git如何合并分支部分代码"></a>git如何合并分支部分代码</h2><p>在Git中，你可以使用 <code>git cherry-pick</code> 命令来合并某个提交或一系列提交到当前分支。这允许你选择性地合并分支中的部分代码，而不是整个分支。</p><p>以下是使用 <code>git cherry-pick</code> 的步骤：</p><ol><li><p><strong>查找提交 ID：</strong></p><ul><li>首先，使用 <code>git log</code> 命令查找要合并的提交的提交 ID。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p><strong>切换到目标分支：</strong></p><ul><li>切换到你想要将代码合并到的目标分支。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;target-branch&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>执行 cherry-pick：</strong></p><ul><li>使用 <code>git cherry-pick</code> 命令并提供要合并的提交 ID。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></li></ol><p>如果要合并一系列连续的提交，可以使用 commit 范围：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;</span><br></pre></td></tr></table></figure><p>   这里 <code>^</code> 表示排除 <code>start-commit-id</code> 自身。</p><ol start="4"><li><p><strong>处理冲突（如果有）：</strong></p><ul><li>如果合并过程中发生冲突，需要手动解决冲突，然后使用 <code>git add</code> 和 <code>git cherry-pick --continue</code> 完成合并。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted-file&gt;</span><br><span class="line">git cherry-pick --continue</span><br></pre></td></tr></table></figure></li><li><p><strong>完成：</strong></p><ul><li>合并完成后，可以继续进行其他操作或者提交合并结果。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></li></ol><p>请注意，<code>git cherry-pick</code> 可能会引入冲突，特别是当合并的提交依赖于目标分支的其他修改时。在使用 <code>git cherry-pick</code> 时，确保理解合并的影响，并在需要时手动解决冲突。</p><h2 id="如何切换新分支且不产生新记录"><a href="#如何切换新分支且不产生新记录" class="headerlink" title="如何切换新分支且不产生新记录"></a>如何切换新分支且不产生新记录</h2><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="说说你对-TypeScript-的理解？与-JavaScript-的区别？"><a href="#说说你对-TypeScript-的理解？与-JavaScript-的区别？" class="headerlink" title="说说你对 TypeScript 的理解？与 JavaScript 的区别？"></a>说说你对 TypeScript 的理解？与 JavaScript 的区别？</h2><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p><blockquote><p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合 A 里面的的所有元素集合 B 里面都存在，那么我们可以理解集合 B 是集合 A 的超集，集合 A 为集合 B 的子集</p></blockquote><p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p><p>同时扩展了<code>JavaScript</code> 的语法，所以任何现有的<code>JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p><p>为了保证兼容性，<code>TypeScript</code> 在编译阶段需要编译器编译成纯 <code>JavaScript</code> 来运行，是为大型应用之开发而设计的语言，如下：</p><p><code>ts</code> 文件如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello);</span><br></pre></td></tr></table></figure><p>编译文件后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello);</span><br></pre></td></tr></table></figure><h3 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h3><p><code>TypeScript</code> 的特性主要有如下：</p><ul><li><strong>类型批注和编译时类型检查</strong> ：在编译时批注变量类型</li><li><strong>类型推断</strong>：ts 中没有批注变量类型会自动推断变量的类型</li><li><strong>类型擦除</strong>：在编译过程中批注的内容和接口会在运行时利用工具擦除</li><li><strong>接口</strong>：ts 中用接口来定义对象类型</li><li><strong>枚举</strong>：用于取值被限定在一定范围内的场景</li><li><strong>Mixin</strong>：可以接受任意类型的值</li><li><strong>泛型编程</strong>：写代码时使用一些以后才指定的类型</li><li><strong>名字空间</strong>：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li><li><strong>元组</strong>：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li><li>…</li></ul><h3 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h3><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用 <code>JavaScript</code> 常规的动态类型</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Add</span>(<span class="params">left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基本类型的批注是 <code>number</code>、<code>bool</code> 和 <code>string</code>，而弱或动态类型的结构则是 <code>any</code> 类型</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><p>变量 <code>str</code> 被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p><p>如果缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 <code>any</code> 类型</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口简单来说就是用来描述对象的类型 数据的类型有 <code>number</code>、<code>null</code>、<code>string</code> 等数据格式，对象的类型就是用接口来描述的</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><ul><li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li><li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li><li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li><li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li></ul><p>更多的区别如下图所示：</p><h2 id="说说-typescript-的数据类型有哪些？"><a href="#说说-typescript-的数据类型有哪些？" class="headerlink" title="说说 typescript 的数据类型有哪些？"></a>说说 typescript 的数据类型有哪些？</h2><p>typescript 的数据类型主要有如下：</p><p>boolean（布尔类型）<br>number（数字类型）<br>string（字符串类型）<br>array（数组类型）<br>tuple（元组类型）<br>enum（枚举类型）<br>any（任意类型）<br>null 和 undefined 类型<br>void 类型<br>never 类型<br>object 对象类型<br>#boolean<br>布尔类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// flag = 123; // 错误</span></span><br><span class="line">flag = <span class="literal">false</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>#number<br>数字类型，和javascript一样，typescript的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// num = &#x27;456&#x27;; // 错误</span></span><br><span class="line">num = <span class="number">456</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p>进制表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>; <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure><p>#string<br>字符串类型，和JavaScript一样，可以使用双引号（”）或单引号（’）表示字符串</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&#x27;this is ts&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure><p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span></span></span><br></pre></td></tr></table></figure><p>#array<br>数组类型，跟javascript一致，通过[]进行包裹，有两种写法：</p><p>方式一：元素类型后面接上 []</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">string</span>[] = [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;23&#x27;</span>];</span><br><span class="line">arr = [<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;56&#x27;</span>];</span><br></pre></td></tr></table></figure><p>方式二：使用数组泛型，Array&lt;元素类型&gt;：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;56&#x27;</span>];</span><br></pre></td></tr></table></figure><p>#tuple<br>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tupleArr</span>:[<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>];</span><br><span class="line">tupleArr = [<span class="number">12</span>, <span class="string">&#x27;34&#x27;</span>, <span class="literal">true</span>]; <span class="comment">//ok</span></span><br><span class="line">typleArr = [<span class="number">12</span>, <span class="string">&#x27;34&#x27;</span>] <span class="comment">// no ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p><p>#enum<br>enum类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure><p>#any<br>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用any类型</p><p>使用any类型允许被赋值为任意类型，甚至可以调用其属性、方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line">num = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">num = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>定义存储各种类型数据的数组时，示例代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arrayList</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">&#x27;fine&#x27;</span>];</span><br><span class="line">arrayList[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">#<span class="literal">null</span> 和 和 <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>在JavaScript 中 null表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而undefined表示一个没有设置值的变量</p><p>默认情况下null和undefined是所有类型的子类型， 就是说你可以把 null和 undefined赋值给 number类型的变量</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> | <span class="literal">undefined</span>; <span class="comment">// 数值类型 或者 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 正确</span></span><br><span class="line">num = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>但是ts配置了–strictNullChecks标记，null和undefined只能赋值给void和它们各自</p><p>#void<br>用于标识方法返回值的类型，表示该方法没有返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello Runoob&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#never<br>never是其他类型 （包括null和 undefined）的子类型，可以赋值给任何类型，代表从不会出现的值</p><p>但是没有类型是 never 的子类型，这意味着声明 never 的变量只能被 never 类型所赋值。</p><p>never 类型一般用来指定那些总是会抛出异常、无限循环</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">never</span>;</span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// 错误的写法</span></span><br><span class="line"></span><br><span class="line">a = (<span class="function">() =&gt;</span> &#123; <span class="comment">// 正确的写法</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误&#x27;</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#object<br>对象类型，非原始类型，常见的形式通过{}进行包裹</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">object</span>;</span><br><span class="line">obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Wang&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure><p>#三、总结<br>和javascript基本一致，也分成：</p><p>基本类型<br>引用类型<br>在基础类型上，typescript增添了void、any、emum等原始类型</p><h2 id="说说你对-TypeScript-中枚举类型的理解？应用场景？"><a href="#说说你对-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中枚举类型的理解？应用场景？"></a>说说你对 TypeScript 中枚举类型的理解？应用场景？</h2><p>一、是什么<br>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p><p>通俗来说，枚举就是一个对象的所有可能取值的集合</p><p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p><p>枚举的说明与结构和联合相似，其形式为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123;</span><br><span class="line">    标识符①[=整型常数],</span><br><span class="line">    标识符②[=整型常数],</span><br><span class="line">    ...</span><br><span class="line">    标识符N[=整型常数],</span><br><span class="line">&#125;枚举变量;</span><br></pre></td></tr></table></figure><p>#二、使用<br>枚举的使用是通过enum关键字进行定义，形式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> xxx &#123; ... &#125;</span><br><span class="line">声明关键字为枚举类型的方式如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明d为枚举类型Direction</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Direction</span>;</span><br></pre></td></tr></table></figure><p>类型可以分成：</p><p>数字枚举</p><p>字符串枚举</p><p>异构枚举</p><p>#数字枚举<br>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,   <span class="comment">// 值默认为 0</span></span><br><span class="line">    <span class="title class_">Down</span>, <span class="comment">// 值默认为 1</span></span><br><span class="line">    <span class="title class_">Left</span>, <span class="comment">// 值默认为 2</span></span><br><span class="line">    <span class="title class_">Right</span> <span class="comment">// 值默认为 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Down</span> === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Left</span> === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Right</span> === <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>, <span class="title class_">Direction</span>.<span class="property">Down</span>, <span class="title class_">Direction</span>.<span class="property">Left</span>, <span class="title class_">Direction</span>.<span class="property">Right</span>); <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure><p>#字符串枚举<br>枚举类型的值其实也可以是字符串类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="string">&#x27;Right&#x27;</span>], <span class="title class_">Direction</span>.<span class="property">Up</span>); <span class="comment">// Right Up</span></span><br></pre></td></tr></table></figure><p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line"> <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line"> <span class="title class_">Down</span>, <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line"> <span class="title class_">Left</span>, <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line"> <span class="title class_">Right</span> <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#异构枚举<br>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BooleanLikeHeterogeneousEnum</span> &#123;</span><br><span class="line">    <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下我们很少会使用异构枚举</p><p>#本质<br>现在一个枚举的案例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译后，javascript如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>上述代码可以看到， Direction[Direction[“Up”] &#x3D; 0] &#x3D; “Up”可以分成</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="number">0</span></span><br><span class="line"><span class="title class_">Direction</span>[<span class="number">0</span>] = <span class="string">&quot;Up&quot;</span></span><br></pre></td></tr></table></figure><p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="number">0</span>]); <span class="comment">// Up</span></span><br></pre></td></tr></table></figure><p>并且多处定义的枚举是可以进行合并操作，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Center</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，js代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Center&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>可以看到，Direction对象属性回叠加</p><p>#三、应用场景<br>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p><h2 id="说说你对-TypeScript-中接口的理解？应用场景？"><a href="#说说你对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中接口的理解？应用场景？"></a>说说你对 TypeScript 中接口的理解？应用场景？</h2><p>一、是什么<br>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p><p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p><p>typescript的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p><p>#二、使用方式<br>接口定义如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> interface_name &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如有一个函数，这个函数接受一个 User 对象，然后返回这个 User 对象的 name 属性:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user</span>) =&gt; user.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>可以看到，参数需要有一个user的name属性，可以通过接口描述user参数的结构</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user: User</span>) =&gt; user.<span class="property">name</span></span><br></pre></td></tr></table></figure><p>这些属性并不一定全部实现，上述传入的对象必须拥有name和age属性，否则typescript在编译阶段会报错，如下图：</p><p>如果不想要age属性的话，这时候可以采用可选属性，如下表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候age属性则可以是number类型或者undefined类型</p><p>有些时候，我们想要一个属性变成只读属性，在typescript只需要使用readonly声明，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们修改属性的时候，就会出现警告，如下所示：</p><p>这是属性中有一个函数，可以如下表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">    <span class="attr">say</span>: <span class="function">(<span class="params">words: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p><p>类型推断</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user: User</span>) =&gt; user.<span class="property">name</span></span><br><span class="line"><span class="title function_">getUserName</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;yellow&#x27;</span>&#125; <span class="keyword">as</span> <span class="title class_">User</span>)</span><br><span class="line">给接口添加字符串索引签名</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口还能实现继承，如下图：</p><p>也可以继承多个，父类通过逗号隔开，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mother</span> &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>,<span class="title class_">Mother</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#三、应用场景<br>例如在javascript中定义一个函数，用来获取用户的姓名和年龄：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserInfo = <span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="attr">name</span>: $&#123;user.<span class="property">name</span>&#125;, <span class="attr">age</span>: $&#123;user.<span class="property">age</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p><p>&#x2F;&#x2F; 先定义一个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = (<span class="attr">user</span>: <span class="title class_">IUser</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`name: <span class="subst">$&#123;user.name&#125;</span>, age: <span class="subst">$&#123;user.age&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用</span></span><br><span class="line"><span class="title function_">getUserInfo</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;koala&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;);</span><br></pre></td></tr></table></figure><p>包括后面讲到类的时候也会应用到接口</p><h2 id="说说你对-TypeScript-中类的理解？应用场景？"><a href="#说说你对-TypeScript-中类的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中类的理解？应用场景？"></a>说说你对 TypeScript 中类的理解？应用场景？</h2><p>一、是什么<br>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p><p>类是一种用户定义的引用数据类型，也称类类型</p><p>传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本</p><p>在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p><p>但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类</p><p>TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等</p><p>#二、使用方式<br>定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p><p>字段 ： 字段是类里面声明的变量。字段表示对象的有关数据。<br>构造函数： 类实例化时调用，可以为类的对象分配内存。<br>方法： 方法为对象要执行的操作<br>如下例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="attr">engine</span>:<span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">engine:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">engine</span> = engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="title function_">disp</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发动机为 :   &quot;</span>+<span class="variable language_">this</span>.<span class="property">engine</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}<br>#继承<br>类的继承使用过extends的关键字</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br></pre></td></tr></table></figure><p>Dog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类</p><p>Dog类继承了Animal类，因此实例dog也能够使用Animal类move方法</p><p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterClass</span> &#123;</span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;父类的 doPrint() 方法。&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrinter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PrinterClass</span> &#123;</span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">doPrint</span>() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子类的 doPrint()方法。&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#修饰符<br>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p><p>公共 public：可以自由的访问类程序里定义的成员<br>私有 private：只能够在该类的内部进行访问<br>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问<br>#私有修饰符<br>只能够在该类的内部进行访问，实例对象并不能够访问</p><p>并且继承该类的子类并不能访问，如下图所示：</p><p>#受保护修饰符<br>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p><p>有一点不同的是 protected 成员在子类中仍然可以访问</p><p>除了上述修饰符之外，还有只读修饰符</p><p>#只读修饰符<br>通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p><p>除了实例属性之外，同样存在静态属性</p><p>#静态属性<br>这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Square</span>.<span class="property">width</span>) <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure><p>上述的类都能发现一个特点就是，都能够被实例化，在 typescript中，还存在一种抽象类</p><p>#抽象类<br>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p><p>abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;roaming the earch...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;miao miao&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br><span class="line"></span><br><span class="line">cat.<span class="title function_">makeSound</span>() <span class="comment">// miao miao</span></span><br><span class="line">cat.<span class="title function_">move</span>() <span class="comment">// roaming the earch...</span></span><br></pre></td></tr></table></figure><p>#三、应用场景<br>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 React 工程中是很常用的，如下：</p><p>export default class Carousel extends React.Component&lt;Props, State&gt; {}<br>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口</p><p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">children</span>: <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;&gt; | <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">never</span>[] = []</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">speed</span>: <span class="built_in">number</span> = <span class="number">500</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">height</span>: <span class="built_in">number</span> = <span class="number">160</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">animation</span>: <span class="built_in">string</span> = <span class="string">&#x27;easeInOutQuad&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">isAuto</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">autoPlayInterval</span>: <span class="built_in">number</span> = <span class="number">4500</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">afterChange</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">beforeChange</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">selesctedColor</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">showDots</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props 的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> defaultProps = <span class="keyword">new</span> <span class="title class_">Props</span>()</span><br></pre></td></tr></table></figure><p>Props 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p><h2 id="说说你对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#说说你对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h2><p>一、是什么<br>函数是JavaScript 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p><p>在TypeScript 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，TypeScript 为 JavaScript 函数添加了额外的功能，丰富了更多的应用场景</p><p>函数类型在 TypeScript 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p><p>#二、使用方式<br>跟javascript 定义函数十分相似，可以通过funciton 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt; a + b</span><br></pre></td></tr></table></figure><p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p><p>当鼠标放置在第三行add函数名的时候，会出现完整的函数定义类型，通过: 的形式来定于参数类型，通过 &#x3D;&gt; 连接参数和返回值类型</p><p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LongHand</span> = &#123;</span><br><span class="line">  (<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ShortHand</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">当存在函数重载时，只能使用方式一的形式</span><br></pre></td></tr></table></figure><p>#可选参数<br>当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt; a + (b ? b : <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以</p><p>#剩余类型<br>剩余参数与JavaScript的语法类似，需要用 … 来表示剩余参数</p><p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>) =&gt; rest.<span class="title function_">reduce</span>((<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b), a)</span><br></pre></td></tr></table></figure><p>#函数重载<br>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p><p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现</p><p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p><p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上边是声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边是实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">string</span> | <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">string</span> | <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、区别<br>从上面可以看到：</p><p>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型<br>typescript 在参数中，添加可选参数供使用者选择<br>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</p><h2 id="说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中泛型的理解？应用场景？"></a>说说你对 TypeScript 中泛型的理解？应用场景？</h2><p>一、是什么<br>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p><p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型 在typescript中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p><p>假设我们用一个函数，它可接受一个 number 参数并返回一个number 参数，如下写法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnItem</span> (<span class="attr">para</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们打算接受一个 string 类型，然后再返回 string类型，则如下写法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnItem</span> (<span class="attr">para</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p><p>虽然可以使用 any类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p><p>这种情况就可以使用泛型，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p><p>#二、使用方式<br>泛型通过&lt;&gt;的形式进行表述，可以声明：</p><p>函数</p><p>接口</p><p>类</p><p>#函数声明<br>声明函数的形式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 T 和 泛型 U：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap&lt;T, U&gt;(<span class="attr">tuple</span>: [T, U]): [U, T] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">swap</span>([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br></pre></td></tr></table></figure><p>#接口声明<br>声明接口的形式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReturnItemFn</span>&lt;T&gt; &#123;</span><br><span class="line">    (<span class="attr">para</span>: T): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">returnItem</span>: <span class="title class_">ReturnItemFn</span>&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="params">para</span> =&gt;</span> para</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>#类声明<br>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p><p>下面简单实现一个元素同类型的栈结构，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">arr</span>: T[] = []</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stacn</span>&lt;<span class="built_in">number</span>&gt;()</span><br></pre></td></tr></table></figure><p>如果上述只能传递 string 和 number 类型，这时候就可以使用 <T extends xx> 的方式猜实现约束泛型，如下所示：</p><p>除了上述的形式，泛型更高级的使用如下：</p><p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p><p>这时候就设计到泛型的索引类型和约束类型共同实现</p><p>#索引类型、约束类型<br>索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: U) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 object类型，是因为默认情况 object 指的是{}，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 T extends object</p><p>使用如下图所示：</p><p>#多类型约束<br>例如如下需要实现两个接口的类型约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FirstInterface</span> &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SecondInterface</span> &#123;</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以创建一个接口继承上述两个接口，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChildInterface</span> <span class="keyword">extends</span> <span class="title class_">FirstInterface</span>, <span class="title class_">SecondInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确使用如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&lt;T <span class="keyword">extends</span> <span class="title class_">ChildInterface</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">genericProperty</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">genericProperty: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span> = genericProperty</span><br><span class="line">  &#125;</span><br><span class="line">  u<span class="string">`Set`</span>() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span>.<span class="title function_">doSomething</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span>.<span class="title function_">doSomethingElse</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过泛型约束就可以达到多类型约束的目的</p><h2 id="说说你对-TypeScript-中高级类型的理解？有哪些？"><a href="#说说你对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="说说你对 TypeScript 中高级类型的理解？有哪些？"></a>说说你对 TypeScript 中高级类型的理解？有哪些？</h2><p>一、是什么<br>除了string、number、boolean 这种基础类型外，在 typescript 类型声明中还存在一些高级的类型应用</p><p>这些高级类型，是typescript为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p><p>#二、有哪些<br>常见的高级类型有如下：</p><p>交叉类型<br>联合类型<br>类型别名<br>类型索引<br>类型约束<br>映射类型<br>条件类型<br>#交叉类型<br>通过 &amp; 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p><p>语法如下：</p><p>T &amp; U<br>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T , U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U) : T &amp; U &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span> = &#123;&#125;</span></span><br><span class="line"><span class="language-xml">    for (let key in first) &#123;</span></span><br><span class="line"><span class="language-xml">        result[key] = first[key]</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    for (let key in second) &#123;</span></span><br><span class="line"><span class="language-xml">        if(!result.hasOwnProperty(key)) &#123;</span></span><br><span class="line"><span class="language-xml">            result[key] = second[key]</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    return result</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>#联合类型<br>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p><p>语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T | U</span><br></pre></td></tr></table></figure><p>例如 number | string | boolean 的类型只能是这三个的一种，不能共存</p><p>如下所示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    line = command.<span class="title function_">trim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">trim</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#类型别名<br>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p><p>可以使用 type SomeName &#x3D; someValidTypeAnnotation的语法来创建类型别名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> some = <span class="built_in">boolean</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: some = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: some = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: some = <span class="number">123</span> <span class="comment">// 不能将类型“123”分配给类型“some”</span></span><br></pre></td></tr></table></figure><p>此外类型别名可以是泛型:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br></pre></td></tr></table></figure><p>也可以使用类型别名来在属性里引用自己：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p><p>两者最大的区别在于，interface只能用于定义对象类型，而 type 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p><p>#类型索引<br>keyof 类似于 Object.keys ，用于获取一个接口中 Key 的联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">text</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ButtonKeys</span> = keyof <span class="title class_">Button</span></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ButtonKeys</span> = <span class="string">&quot;type&quot;</span> | <span class="string">&quot;text&quot;</span></span><br></pre></td></tr></table></figure><p>#类型约束<br>通过关键字 extend 进行约束，不同于在 class 后使用 extends 的继承作用，泛型内使用的主要作用是对泛型加以约束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Ba</span><span class="string">`Set`</span>ype = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里表示 copy 的参数</span></span><br><span class="line"><span class="comment">// 只能是字符串、数字、布尔这几种基础类型</span></span><br><span class="line"><span class="keyword">function</span> copy&lt;T <span class="keyword">extends</span> <span class="title class_">Ba</span><span class="string">`Set`</span>ype&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 extends 和 keyof 进行约束。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getValue</span>(obj, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p>#映射类型<br>通过 in 关键字做类型的映射，遍历已有接口的 key 或者是遍历联合类型，如下例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnlyObj</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Obj</span>&gt;</span><br></pre></td></tr></table></figure><p>上述的结构，可以分成这些步骤：</p><p>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’<br>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’<br>所以最终ReadOnlyObj的接口为下述：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyObj</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#条件类型<br>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p><p>#三、总结<br>可以看到，如果只是掌握了 typeScript 的一些基础类型，可能很难游刃有余的去使用 typeScript，需要了解一些typescript的高阶用法</p><p>并且typescript在版本的迭代中新增了很多功能，需要不断学习与掌握</p><h2 id="说说你对-TypeScript-装饰器的理解？应用场景？"><a href="#说说你对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 装饰器的理解？应用场景？"></a>说说你对 TypeScript 装饰器的理解？应用场景？</h2><p>一、是什么<br>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p><p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p><p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，@expression 的形式其实是Object.defineProperty的语法糖</p><p>expression求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p><p>#二、使用方式<br>由于typescript是一个实验性特性，若要使用，需要在tsconfig.json文件启动，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typescript装饰器的使用和javascript基本一致</p><p>类的装饰器可以装饰：</p><p>类</p><p>方法&#x2F;属性</p><p>参数</p><p>访问器</p><p>#类装饰<br>例如声明一个函数 addAge 去给 Class 的属性 age 添加年龄.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@addAge</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age!: number;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>上述代码，实际等同于以下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span> = <span class="title function_">addAge</span>(<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; ... &#125;);</span><br></pre></td></tr></table></figure><p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 constructor.prototype.age 就是在每一个实例化对象上面添加一个 age 属性</p><p>#方法&#x2F;属性装饰<br>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p><p>target：对象的原型<br>propertyKey：方法的名称<br>descriptor：方法的属性描述符<br>可以看到，这三个属性实际就是Object.defineProperty的三个参数，如果是类的属性，则没有传递第三个参数</p><p>如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明装饰器修饰方法/属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method</span>(<span class="params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop &quot;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desc &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  descriptor.<span class="property">writable</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">property</span>(<span class="params">target: any, propertyKey: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;target&quot;</span>, target)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;propertyKey&quot;</span>, propertyKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> @property</span><br><span class="line"> <span class="attr">name</span>: string;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @method</span><br><span class="line"> <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;instance method&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @method</span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xmz = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改实例方法say</span></span><br><span class="line">xmz.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;edit&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下图所示：</p><p>#参数装饰<br>接收3个参数，分别是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">target ：当前对象的原型</span><br><span class="line">propertyKey ：参数的名称</span><br><span class="line">index：参数数组中的位置</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyName: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyName);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="meta">@logParameter</span> <span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;message&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> emp = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">emp.<span class="title function_">greet</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输入如下图：</p><p>#访问器装饰<br>使用起来方式与方法装饰一致，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modification</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop &quot;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desc &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@modification</span></span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#装饰器工厂<br>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>#执行顺序<br>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="meta">@f</span>()</span><br><span class="line">    <span class="meta">@g</span>()</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="title function_">f</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): called</span><br><span class="line"><span class="title function_">f</span>(): called</span><br></pre></td></tr></table></figure><p>#三、应用场景<br>可以看到，使用装饰器存在两个显著的优点：</p><p>代码可读性变强了，装饰器命名相当于一个注释<br>在不改变原有代码情况下，对原来功能进行扩展<br>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p><h2 id="说说对-TypeScript-中命名空间与模块的理解？区别？"><a href="#说说对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="说说对 TypeScript 中命名空间与模块的理解？区别？"></a>说说对 TypeScript 中命名空间与模块的理解？区别？</h2><p>一、模块<br>TypeScript 与ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块</p><p>相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的</p><p>例如我们在在一个 TypeScript 工程下建立一个文件 1.ts，声明一个变量a，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后在另一个文件同样声明一个变量a，这时候会出现错误信息</p><p>提示重复声明a变量，但是所处的空间是全局的</p><p>如果需要解决这个问题，则通过import或者export引入模块系统即可，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line">在typescript中，<span class="keyword">export</span>关键字可以导出变量或者类型，用法与es6模块一致，如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过import 引入模块，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, <span class="title class_">Person</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br></pre></td></tr></table></figure><p>#二、命名空间<br>命名空间一个最明确的目的就是解决重名问题</p><p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p><p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p><p>TypeScript 中命名空间使用 namespace 来定义，语法格式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">SomeNameSpaceName</span> &#123;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ISomeInterfaceName</span> &#123;      &#125;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SomeClassName</span> &#123;      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加 export 关键字</p><p>使用方式如下：</p><p>SomeNameSpaceName.SomeClassName<br>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Letter</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> z = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成js如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Letter</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Letter</span>) &#123;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">z</span> = <span class="number">26</span>;</span><br><span class="line">&#125;)(<span class="title class_">Letter</span> || (<span class="title class_">Letter</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>#三、区别<br>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</p><p>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</p><p>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</p><h2 id="说说如何在-React-项目中应用-TypeScript？"><a href="#说说如何在-React-项目中应用-TypeScript？" class="headerlink" title="说说如何在 React 项目中应用 TypeScript？"></a>说说如何在 React 项目中应用 TypeScript？</h2><h2 id="说说如何在Vue项目中应用TypeScript？"><a href="#说说如何在Vue项目中应用TypeScript？" class="headerlink" title="说说如何在Vue项目中应用TypeScript？"></a>说说如何在Vue项目中应用TypeScript？</h2><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><h2 id="说说你对-Node-js-的理解？优缺点？应用场景？"><a href="#说说你对-Node-js-的理解？优缺点？应用场景？" class="headerlink" title="说说你对 Node.js 的理解？优缺点？应用场景？"></a>说说你对 Node.js 的理解？优缺点？应用场景？</h2><h2 id="说说-Node-js-有哪些全局对象？"><a href="#说说-Node-js-有哪些全局对象？" class="headerlink" title="说说 Node.js 有哪些全局对象？"></a>说说 Node.js 有哪些全局对象？</h2><h2 id="说说对-Node-中的-process-的理解？有哪些常用方法？"><a href="#说说对-Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="说说对 Node 中的 process 的理解？有哪些常用方法？"></a>说说对 Node 中的 process 的理解？有哪些常用方法？</h2><h2 id="说说对-Node-中的-fs模块的理解-有哪些常用方法"><a href="#说说对-Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="说说对 Node 中的 fs模块的理解? 有哪些常用方法"></a>说说对 Node 中的 fs模块的理解? 有哪些常用方法</h2><h2 id="说说对-Node-中的-Buffer-的理解？应用场景？"><a href="#说说对-Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="说说对 Node 中的 Buffer 的理解？应用场景？"></a>说说对 Node 中的 Buffer 的理解？应用场景？</h2><h2 id="说说对-Node-中的-Stream-的理解？应用场景？"><a href="#说说对-Node-中的-Stream-的理解？应用场景？" class="headerlink" title="说说对 Node 中的 Stream 的理解？应用场景？"></a>说说对 Node 中的 Stream 的理解？应用场景？</h2><h2 id="说说Node中的EventEmitter-如何实现一个EventEmitter"><a href="#说说Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="说说Node中的EventEmitter? 如何实现一个EventEmitter?"></a>说说Node中的EventEmitter? 如何实现一个EventEmitter?</h2><h2 id="说说对-Node-js-中的事件循环机制理解"><a href="#说说对-Node-js-中的事件循环机制理解" class="headerlink" title="说说对 Node.js 中的事件循环机制理解?"></a>说说对 Node.js 中的事件循环机制理解?</h2><h2 id="说说-Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#说说-Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h2><h2 id="说说对中间件概念的理解，如何封装-node-中间件？"><a href="#说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="说说对中间件概念的理解，如何封装 node 中间件？"></a>说说对中间件概念的理解，如何封装 node 中间件？</h2><h2 id="如何实现jwt鉴权机制？说说你的思路"><a href="#如何实现jwt鉴权机制？说说你的思路" class="headerlink" title="如何实现jwt鉴权机制？说说你的思路"></a>如何实现jwt鉴权机制？说说你的思路</h2><h2 id="如何实现文件上传？说说你的思路"><a href="#如何实现文件上传？说说你的思路" class="headerlink" title="如何实现文件上传？说说你的思路"></a>如何实现文件上传？说说你的思路</h2><h2 id="如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h2><h2 id="Node性能如何进行监控以及优化？"><a href="#Node性能如何进行监控以及优化？" class="headerlink" title="Node性能如何进行监控以及优化？"></a>Node性能如何进行监控以及优化？</h2><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="1-项目中有封装过axios吗？主要是封装哪些方面"><a href="#1-项目中有封装过axios吗？主要是封装哪些方面" class="headerlink" title="1. 项目中有封装过axios吗？主要是封装哪些方面"></a>1. 项目中有封装过axios吗？主要是封装哪些方面</h2><p>有的，主要就是随着项目规模的增大，为了方便管理和维护我们的代码，提高代码质量，在项目中都会对axios进行一个二次封装</p><p>在封装的同时需要和后端进行协商好，请求参数，状态码和请求的超时时间</p><p>主要有以下的几个方面</p><p>设置接口请求前缀，利用node环境变量来判断，区分开发，测试，生产的不同环境，</p><p>在我们本地调试的时候，如果后端没有开启cors跨域，我们就需要在vue配置文件中进行配置devServer代理转发从而实现跨域请求</p><p>请求头：在请求头里面，有的一些业务必须要携带token或者是其他的参数才可以请求，就需要对请求的配置对象在请求数据时携带上token，这样就不用每次请求数据时，还要去手动加上token</p><p>状态码：根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p><p>请求拦截器：依据请求头的请求设定，来决定哪些请求是可以访问的</p><p>响应拦截器：这块就是根据后端返回的状态码执行不同的业务</p><p>封装请求方法，先把axios实例引入进来，在把不同的请求方法，用一个函数保存起来，最后对外暴露出去，然后在需要使用该请求方法的页面导入，直接调用即可</p><p>可以把所有的有相同业务逻辑的请求方法写在一个api文件夹里面，就比如说，要做权限的业务，就可以把所有的请求方法放在一个permission.js的文件里面，做薪资管理的就可以把所有的请求方法放在一个salary.js的文件里面，方便后期的统一管理和维护</p><h2 id="2-vue项目中跨域问题的解决"><a href="#2-vue项目中跨域问题的解决" class="headerlink" title="2. vue项目中跨域问题的解决"></a>2. vue项目中跨域问题的解决</h2><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p><p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p><blockquote><p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p></blockquote><h3 id="二、如何解决"><a href="#二、如何解决" class="headerlink" title="二、如何解决"></a>二、如何解决</h3><p>解决跨域的方法有很多，下面列举了三种：</p><ul><li>JSONP</li><li>CORS</li><li>Proxy</li></ul><p>而在<code>vue</code>项目中，我们主要针对<code>CORS</code>或<code>Proxy</code>这两种方案进行展开</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p><p><code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p><p>只要后端实现了 <code>CORS</code>，就实现了跨域</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p><p><strong>方案一</strong></p><p>如果是通过<code>vue-cli</code>脚手架工具搭建项目，我们可以通过<code>webpack</code>为我们起一个本地服务器作为请求的代理对象</p><p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</p><p>在<code>vue.config.js</code>文件，新增以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">amodule.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8084</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">// vue项目启动时自动打开浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123; <span class="comment">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class="comment">//目标地址，一般是指后台服务器地址</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="comment">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&quot;&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>axios</code>发送请求中，配置请求的根路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方案二</strong></p><p>此外，还可通过服务端实现代理请求转发</p><p>以<code>express</code>框架为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname + <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123; <span class="attr">target</span>: <span class="string">&#x27;http://localhost:4000&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">false</span></span><br><span class="line">                      &#125;));</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app</span><br></pre></td></tr></table></figure><p><strong>方案三</strong></p><p>通过配置<code>nginx</code>实现代理</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen    <span class="number">80</span>;</span><br><span class="line">    # server_name www.josephxia.com;</span><br><span class="line">    location / <span class="punctuation">&#123;</span></span><br><span class="line">        root  /var/www/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    location /api <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass  http<span class="punctuation">:</span><span class="comment">//127.0.0.1:3000;</span></span><br><span class="line">        proxy_redirect   off;</span><br><span class="line">        proxy_`Set`_header  Host       $host;</span><br><span class="line">        proxy_`Set`_header  X-Real-IP     $remote_addr;</span><br><span class="line">        proxy_`Set`_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-本地开发完后部署到服务器后404是什么原因"><a href="#3-本地开发完后部署到服务器后404是什么原因" class="headerlink" title="3. 本地开发完后部署到服务器后404是什么原因"></a>3. 本地开发完后部署到服务器后404是什么原因</h2><p>当我们进入到子路由时刷新页面，<code>web</code>容器没有相对应的页面此时会出现404</p><p>所以我们只需要配置将任意页面都重定向到 <code>index.html</code>，把路由交由前端处理</p><p>对<code>nginx</code>配置文件<code>.conf</code>修改，添加<code>try_files $uri $uri/ /index.html;</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location / <span class="punctuation">&#123;</span></span><br><span class="line">    index  /data/dist/index.html;</span><br><span class="line">    try_files $uri $uri/ /index.html;</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>修改完配置文件后记得配置的更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 <code>index.html</code> 文件</p><h2 id="4-项目中的错误处理"><a href="#4-项目中的错误处理" class="headerlink" title="4. 项目中的错误处理"></a>4. 项目中的错误处理</h2>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常用简写技巧</title>
      <link href="/2022/07/27/js%E5%B8%B8%E7%94%A8%E7%AE%80%E5%86%99%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/07/27/js%E5%B8%B8%E7%94%A8%E7%AE%80%E5%86%99%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>分享一些自己常用的js简写技巧，长期更新，会着重挑选一些实用的简写技巧，使自己的代码更简洁优雅~</p><p>这里只会收集一些大多数人不知道的用法，但是确实能提高自己的编码技巧，像ES6那些基础的简写语法或者是三目运算符代替if else那些我觉得是基础，没必要写在这里浪费精力。</p><p>注意本篇内容涉及到的语法从ES6到ES11不等，具体使用需要考虑项目兼容性问题！<br>另外推荐一个只用一行代码实现一个方法的实用网站1loc.dev，github<br>If-Else 用 || 或 ?? 运算符进行简化<br>逻辑或操作符||，这里要注意的是0和’’也会认为是false<br>如果||前面的值是0 ‘’ false null undefined NaN其中的任意一种，则直接返回||后面的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = obj || &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于 =&gt;&gt;</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">if</span>(</span><br><span class="line">    obj === <span class="number">0</span> || </span><br><span class="line">    obj === <span class="string">&quot;&quot;</span> || </span><br><span class="line">    obj === <span class="literal">false</span> || </span><br><span class="line">    obj === <span class="literal">null</span> || </span><br><span class="line">    obj === <span class="literal">undefined</span> ||</span><br><span class="line">    <span class="built_in">isNaN</span>(obj)</span><br><span class="line">  )&#123;</span><br><span class="line">     a = &#123;&#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     a = obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空值合并操作符??如果没有定义左侧返回右侧。如果是，则返回左侧。<br>这种方法非常实用，有时候仅仅只是想判断一个字段有没有值，而不是把空字符串或者0也当做false处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = obj ?? &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于 =&gt;&gt;</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">if</span>(</span><br><span class="line">    obj === <span class="literal">null</span> || </span><br><span class="line">    obj === <span class="literal">undefined</span></span><br><span class="line">  )&#123;</span><br><span class="line">     a = &#123;&#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     a = obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入框非空的判断（有时候不想把0当成false可以用此方法。比如分数0也是个值，这种情况就不能认为是false）<br>js复制代码if(value !&#x3D;&#x3D; null &amp;&amp; value !&#x3D;&#x3D; undefined &amp;&amp; value !&#x3D;&#x3D; ‘’){}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于 ==&gt;</span></span><br><span class="line"><span class="keyword">if</span>((value ?? <span class="string">&#x27;&#x27;</span>) !== <span class="string">&#x27;&#x27;</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">includes的正确使用姿势</span><br><span class="line">在上面逻辑或操作符||代码段里有一个<span class="keyword">if</span>判断比较长，这时候就可以用includes去简化代码</span><br><span class="line">js复制代码<span class="keyword">if</span>(</span><br><span class="line">  obj === <span class="number">0</span> || </span><br><span class="line">  obj === <span class="string">&quot;&quot;</span> || </span><br><span class="line">  obj === <span class="literal">false</span> || </span><br><span class="line">  obj === <span class="literal">null</span> || </span><br><span class="line">  obj === <span class="literal">undefined</span></span><br><span class="line">)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用includes简化</span></span><br><span class="line"><span class="keyword">if</span>([<span class="number">0</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">undefined</span>].<span class="title function_">includes</span>(obj))&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止崩溃的可选链(?.)<br>可选链操作符?.<br>如果访问未定义的属性，则会产生错误。这就是可选链的用武之地。<br>在未定义属性时使用可选链运算符，undefined将返回而不是错误。这可以防止你的代码崩溃。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> student = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lwl&quot;</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;New York&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一层一层判断</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student &amp;&amp; student.<span class="property">address</span> &amp;&amp; student.<span class="property">address</span>.<span class="property">ZIPCode</span>) <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="comment">// 使用可选链操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student?.<span class="property">address</span>?.<span class="property">ZIPCode</span>) <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure><p>可选链运算符也可以用于方法调用。如果方法存在，它将被调用，否则将返回 undefined。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from foo!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>?.() <span class="comment">// 输出：&#x27;Hello from foo!&#x27;</span></span><br><span class="line">obj.<span class="property">bar</span>?.() <span class="comment">// 输出：undefined，因为 bar 方法不存在</span></span><br></pre></td></tr></table></figure><p>同样，数组也可以使用。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">4</span>]) <span class="comment">// 输出：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可选链运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr?.[<span class="number">0</span>]) <span class="comment">// 输出：1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr?.[<span class="number">4</span>]) <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr?.[<span class="number">0</span>]?.<span class="title function_">toString</span>()) <span class="comment">// 输出：&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">逻辑空赋值(??=)</span><br><span class="line">逻辑空赋值??=</span><br><span class="line">逻辑空赋值运算符(x ??= y)仅在 x 是 nullish (<span class="literal">null</span> 或 <span class="literal">undefined</span>) 时对其赋值。</span><br><span class="line">javascript复制代码<span class="keyword">const</span> a = &#123; <span class="attr">duration</span>: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">duration</span> ??= <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">duration</span>);</span><br><span class="line"><span class="comment">// expected output: 50</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">speed</span> ??= <span class="number">25</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">speed</span>);</span><br><span class="line"><span class="comment">// expected output: 25</span></span><br></pre></td></tr></table></figure><p>快速生成1-10的数组<br>生成0-9，利用了数组的下标值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [...<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">keys</span>()]</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(<span class="number">10</span>), <span class="function">(<span class="params">v, k</span>) =&gt;</span> k)</span><br></pre></td></tr></table></figure><p>生成1-10，通过map的特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> arr2 = [...<span class="title class_">Array</span>(<span class="number">10</span>)].<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> i + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>快速生成10个0的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>快速生成10个[]的数组（二维数组）<br>注意： 二维数组不能直接写成new Array(10).fill([])（也就是fill方法不能传引用类型的值，[]换成new Array()也不行）,因为fill里传入引用类型值会导致每一个数组都指向同一个地址，改变一个数据的时候其他数据也会随之改变，详见mdn官方说明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>([]) <span class="comment">// 注意这是错误写法，不要这么写</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>().<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>())</span><br><span class="line"></span><br><span class="line">数组降维</span><br></pre></td></tr></table></figure><p>你是否还在用递归给一个多维数组降维？如果是，那你应该知道一下es6的 flat() 方法。<br>如果不确定需要降维的数组有多深，可以传入最大值作为参数Infinity，默认值深度为1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> flatArr = arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>) <span class="comment">// 输出 [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>你是否在使用map的时候想要对数组降维？大概像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> [v, v * <span class="number">2</span>]).<span class="title function_">flat</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出 [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><p>其实js也提供了更简便的方法，那就是flatMap()，可以改成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="keyword">const</span> result = arr.<span class="title function_">flatMap</span>(<span class="function"><span class="params">v</span> =&gt;</span> [v, v * <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>Set集合实践：数组去重、交集、并集、差集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js复制代码<span class="comment">// 1.数组去重 </span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>] </span><br><span class="line"><span class="keyword">let</span> result1 = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)] </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1) <span class="comment">// [1, 3, 2, 4] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.交集 </span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>] </span><br><span class="line"><span class="keyword">let</span> result2 = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)].<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>(arr2).<span class="title function_">has</span>(v)) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2) <span class="comment">// [3, 4] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.并集 </span></span><br><span class="line"><span class="keyword">let</span> result3 = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...arr1, ...arr2])] </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result3) <span class="comment">// [1, 3, 2, 4, 7] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.差集 </span></span><br><span class="line"><span class="keyword">let</span> result4 = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1)].<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> !(<span class="keyword">new</span> <span class="title class_">Set</span>(arr2).<span class="title function_">has</span>(v))) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result4) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>在没有第三个变量的情况下交换两个变量<br>在 JavaScript 中，你可以使用解构从数组中拆分值。这可以应用于交换两个变量而无需第三个<br>比较简单，es6语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>将对象的值收集到数组中<br>用于Object.values()将对象的所有值收集到一个新数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> info = &#123; <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>, <span class="attr">country</span>: <span class="string">&quot;Finland&quot;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LONGER FORM</span></span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> info) &#123;</span><br><span class="line">  data.<span class="title function_">push</span>(info[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SHORTHAND</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title class_">Object</span>.<span class="title function_">values</span>(info);</span><br></pre></td></tr></table></figure><p>指数运算符（用的不多）<br>你Math.pow()习惯把一个数字提高到一个幂吗？你知道你也可以使用<strong>运算符吗？<br>虽然可以简写，不过我还是建议写成Math.pow()方法，代码更有语义化。<br>注意：</strong>运算符要求操作数为数值类型，不过在js里也能正常运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出: 8 </span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span>; <span class="comment">// 输出: 8 </span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">4</span>, <span class="number">0.5</span>); <span class="comment">// 输出: 2 </span></span><br><span class="line"><span class="number">4</span> ** <span class="number">0.5</span>; <span class="comment">// 输出: 2 </span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, -<span class="number">2</span>); <span class="comment">// 输出: 0.1111111111111111 </span></span><br><span class="line"><span class="number">3</span> ** -<span class="number">2</span>; <span class="comment">// 输出: 0.1111111111111111 </span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>); <span class="comment">// 输出: 8 (参数被自动转换为数字) </span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> ** <span class="string">&#x27;3&#x27;</span>; <span class="comment">// js中输出: 8，其他语言可能报错</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>() 简写（用的不多）</span><br><span class="line">向下取整<span class="title class_">Math</span>.<span class="title function_">floor</span>()并不是什么新鲜事。但是你知道你也可以使用~~运算符吗？</span><br><span class="line">同上虽然可以简写，不过我还是建议写成<span class="title class_">Math</span>.<span class="title function_">floor</span>()方法，代码更有语义化。</span><br><span class="line">注意：对于正数而言两者都是直接去掉小数位，但对于负数来说<span class="title class_">Math</span>.<span class="title function_">floor</span>()是向下取整，~~依然是只去掉小数位，整数位不变。 请看下面输出结果：</span><br><span class="line">javascript复制代码<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">3.14</span>); <span class="comment">// 输出: 3 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">5.7</span>); <span class="comment">// 输出: 5 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(-<span class="number">2.5</span>); <span class="comment">// 输出: -3 </span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">10</span>); <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">~~<span class="number">3.14</span>; <span class="comment">// 输出: 3 </span></span><br><span class="line">~~<span class="number">5.7</span>; <span class="comment">// 输出: 5 </span></span><br><span class="line">~~(-<span class="number">2.5</span>); <span class="comment">// 输出: -2 </span></span><br><span class="line">~~<span class="number">10</span>; <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure><p>逗号运算符(,)</p><p>逗号（ , ）运算符对它的每个操作数从左到右求值，并返回最后一个操作数的值。这让你可以创建一个复合表达式，其中多个表达式被评估，复合表达式的最终值是其成员表达式中最右边的值。这通常用于为 for 循环提供多个参数。</p><p>这里只说一下函数return的时候用逗号运算符简化代码的技巧，其他用法请直接点击查看官方文档。<br>举一个简单的例子：<br>js复制代码&#x2F;&#x2F; 简化前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">result</span> = arr =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">result</span>([<span class="number">1</span>,<span class="number">2</span>])) <span class="comment">// 输出：[1, 2, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><p>这段代码需要返回修改后的数组，不能直接return arr.push(‘a’)，因为push的返回值是修改后数组的长度，这时候可以用逗号运算符简化成一行代码。<br>js复制代码&#x2F;&#x2F; 简化后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">result</span> = arr =&gt; (arr.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>), arr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">result</span>([<span class="number">1</span>,<span class="number">2</span>])) <span class="comment">// 输出：[1, 2, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><p>Array.map()的简写<br>比如想要拿到接口返回的特定字段的值，可以用解构赋值和对象的简写方法对map方法简写，详细解释请移步js map方法应用场景 处理对象数组。<br>比如接口返回数据，此时如果只想要数据里的id和name，就可以用下面的简写方式。<br>js复制代码&#x2F;&#x2F; 接口返回数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">res = [&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">16</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lisi&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="number">1</span></span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法：箭头函数、 解构赋值</span></span><br><span class="line"><span class="keyword">const</span> data = res.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123;id, name&#125;</span>) =&gt;</span> (&#123;id, name&#125;))</span><br><span class="line"><span class="comment">// 第二种方法：箭头函数、返回对象（相对更容易理解）</span></span><br><span class="line"><span class="keyword">const</span> data = res.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> (&#123;<span class="attr">id</span>: v.<span class="property">id</span>, <span class="attr">name</span>: v.<span class="property">name</span>&#125;))</span><br></pre></td></tr></table></figure><p>文字排序<br>我们知道数组方法sort()默认是按照UTF-16码元值升序排序</p><p>我们可以使用charCodeAt()方法获取UTF-16码元</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对于中文或者其他语言按照拼音排序（字典顺序排序）则需要用到<span class="title function_">localeCompare</span>()方法</span><br><span class="line">js复制代码[<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;赵五&#x27;</span>, <span class="string">&#x27;王二&#x27;</span>, <span class="string">&#x27;陈六&#x27;</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// 输出：[&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王二&#x27;, &#x27;赵五&#x27;, &#x27;陈六&#x27;]</span></span><br><span class="line">[<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;赵五&#x27;</span>, <span class="string">&#x27;王二&#x27;</span>, <span class="string">&#x27;陈六&#x27;</span>].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">localeCompare</span>(b, <span class="string">&#x27;zh-Hans-CN&#x27;</span>))</span><br><span class="line"><span class="comment">// 输出：[&#x27;陈六&#x27;, &#x27;李四&#x27;, &#x27;王二&#x27;, &#x27;张三&#x27;, &#x27;赵五&#x27;]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;Date&#x27;</span>, <span class="string">&#x27;apricot&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>].<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// 输出：[&#x27;Banana&#x27;, &#x27;Banana&#x27;, &#x27;Date&#x27;, &#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherry&#x27;]</span></span><br><span class="line">[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;Date&#x27;</span>, <span class="string">&#x27;apricot&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">localeCompare</span>(b, <span class="string">&#x27;en&#x27;</span>))</span><br><span class="line"><span class="comment">// 输出：[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;Banana&#x27;, &#x27;Banana&#x27;, &#x27;cherry&#x27;, &#x27;Date&#x27;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;zh&#x27;</span> 表示主语言标记，代表中文。</span><br><span class="line"><span class="string">&#x27;Hans&#x27;</span> 是脚本子标记，表示简体汉字。</span><br><span class="line"><span class="string">&#x27;CN&#x27;</span> 是区域子标记，表示中国。</span><br></pre></td></tr></table></figure><p>如果您不提供locales参数（第二个参数），localeCompare方法通常会默认使用浏览器或操作系统的当前语言环境</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与作用域链</title>
      <link href="/2022/07/27/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2022/07/27/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是作用域和作用域链"><a href="#什么是作用域和作用域链" class="headerlink" title="什么是作用域和作用域链?"></a>什么是作用域和作用域链?</h2><p>作用域(scope):简单来说作用域就是变量能够生效的一个范围,一旦超过了这个范围变量就无法访问</p><p>作用域链(Scope Chain):访问变量的一个查找过程,首先会在当前的作用域进行查找,查找不到就会返回到父级作用域来查找,若是依旧没有找到,就会依次逐级向上查找,直到全局作用域,变量访问的原则遵循<strong>就近原则</strong></p><p>作用域的类型:</p><ol><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ol><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>在<code>foo</code>函数内声明了一个名字叫Jack ,在函数内访问打印,没有问题,但是在函数外无法访问到,<code>name</code>变量的生效范围只有函数的{ } 内这么大一块的范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> name =<span class="string">&#x27;jack&#x27;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//jack</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域可通过<code>ES6</code>新增命令<code>let</code>和<code>const</code>声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);<span class="comment">//0,1,2,3,4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);<span class="comment">//Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>声明在<code>&lt;script&gt;</code>标签和<code>js</code>文件最外层的就是全局作用域,使用<code>var</code>声明的变量也是属于全局作用域,无论在哪里都可以被访问到。</p><p>这里在全局声明了一个变量 a 赋值为了10,在全局和函数内都可以被访问到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><p>所有<code>window</code>对象的属性拥有全局作用域</p><p>一般情况下，<code>window</code>对象的内置属性都拥有全局作用域，例如<code>window.name</code>、<code>window.location</code>、<code>window.top</code>等等。</p><p>全局作用域有个弊端：如果我们写了很多行 <code>JS</code> 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p><p>值得注意的是若是变量没有声明直接进行赋值也属于全局变量,不推荐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age);<span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age);<span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>为<code>window</code>对象动态添加的属性默认也是属于全局的,同样不推荐</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> one = <span class="string">&#x27;bac&#x27;</span>;</span><br><span class="line">  <span class="comment">// 打印 &#x27;one&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(one);</span><br><span class="line">  <span class="comment">// 打印 &#x27;foo&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">  number = <span class="number">42</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(number);  <span class="comment">// 打印 42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fo</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当函数<code>fo()</code>被调用，<code>Javascript</code>引擎首先在当前作用域下寻找变量<code>bac</code>，然后寻找<code>foo</code>变量但发现在当前作用域下找不到，然后继续在外部作用域寻找找到了它(这里是在全局作用域找到的)。</p><p>然后将<code>42</code>赋值给变量<code>number</code>。<code>Javascript</code>引擎会在当前作用域以及外部作用域下一步步寻找<code>number</code>变量(没找到)。</p><p>如果是在非严格模式下，引擎会创建一个<code>number</code>的全局变量并把<code>42</code>赋值给它。但如果是严格模式下就会报错了。</p><p><strong>结论：</strong>当使用一个变量的时候，<code>Javascript</code>引擎会循着作用域链一层一层往上找该变量，直到找到该变量为止。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作用域:</p><ul><li>作用域是指变量、函数和对象的可访问范围。</li><li>JavaScript中的作用域分为全局作用域和局部作用域。</li><li>全局作用域中定义的变量可以在整个程序中访问，称为全局变量。</li><li>局部作用域由函数创建，在函数内部定义的变量只能在函数内部访问，称为局部变量或函数作用域变量。</li></ul><p>作用域链:</p><ul><li>作用域链是一种变量查找机制，用于确定在特定作用域中访问变量时的查找顺序。</li><li>当访问一个变量时，JavaScript引擎首先在当前作用域中查找该变量，如果找到了则直接使用。</li><li>如果在当前作用域中没有找到该变量，JavaScript引擎将会沿着作用域链向上一级作用域继续查找，直到找到该变量或者抵达全局作用域。</li><li>作用域链的尽头是全局作用域，如果在所有的嵌套作用域中都找不到该变量，JavaScript引擎将抛出 <code>ReferenceError</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http强缓存和协商缓存</title>
      <link href="/2022/05/07/http%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
      <url>/2022/05/07/http%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>为了减少资源请求次数，加快资源访问速度，浏览器会对资源文件如图片、css文件、js文件等进行缓存，而浏览器缓存策略又分为<strong>强缓存</strong>和<strong>协商缓存</strong>，什么是强缓存？什么是协商缓存？两者之间的区别又是什么？接下来本文就带大家深入了解这方面的知识。</p><h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>所谓强缓存，可以理解为强制缓存的意思，即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用，且由于直接从本地缓存读取资源文件，大大提高了加载速度。</p><p>强缓存的具体流程为：</p><p>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置<code>Cache-Control: max-age=31536000</code>，max-age代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/373d5015fed14a7e96de8f5a87f85325~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/5a496f3c85ad4a19b541a9d3d9651220~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>使用缓存的话，状态码200后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。</p><p>当缓存时间到期后再次访问时，状态码200后面便没有括号内的内容了。</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/defb8b22fd914b46ae37bf1afc07d609~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><blockquote><p>一般来说，浏览器会将较大的资源缓存到disk cache，而较小的资源则被缓存到memory cache里。内存缓存与磁盘缓存相比，访问速度要更快一些！</p></blockquote><p><code>Cache-Control</code>除了max-age外，还可以设置其它属性值：</p><ul><li>no-cache: 不使用强缓存（但仍会使用协商缓存）。</li><li>no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。</li><li>private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。</li><li>public: 客户端和代理服务器都可缓存。</li><li>s-maxage: 与max-age类似，区别是s-maxage是设定代理服务器的缓存时间。</li></ul><p>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是Http1.0规范，<code>Cache-Control</code>是Http1.1规范，<code>Expires</code>返回一个具体的时间值（如下图所示），代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/f8686051a1504cb78d5ab6be86ec6a43~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>因为<code>Expires</code>参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是<code>Expires</code>的一个缺点，所以有了后来Http1.1规范的<code>Cache-control</code>。</p><p>另外，<code>Cache-control</code>的优先级要高于<code>Expires</code>，如果两者同时设置，会优先使用<code>Cache-control</code>而忽略掉Expires。</p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存，协商缓存的具体流程如下：</p><p>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比。</p><ul><li>如果没有变化则返回304，告诉浏览器继续使用缓存（不返回资源文件）。</li><li>如果发生变化，则返回200和最新的资源文件给浏览器使用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/1a24c905da134f0cb8659b918da5cc12~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5134815de7488588717a865d743a92~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>除了<code>Etag</code>外，还有一个<code>Last-Modified</code>的属性，它是Http1.0规范的，服务器返回<code>Last-Modified</code>，浏览器请求头对应携带的是<code>If-Modified-since</code>，与<code>Etag</code>不同的是，<code>Last-Modified</code>的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/bc31ce3b334a4fb88395861afbd2e9b1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>相比<code>Last-Modified</code>，<code>Etag</code>优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code>不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。</p><blockquote><p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>强缓存就是浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。</p><p>协商缓存则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年用过的css奇妙用法之能用css就不用js技巧系列</title>
      <link href="/2021/09/27/%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%94%A8%E8%BF%87%E7%9A%84css%E5%A5%87%E5%A6%99%E7%94%A8%E6%B3%95%E4%B9%8B%E8%83%BD%E7%94%A8css%E5%B0%B1%E4%B8%8D%E7%94%A8js%E6%8A%80%E5%B7%A7%E7%B3%BB%E5%88%97/"/>
      <url>/2021/09/27/%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%94%A8%E8%BF%87%E7%9A%84css%E5%A5%87%E5%A6%99%E7%94%A8%E6%B3%95%E4%B9%8B%E8%83%BD%E7%94%A8css%E5%B0%B1%E4%B8%8D%E7%94%A8js%E6%8A%80%E5%B7%A7%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>嵌套的圆角</p><p>在遇到内外两层圆角时，可以通过 CSS 变量动态去计算内部的圆角，看起来会更加和谐</p><p>核心代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attr">--anzhiyu-nested-radius</span>: <span class="built_in">calc</span>(<span class="built_in">var</span>(--radius) - <span class="built_in">var</span>(--padding));</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nested</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--anzhiyu-nested-radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《css嵌套的圆角》在线运行1024code</p><p>视图转换动画 View Transitions API<br>我们先从一个简单的例子来认识一下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们实现一个简单交互，点击每个元素，元素就会被删除</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list<span class="selector-class">.addEventListener</span>(&#x27;click&#x27;, function(ev)&#123;</span><br><span class="line">  if (ev<span class="selector-class">.target</span><span class="selector-class">.className</span> === &#x27;item&#x27;) &#123;</span><br><span class="line">    ev<span class="selector-class">.target</span><span class="selector-class">.remove</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用 css修饰一下就变成了以下效果</p><p>功能正常，就是有点太过生硬了</p><p>现在轮到 View Transitions 出场了！我们只需要在改变状态的地方添加document.startViewTransition，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">list<span class="selector-class">.addEventListener</span>(&#x27;click&#x27;, function(ev)&#123;</span><br><span class="line">  if (ev<span class="selector-class">.target</span><span class="selector-class">.className</span> === &#x27;item&#x27;) &#123;</span><br><span class="line">    document<span class="selector-class">.startViewTransition</span>(() =&gt; &#123; // 开始视图变换</span><br><span class="line">      ev<span class="selector-class">.target</span><span class="selector-class">.remove</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">list<span class="selector-class">.addEventListener</span>(&#x27;click&#x27;, function(ev)&#123;</span><br><span class="line">  if (document<span class="selector-class">.startViewTransition</span>) &#123; // 如果支持就视图变换</span><br><span class="line">    document<span class="selector-class">.startViewTransition</span>(() =&gt; &#123; // 开始视图变换</span><br><span class="line">      ev<span class="selector-class">.target</span><span class="selector-class">.remove</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123; // 不支持就执行原来的逻辑</span><br><span class="line">    ev<span class="selector-class">.target</span><span class="selector-class">.remove</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在效果如下</p><p>加速startViewTransition监听后的效果加速startViewTransition监听后的效果</p><p>删除前后现在有一个淡入淡出的效果了，也就是默认的动画效果，我们可以把这个动画时长设置大一点，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">view-transition-old</span>(root), <span class="comment">/* 旧视图*/</span></span><br><span class="line">::<span class="built_in">view-transition-new</span>(root) &#123; <span class="comment">/* 新视图*/</span></span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个伪元素我们后面再做介绍，先看效果</p><p>延长动画时间延长动画时间</p><p>是不是明显感觉过渡变慢了许多？</p><p>但是这种动画还是不够舒服，是一种整体的变化，看不出删除前后元素的位置变化。</p><p>接下来我们给每个元素指定一个标识，用来标记变化前后的状态，为了方便控制，可以借助 CSS 变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;list&quot; id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;item&quot; style=&quot;<span class="attr">--i</span>: a1<span class="string">&quot;&gt;1&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a2<span class="string">&quot;&gt;2&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a3<span class="string">&quot;&gt;3&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a4<span class="string">&quot;&gt;4&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a5<span class="string">&quot;&gt;5&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a6<span class="string">&quot;&gt;6&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a7<span class="string">&quot;&gt;7&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a8<span class="string">&quot;&gt;8&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a9<span class="string">&quot;&gt;9&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;</span>item<span class="string">&quot; style=&quot;</span>--i: a10<span class="string">&quot;&gt;10&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>这里通过view-transition-name来设置名称</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  view-<span class="attribute">transition</span>-name: <span class="built_in">var</span>(--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以得到这样的效果，每个元素在变化前后会自动找到之前的位置，并且平滑的移动过去，如下</p><p>是不是非常丝滑？这就是 View Transitions 的魅力！</p><p>在动画执行的过程中，还会在页面根节点自动创建以下伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::view-transition</span><br><span class="line">└─ ::<span class="built_in">view-transition-group</span>(root)</span><br><span class="line">   └─ ::<span class="built_in">view-transition-image-pair</span>(root)</span><br><span class="line">      ├─ ::<span class="built_in">view-transition-old</span>(root)</span><br><span class="line">      └─ ::<span class="built_in">view-transition-new</span>(root)</span><br></pre></td></tr></table></figure><p>控制台截图控制台截图</p><p>其中，::view-transition-old表示「旧视图」的状态，也就是变化之前的截图，::view-transition-new表示「新视图」的状态，也就是变化之后的截图。</p><p>默认情况下，整个页面root都会作为一个状态，也就是上面的::view-transition-group(root)，在切换前后会执行淡入淡出动画，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>::<span class="built_in">view-transition-new</span>(root) &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: -ua-view-transition-fade-in; <span class="comment">/*淡入动画*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:root</span>::<span class="built_in">view-transition-old</span>(root) &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: -ua-view-transition-fade-out; <span class="comment">/*淡出动画*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是为什么在使用了document.startViewTransition后整个页面会有淡入淡出的效果了</p><p>详细的内容这里不再做过多赘述。</p><p>最佳实践:《View Transitions API》</p><p>另外还有几个有趣的案例</p><p>《css动画拖拽排序》</p><p>《数字过渡动画》</p><p>类似于 APP 的转场动画（多页面跳转）</p><p>总的来说，原生的视图转换动画可以很轻松的实现两种状态的过渡，让 web 也能实现媲美原生 APP 的动画体验，下面再来回顾一下整个变化过程：</p><p>调用document.startViewTransition，浏览器会捕捉当前页面的状态，类似于实时截图，或者“快照”</p><p>执行实际的 dom 变化，再次记录变化后的页面状态（截图）</p><p>触发两者的过渡动画，包括透明度、位移等变化，也可以自定义 CSS 动画</p><p>默认情况下是整个页面的淡入淡出变化</p><p>::view-transition-old表示「旧视图」的状态，也就是变化之前的截图，::view-transition-new表示「新视图」的状态，也就是变化之后的截图。</p><p>如果需要指定具体元素的变化，可以给该元素指定view-transition-name</p><p>前后变化不一定要同一元素，浏览器是根据view-transition-name寻找的</p><p>同一时间页面上不能出现两个相同view-transition-name的元素，不然视图变化会失效</p><p>另外，视图转换动画应该作为一种「体验增强」的功能，而非必要功能，在使用动画时其实拖慢了页面打开或者更新的速度，并且在动画过程中，页面是完全“冻结”的，做不了任何事情，因此需要衡量好动画的时间，如果页面本身就很慢就更不要使用这些动画了。</p><p>参考链接<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API">https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API</a></p><p> <a href="https://code.juejin.cn/pen/7268263402853072931">https://code.juejin.cn/pen/7268263402853072931</a></p><p> <a href="https://codepen.io/xboxyan/pen/BavBevP">https://codepen.io/xboxyan/pen/BavBevP</a></p><p> <a href="https://code.juejin.cn/pen/7268262983178911779">https://code.juejin.cn/pen/7268262983178911779</a></p><p> <a href="https://codepen.io/xboxyan/pen/WNLeBgY">https://codepen.io/xboxyan/pen/WNLeBgY</a></p><p> <a href="https://code.juejin.cn/pen/7268257573277532219">https://code.juejin.cn/pen/7268257573277532219</a></p><p> <a href="https://codepen.io/xboxyan/pen/poqzmLY">https://codepen.io/xboxyan/pen/poqzmLY</a></p><p>css属性占用<br>问题的原因，众所周知，CSS 中的transform是一个包含很多值的属性，例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这并不是简写，而是就该这么写，这一点和background不一样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;1xxx&#x27;</span>) <span class="number">10px</span> <span class="number">10px</span> / <span class="number">20px</span> <span class="number">20px</span> no-repeat; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;<em>等同于以下写法</em>&#x2F;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;1xxx&#x27;</span>); </span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分开写的好处在于，如果只需要改变某一部分就很容易覆盖</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.div1</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;2xxx&#x27;</span>); <span class="comment">/*只改变图片，不改变其他*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面，如果希望改变transform中的某一部分，就不太行了，必须把没改变的部分也写一遍，而且更改的部分也无法抽离出来作为一个公共的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.scale</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>) <span class="comment">/*这样不行，会丢失translate*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;<em>必须写完整</em>&#x2F;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.scale</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">scale</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那如何巧妙的解决这个问题呢？</p><p>用其他方式来代替 transform<br>碰到这种情况，第一感觉可能就是放弃原有transform属性，用其他方式代替。</p><p>比如translate(-50%, -50%)一般是为了实现元素居中效果，可以用flex等其他方式实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto; <span class="comment">/*通过margin:auto实现居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如translate(10px, 10px)这样的偏移，可以用left或者margin-left等方式实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者干脆再包裹一层父级，也能避免transform被占用的问题。</p><p>transform 的单独赋值<br>前面提到过transform并不是一个简写属性，所以没有办法像background那样对某一部分进行赋值。为了解决这个问题，从Chrome 104开始，浏览器终于正式支持单独赋值了</p><p>有兴趣的可以参考这篇文章：解放生产力！transform 支持单独赋值改变</p><p>就拿前面那个例子来说</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以写成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  translate: -<span class="number">50%</span> -<span class="number">50%</span>;</span><br><span class="line">  scale: <span class="number">1.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果需要改变某一部分，就只需要像普通属性一样覆盖就行了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.scale</span>&#123;</span><br><span class="line">  scale: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过目前兼容性欠佳，谨慎使用！（适合内部项目尝鲜）</p><p>借助 CSS 变量拆分属性</p><p>前面的transform 的单独赋值虽然很好，但是太新了，无法立刻在项目中使用。下面介绍一个兼容性更好，使用更放心的解决方案。</p><p>还是上面这个例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>) <span class="built_in">scale</span>(<span class="number">1.5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 CSS 变量，将transform拆分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attr">--translate</span>: -<span class="number">50%</span>, -<span class="number">50%</span>;</span><br><span class="line">  <span class="attr">--scale</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="built_in">var</span>(--translate)) <span class="built_in">scale</span>(<span class="built_in">var</span>(--scale))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样拆分以后，CSS 变量就成了独立属性，如果需要覆盖，只需要修改其中一个就行了，而无需关注–translate是什么样的，这样变化的部分就可以单独作为一个公共的样式了，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">  <span class="attr">--translate</span>: -<span class="number">50%</span>, -<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">  <span class="attr">--translate</span>: <span class="number">10px</span>, <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.scale</span>&#123;</span><br><span class="line">  <span class="attr">--scale</span>: <span class="number">2</span>; <span class="comment">/*无需关注其他transform，可以作为公共的样式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是非常清晰明了？下面是一个演示demo</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span><span class="selector-pseudo">:checked</span>+<span class="selector-tag">div</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">--scale</span>: <span class="number">1.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动是动了，但是没有过渡，太生硬了，那如何解决呢？</p><p>这就需要用到@property了，是干什么的呢？简单来讲，可以自定义属性，让自定义变量像颜色一样进行过渡和动画，换句话说，现在执行动画的是–scale这个属性，而不再是transform了</p><p>将这个自定义属性通过@property定义一下就行了，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> --scale &#123; </span><br><span class="line">  syntax: <span class="string">&#x27;&lt;number&gt;&#x27;</span>;</span><br><span class="line">  inherits: false;</span><br><span class="line">  initial-value: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于@property的应用，可以参考以下文章</p><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@property">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@property</a></p><p>其实不至于transform，很多类似的都可以用到这个技巧，比如颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">el&#123;</span><br><span class="line">  <span class="attr">--r</span>: <span class="number">255</span>;</span><br><span class="line">  <span class="attr">--g</span>: <span class="number">255</span>;</span><br><span class="line">  <span class="attr">--b</span>: <span class="number">255</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="built_in">var</span>(--r), <span class="built_in">var</span>(--g), <span class="built_in">var</span>(--b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下</p><p>部分 CSS 属性比较复杂，比如transform，很容易被占用<br>通常的解决方式是规避，比如换一种居中方式，或者用left、top等代替<br>新出现的transform 的单独属性可以解决这个问题，目前还比较新，仅适合内部项目尝鲜<br>借助 CSS 变量可以拆分复杂的属性<br>借助 @property 让CSS自定义属性支持过渡动画<br>不仅仅是 transform，思维放开，复杂的属性都可以采取这样的思路</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全网最通俗易懂的讲解git rebase和git merge的原理和区别</title>
      <link href="/2021/07/27/%E5%85%A8%E7%BD%91%E6%9C%80%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2%E8%A7%A3%20git%20rebase%E5%92%8Cgit%20merge%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/07/27/%E5%85%A8%E7%BD%91%E6%9C%80%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2%E8%A7%A3%20git%20rebase%E5%92%8Cgit%20merge%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>Git 作为现在最流行的版本管理工具，想必大家在开发过程中都会使用。由于 Git 中很多操作默认是采用 Merge 进行的，并且相对也不容易出错，所以很多人都会使用 Merge 来进行合并代码。但Rebase 作为 Git 中主要命令之一，我们还是有必要了解一下，在适合的场景中进行使用。<br> <img src="/./assets/0.png"></p><h1 id="2-Rebase-的作用"><a href="#2-Rebase-的作用" class="headerlink" title="2. Rebase 的作用"></a>2. Rebase 的作用</h1><p>Rebase 中文翻译过来：<code>变基</code>，我觉得这个翻译挺生硬的，导致很多人没有彻底理解变基的含义。我个人把 Rebase 意为 <code>认爸爸</code>，比如可以 Rebase 到马爸爸分支上，成为他的合理继承人。<br> <img src="/./assets/b16f8107f6764e95ac4d4467cca98d100.png"><br> 上图为一次 Rebase 的情况，可以看到最终效果仿佛 Feature 分支没有存在过，新提交的 Commit 像真的在主分支上提交一样。而如果我们用 Merge 就会产生一个合并节点：<br> <img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/d21b5a64472b4bdea29fd2e9c7513f17~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 可能只看到一次合并所产生的 Commit 节点并没有什么，但实际项目中大概率会变成这样：<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edff7351d03a44d485e93fce8624c7ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 简直是乱的一批，仿佛看到了多年前其他人写的一堆代码，啥啥啥，这都是啥！反过来看看采用 Rebase 开发的真实项目，没有对比就没有伤害：<br> <img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/d3df64fa3c834e919c7e9ede0d373458~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 这也是为什么尤雨溪也比较推荐使用 rebase的原因：<br> <img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/037550764da74a53a8e0e5efbfd63bf3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><h1 id="3-Rebase-怎么用"><a href="#3-Rebase-怎么用" class="headerlink" title="3. Rebase 怎么用"></a>3. Rebase 怎么用</h1><p>其实很多人不用 Rebase ，一方面是不了解实际项目协同中怎么用。另一方面是用了，但问题很多，所以就误认为不好用从而再也不用。这里分享一下，我最近在做项目时所采用 Rebase 方面的协同流程（为了好说明，适当的进行了简化）：</p><h2 id="3-1-Checkout"><a href="#3-1-Checkout" class="headerlink" title="3.1 Checkout"></a>3.1 Checkout</h2><p>首先，我们想从 master 分支上开发新的功能或者修复 bug ，需要 checkout出来一个分支。比如在<br> A节点中 checkout dev 分支，为了让场景更复杂，在 <code>git checkout dev </code>分支后。master 上继续有人提交了B、C，形成如下Git 结构：<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7073ae34eaa84968a17da0a9792ba070~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 这里强调一下，很多人用 Rebase 出问题，都是出在了想要 Rebase 的分支是公共分支。其实这里的 dev 应该是只有自己用的分支才合适，回想一下，Git 本身就是分布式版本管理。其实不用远程仓库也是可以非常好的进行版本控制的，我们要将本地分支和远程分支的概念区分的开一些，这俩没有直接联系。所以你本机随便做个 NB 分支一样可以的，Rebase后没人知道你自己起了个什么鬼名字。</p><h2 id="3-2-远程管理"><a href="#3-2-远程管理" class="headerlink" title="3.2 远程管理"></a>3.2 远程管理</h2><p>如果自己的dev分支并不一定在一台电脑上开展，为了可以自己在多个电脑上开发，我们可以关联了一个自己的远程仓库。这一步是可选的。</p><h2 id="3-3-开始变基"><a href="#3-3-开始变基" class="headerlink" title="3.3 开始变基"></a>3.3 开始变基</h2><p>现在我们在 dev 上开发了D、E，然后<code>dev rebase master</code>，形成了A、B、C、D、E：<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f212464382649b3adb4dc2306bdbcbc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 这里虽然看似已经一条直线了，但实际 只有 dev 知道自己的爸爸成为了 master，但 master 并没有认这个儿子。所以我们还需要：<code>master merge dev</code>，这样就在master上形成了一条完美的直线：<br> <img src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/28dba999af1441d3b35d7aba9762e139~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 最后，再<code> git push origin master</code> 到远程分支，完成本次开发。</p><h2 id="3-4-善后"><a href="#3-4-善后" class="headerlink" title="3.4 善后"></a>3.4 善后</h2><p>Rebase 后 dev 由于变基了，相当于已经认贼作父了，现在还想再认回来？休想！所以只能强制解决，在非保护分支中强制push到自己的远程仓库：<code>git push --force origin dev</code>，最后再将dev变基到自己的远程分支：<code>git rebase origin dev</code>，方便自己远程仓库的维护。至此，完成了一次rebase形式的开发，并且可以继续进行下次开发。</p><h1 id="4-Rebase-的优缺点"><a href="#4-Rebase-的优缺点" class="headerlink" title="4. Rebase 的优缺点"></a>4. Rebase 的优缺点</h1><p>先说说优点：</p><ul><li>保持提交历史的线性：使用 merge 合并分支时，会创建一个新的合并提交，从而在提交历史中形成一条新的分支。而使用 rebase，可以将提交记录直接添加到目标分支的末尾，从而保持提交历史的线性。</li><li>减少不必要的合并提交：使用 merge 合并分支时，会创建一个新的合并提交，它可能会包含很多无意义的合并信息。而使用 rebase，可以将提交记录逐个添加到目标分支的末尾，避免了创建不必要的合并提交。</li><li>更好的代码审查和追溯：使用 rebase，可以让提交历史更加直观和易于理解，从而更容易进行代码审查和问题追溯。</li><li>避免冲突的产生：在合并分支时，可能会因为两个分支之间存在冲突而导致合并失败。而使用 rebase，可以在变基之前先解决这些冲突，从而避免了合并时出现的冲突。</li></ul><p>总之，虽然 rebase 不是适用于所有情况的万能解决方案，但在大多数情况下，使用 rebase 能够帮助我们创建更加干净和直观的提交历史，提高团队的协作效率。</p><p>说了这么说好像都在说 Rebase 的优点，那 Rebase就没有缺点嘛？当然不是，要不然大家早就都从 Merge 转 Rebase了。Rebase 的缺点：</p><ul><li>解决冲突繁琐，rebase冲突 是按每个commit来对比的，merge冲突 是按最终结果来对比的，如果用rebase最好是经常去合并一下代码，不然长周期的开发如果就在最后rebase真的是解冲突解到人傻掉。</li><li>没有合并记录，Merge 有记录，出了问题好解决。</li><li>操作步骤相对繁琐。</li></ul><h1 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h1><p>协同开发最核心的问题其实就是合并，如何合理的合并，优雅的合并，是每个团队需要考虑的问题。Merge 和 Rebase 作为 Git 中主要的命令，其实各有各的优点，两个一起用也是很常见的。根据自身团队及项目情况，选择合适的方式才是最好的。最后，祝大家合并代码一切顺利~</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识vue（下）</title>
      <link href="/2021/07/17/%E5%88%9D%E8%AF%86vue%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2021/07/17/%E5%88%9D%E8%AF%86vue%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>一对一的映射关系</p><p><code>vue</code>中的路由: <strong>路径与组件之间的映射关系</strong></p><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p><strong>S</strong>ingle <strong>P</strong>age <strong>A</strong>pplication,单页面应用(SPA): 所有功能在 <strong>一个html页面 上实现</strong></p><table><thead><tr><th>开发分类</th><th>实现方式</th><th>页面性能</th><th>开发效率</th><th>用户体验</th><th>学习成本</th><th>首屏加载</th><th>SEO</th></tr></thead><tbody><tr><td>单页</td><td>一个html页面</td><td>按需更新,性能高</td><td>高</td><td>非常好</td><td>高</td><td>慢</td><td>差</td></tr><tr><td>多页</td><td>多个html页面</td><td>整页更新,性能低</td><td>中等</td><td>一般</td><td>中等</td><td>快</td><td>优</td></tr></tbody></table><p>优点:按需更新性能高，开发效率高，用户体验好</p><p>缺点:学习成本，首屏加载慢，不利于<code>SEO</code></p><p>应用场景:系统类网站 &#x2F; 内部网站 &#x2F; 文档类网站 &#x2F;移动端站点</p><p><code>vue</code>中的路由插件<code>vuerouter</code></p><p>作用:<strong>修改访问</strong>地址栏路径时,<strong>切换显示</strong>匹配的组件</p><h2 id="VueRouter的基本使用步骤"><a href="#VueRouter的基本使用步骤" class="headerlink" title="VueRouter的基本使用步骤:"></a>VueRouter的基本使用步骤:</h2><p>1.下载</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8e080d199494cc889cc085705800540~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=471&h=56&s=4240&e=png&b=252526" alt="image-20230831202839981.png"></p><p>2.引入</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/120cbb08cfe8490180f2040ce48c9d50~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1019&h=88&s=8542&e=png&a=1&b=252526" alt="image-20230831202858913.png"></p><p>3.安装注册</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/386ffcbb985148dabc30342cac9f6160~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1019&h=87&s=6304&e=png&a=1&b=252526" alt="image-20230831202910254.png"></p><p>4.创建路由对象</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a64884398daf4a228b68ee16070e9971~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1019&h=88&s=9228&e=png&a=1&b=252526" alt="image-20230831202922922.png"></p><p>5.注入,将路由对象注入到new Vue实例中,建立关联</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffcba9a5f3fe4829ba30961d5d6dcff8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=208&s=17845&e=png&a=1&b=252526" alt="image-20230831202931311.png"></p><h3 id="两个核心步骤"><a href="#两个核心步骤" class="headerlink" title="两个核心步骤"></a>两个核心步骤</h3><ol><li>创建需要的组件(views)目录,配置路由规则</li><li>封装抽离路由模块,好处:拆分模块:利于维护</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ 表示 src 的绝对路径</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Find</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Find&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">My</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/My&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Friend</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/Friend&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个路由对象</span></span><br><span class="line"><span class="comment">// 传入配置对象,配置路由规则</span></span><br><span class="line"><span class="comment">// 路由配置规则: 路径和组件之间的一一对应的映射关系</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="comment">// 路由规则是多条,所以 routers 是复数形式</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">  <span class="comment">// 一个对象对应一条规则</span></span><br><span class="line">  <span class="comment">//  path 用户访问的地址</span></span><br><span class="line">  <span class="comment">//  components 用户访问对应地址其对应要展示的组件内容</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/find&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Find</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/my&#x27;</span>, <span class="attr">component</span>: <span class="title class_">My</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/friend&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Friend</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><ol start="2"><li>配置导航,配置路由出口(路径匹配的组件显示的位置)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;footer_wrap&quot;&gt;</span><br><span class="line">      &lt;a href=&quot;#/find&quot;&gt;发现音乐&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;#/my&quot;&gt;我的音乐&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;#/friend&quot;&gt;朋友&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;</span><br><span class="line">      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h2><p>页面组件 - views文件夹  &#x3D;&gt; 配合路由，页面展示</p><p>复用组件 - components文件夹  &#x3D;&gt;  封装复用</p><h2 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h2><p>导航高亮</p><p>vue-router 提供了一个全局组件 router-link (取代 a 标签)</p><p>① 能跳转，配置 to 属性指定路径(必须) 。本质还是 a 标签 ，使用to 无需 #</p><p>#为锚点实现在当前页面跳转无需刷新页面</p><p>② 能高亮，默认就会提供高亮类名，可以直接设置高亮样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;footer_wrap&quot;&gt;</span><br><span class="line">      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;</span><br><span class="line">      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>当前选中的router-link 的两个类名</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd138c240c44b76bf98e1a4c7ccc028~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1695&h=256&s=114804&e=png&a=1&b=f9f8f8" alt="image-20230831213601560.png"></p><p>① router-link-active 模糊匹配 (用的多)</p><p>to&#x3D;”&#x2F;my” 可以匹配  &#x2F;my   &#x2F;my&#x2F;a   &#x2F;my&#x2F;b  ….</p><p>② router-link-exact-active 精确匹配</p><p>to&#x3D;”&#x2F;my” 仅可以匹配  &#x2F;my</p><h3 id="router-link-的类名定制"><a href="#router-link-的类名定制" class="headerlink" title="router-link 的类名定制"></a>router-link 的类名定制</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4aa21cb56b24d1390390dd45305005c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=734&h=248&s=28558&e=png&a=1&b=252526" alt="image.png"></p><h2 id="声明式导航-—跳转传参"><a href="#声明式导航-—跳转传参" class="headerlink" title="声明式导航 —跳转传参"></a>声明式导航 —跳转传参</h2><ol><li>查询参数传参</li></ol><p>① 语法格式如下</p><p>to&#x3D;”&#x2F;path?参数名&#x3D;值”</p><p>② 对应页面组件接收传递过来的值</p><p>$route.query.参数名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;search-box&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">      &lt;button&gt;搜索一下&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;hot-link&quot;&gt;</span><br><span class="line">      热门搜索：</span><br><span class="line">      &lt;!-- query 传参:查询字符串传参 --&gt;</span><br><span class="line">      &lt;!--1.传递:  路径?参数名1 = 参数值1 &amp; 参数名2 = 参数值2 --&gt;</span><br><span class="line">      &lt;!--2.去对应的目标组件中接收参数 $route.query.参数名 --&gt;</span><br><span class="line">      &lt;router-link to=&quot;/search?keywords=今天下大雨了&quot;&gt;今天下大雨了&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;/search?keywords=小白,如何月薪过万?&quot;&gt;小白,如何月薪过万&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="动态路由传参"><a href="#动态路由传参" class="headerlink" title="动态路由传参"></a>动态路由传参</h2><p>①去 router&#x2F;index.js 文件下配置动态路由</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/660cfe363f754ed996c2da0ceeb82b8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=653&h=363&s=20813&e=png&a=1&b=252526" alt="image.png"></p><p>用户点击访问的路径后面添加上 <code>:参数名</code> 就是动态路由的参数</p><p>② 配置导航链接</p><p>传递: to&#x3D;”&#x2F;path&#x2F;参数值”</p><p>③ 对应页面组件接收传递过来的值</p><p>接收 : <code>$route.params.参数名</code></p><h2 id="动态路由参数可选符"><a href="#动态路由参数可选符" class="headerlink" title="动态路由参数可选符"></a>动态路由参数可选符</h2><p>? 表示可选参数,传不传参数都可以匹配到这条路由规则</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01cd71ad87c443d1a0fd326e7506a4d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1073&h=328&s=37653&e=png&a=1&b=252526" alt="image.png"></p><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>**问题：**网页打开， url 默认是 &#x2F; 路径，未匹配到组件时，会出现空白</p><p><strong>语法：</strong> { path: 匹配路径, redirect: 重定向到的路径 },</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27;&#125;,</span><br><span class="line">    &#123; path: &#x27;/home&#x27;, component: Home &#125;,</span><br><span class="line">    &#123; path: &#x27;/search&#x27;, component: Search &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p><h3 id="为什么要使用路由懒加载"><a href="#为什么要使用路由懒加载" class="headerlink" title="为什么要使用路由懒加载?"></a>为什么要使用路由懒加载?</h3><p>为给客户更好的客户体验，首屏组件加载速度更快一些，解决白屏问题。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// import Home from &#x27;@/views/Home.vue&#x27;</span><br><span class="line">// 替换成：() =&gt; import(&#x27;@/views/Home.vue&#x27;) 直接作为component选项</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    name: &#x27;Home&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;@/views/Home.vue&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    name: &#x27;About&#x27;,</span><br><span class="line">    component: () =&gt; import(&#x27;@/views/About.vue&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>每个路由的<code>component</code>选项使用了<code>import()</code>函数，它会返回一个 Promise，用于异步加载对应的路由组件。这样，在初始加载页面时，只会下载首页所需的<code>Home.vue</code>组件，而不会加载其他路由组件。当用户访问 About 页面时，才会异步加载并渲染<code>About.vue</code>组件</p><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>编程式导航:使用js代码来实现跳转</p><p>语法:</p><h3 id="①-path-路径跳转-简易方便"><a href="#①-path-路径跳转-简易方便" class="headerlink" title="① path 路径跳转 (简易方便)"></a>① <code>path</code> 路径跳转 (简易方便)</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a159e3192484ca9bdb257e9e175618a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=636&h=248&s=21253&e=png&a=1&b=252526" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;search-box&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">      &lt;button @click=&quot;goSearch&quot;&gt;搜索一下&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;hot-link&quot;&gt;</span><br><span class="line">      热门搜索：</span><br><span class="line">      &lt;router-link to=&quot;/search&quot;&gt;今天早餐你喝胡辣汤了吗?&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;/search&quot;&gt;小白如何月薪过万?&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;FindMusic&#x27;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    goSearch() &#123;</span><br><span class="line">      this.$router.push(&#x27;/search&#x27;) //简单写法</span><br><span class="line">      // this.$router.push(&#123; path: &#x27;/search&#x27;&#125;) //完整写法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="path路径跳转传参"><a href="#path路径跳转传参" class="headerlink" title="path路径跳转传参"></a>path路径跳转传参</h4><ol><li>query传参</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b0bad873ffc414284e9b3a7bc9f6510~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1089&h=370&s=50697&e=png&a=1&b=252526" alt="image.png"><br>2.  动态路由传参</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc5b6f52085247f2bb117dc9812ebaac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=724&h=209&s=27849&e=png&a=1&b=252526" alt="image.png"></p><h3 id="②-name-命名路由跳转-适合-path-路径长的场景"><a href="#②-name-命名路由跳转-适合-path-路径长的场景" class="headerlink" title="② name 命名路由跳转 (适合 path 路径长的场景)"></a>② name 命名路由跳转 (适合 path 路径长的场景)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;logo-box&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;search-box&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">      &lt;button @click=&quot;goSearch&quot;&gt;搜索一下&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;hot-link&quot;&gt;</span><br><span class="line">      热门搜索：</span><br><span class="line">      &lt;router-link to=&quot;/search&quot;&gt;今天早餐你喝胡辣汤了吗?&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;/search&quot;&gt;小白如何月薪过万?&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;FindMusic&#x27;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">     goSearch() &#123;</span><br><span class="line">    // path 路径跳转</span><br><span class="line">    //   this.$router.push(&#x27;/search&#x27;) //简单写法</span><br><span class="line">    //   // this.$router.push(&#123; path: &#x27;/search&#x27;&#125;) //完整写法</span><br><span class="line"></span><br><span class="line">    // name 属性跳转</span><br><span class="line">    // 语法: this.$router.push( &#123;name : &#x27;路由名&#x27;&#125; )</span><br><span class="line">    this.$router.push( &#123;name : &#x27;search&#x27;&#125; )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="name属性跳转传参"><a href="#name属性跳转传参" class="headerlink" title="name属性跳转传参"></a>name属性跳转传参</h4><ol><li>query传参</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3704fdf883424eb5a57ba536bdd0da31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1090&h=329&s=35991&e=png&a=1&b=252526" alt="image.png"></p><ol start="2"><li>动态路由传参<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e61721b49184d6da7f1ac5f116fa81b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=723&h=288&s=25701&e=png&a=1&b=252526" alt="image.png"></li></ol><p>导航方式和传参方式有点多,贴一张思维导图便于理解和查找</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0296cf6d1d4a469fa2077450673b7320~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3544&h=2246&s=677956&e=png&b=fffdfd" alt="路由导航.png"></p><h2 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h2><p><keep-alive> 是 Vue 的内置组件，当它<strong>包裹动态组件时</strong>，会缓存不活动的组件实例，而不是销毁它们。<keep-alive> 是一个抽象组件，它自身不会渲染成一个 <code>DOM</code> 元素，也不会出现在父组件链中</p><p>此外， <keep-alive> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部 &#x2F; 全局注册</p><p>优点：</p><p>在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染 <code>DOM</code>，减少加载时间及性能消耗，提高用户体验性</p><p><keep-alive>的三个属性：</p><ol><li><p><code>include</code>：组件名数组，只有匹配的组件会被缓存</p></li><li><p><code>exclude</code>：组件名数组，任何匹配的组件都不会被缓存，二者都可以用逗号分隔的字符串、正则表达式或一个数组来表示</p></li><li><p><code>max</code>：数字，最多可以缓存多少组件实例</p></li></ol><p><code>include</code>和<code>exclude</code>只会设置其中一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 逗号分隔字符串 --&gt;</span><br><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 v-bind) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 v-bind) --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :max=&quot;10&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><keep-alive>的使用会触发两个生命周期函数</p><p><code>activated</code>：当组件被激活（使用）的时候触发（进入这个页面的时候触发）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">  console.log(&#x27;activated 激活 → 进入页面&#x27;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>deactivated</code>：当组件不被使用的时候触发（离开这个页面的时候触发）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deactivated() &#123;</span><br><span class="line">  console.log(&#x27;deactivated 失活 → 离开页面&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件缓存后就不会执行组件的 <code>created</code>、<code>mounted</code>、<code>destroyed</code> 等钩子了。所以其提供了 <code>activated</code> (组件激活)和 <code>deactivated</code> (组件失活)钩子，帮我们实现业务需求</p><h2 id="导航守卫（路由守卫）"><a href="#导航守卫（路由守卫）" class="headerlink" title="导航守卫（路由守卫）"></a>导航守卫（路由守卫）</h2><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的</p><p>路由守卫有三种：</p><p>全局前置守卫： <code>beforeEach</code>、全局后置钩子：<code>afterEach</code></p><p>所谓全局是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数</p><p>独享守卫： <code>beforeEnter</code>、 <code>beforeLeave</code><br>组件内守卫：<code>beforeRouteEnter</code>、 <code>beforeRouteUpdate</code>、 <code>beforeRouteLeave</code><br>全局前置守卫</p><p>使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const router = createRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // 返回 false 以取消导航</span><br><span class="line">  return false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 <code>resolve</code> 完之前一直处于等待中</p><p>守卫有三个参数：</p><p><code>to</code> 往哪里去， 到哪去的路由信息对象<br><code>from</code> 从哪里来， 从哪来的路由信息对象<br><code>next()</code>是否放行（可选）<br>如果<code>next()</code>调用，就是放行<br><code>next(路径)</code> 拦截到某个路径页面<br>可以返回的值如下:</p><p><code>false</code>: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址<br>一个路由地址：通过一个路由地址跳转到一个不同的地址，就像你调用 <code>router.push()</code> 一样，你可以设置诸如 <code>replace: true</code> 或 <code>name: &#39;home&#39;</code> 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 <code>from</code> 一样<br>如果遇到了意料之外的情况，可能会抛出一个 <code>Error</code>。这会取消导航并且调用 <code>router.onError()</code> 注册过的回调</p><p>如果什么都没有，<code>undefined</code> 或返回 <code>true</code>，则导航是有效的，并调用下一个导航守卫</p><p>全局后置钩子</p><p>全局后置钩子和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  sendToAnalytics(to.fullPath)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用</p><p>独享守卫</p><p>单路由独享守卫，独享守卫只有前置没有后置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &#x27;/users/:id&#x27;,</span><br><span class="line">    component: UserDetails,</span><br><span class="line">    beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">      // reject the navigation</span><br><span class="line">      return false</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>组件内守卫</p><p>你可以为路由组件添加以下配置：</p><p><code>beforeRouteEnter</code><br><code>beforeRouteUpdate</code><br><code>beforeRouteLeave</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const UserDetails = &#123;</span><br><span class="line">  template: ...,</span><br><span class="line">  beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被验证前调用</span><br><span class="line">    // 不能获取组件实例 `this` ！</span><br><span class="line">    // 因为当守卫执行时，组件实例还没被创建！</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">    // 在导航离开渲染该组件的对应路由时调用</span><br><span class="line">    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>Vuex</code> 是一个专门为 <code>Vue.js</code> 应用程序开发的状态管理模式。**(可以理解为状态就是数据)**它通过提供一个集中存储管理应用的所有组件的状态，并提供了一些操作和方法来修改和访问这些状态。通过使用 <code>Vuex</code>，可以更好地组织和管理 <code>Vue.js</code> 应用程序的状态，提高代码的可维护性和可测试性。它适用于中大型的应用程序或需要共享状态的多个组件之间进行通信的场景</p><p>一般情况下，只有多个组件均需要共享的数据 ，才有必要存储在 <code>Vuex</code> 中，对于某个组件中的私有数据，依旧存储在组件自身的 <code>data</code> 中</p><blockquote><p>使用 <code>Vuex</code> 优势主要有三点：<br>共同维护一份数据，数据集中化管理<br>响应式变化<br>操作简洁 (<code>Vuex</code> 提供了一些辅助函数)</p></blockquote><h3 id="Vuex使用"><a href="#Vuex使用" class="headerlink" title="Vuex使用"></a><code>Vuex</code>使用</h3><p>安装 <code>Vuex</code> 插件，初始化一个空仓库</p><p>安装 <code>vuex</code>，与 <code>vue-router</code> 类似，<code>vuex</code> 是一个独立存在的插件，如果脚手架初始化没有选 <code>vuex</code>，就需要额外安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuex@3</span><br></pre></td></tr></table></figure><p>新建 store&#x2F;index.js 专门存放 <code>vuex</code>。为了维护项目目录的整洁，在 <code>src</code> 目录下新建一个 <code>store</code> 目录，其下放置一个<code>index.js</code>文件 (和 router&#x2F;index.js 类似)</p><p>创建仓库 store&#x2F;index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 导入 vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">// 导入 vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line">// vuex 也是 vue 的插件, 需要 use 一下, 进行插件的安装初始化</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">// 创建仓库 store</span><br><span class="line">const store = new Vuex.Store()</span><br><span class="line">// 导出仓库</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure><p>在 main.js 中导入挂载到 Vue 实例上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  store</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>此刻起, 就成功创建了一个 空仓库!!</p><h3 id="Vuex-的核心概念"><a href="#Vuex-的核心概念" class="headerlink" title="Vuex 的核心概念"></a><code>Vuex</code> 的核心概念</h3><p><code>Vuex</code> 的核心概念包括：**<code>State</code><strong>（状态）、</strong><code>Mutation</code><strong>（变化）、</strong><code>Action</code><strong>（动作）、</strong><code>Getter</code><strong>（获取器）、</strong><code>Module</code>**（模块）</p><h4 id="States"><a href="#States" class="headerlink" title="States"></a><code>States</code></h4><p><code>State</code>（状态）: <code>Vuex</code> 使用单一状态树来管理应用的状态，也就是一个包含了所有数据的对象。通过将数据放在一个集中的地方，可以方便地跟踪和管理应用的数据</p><p><code>State</code> 提供唯一的公共数据源，所有共享的数据都要统一放到 <code>Store</code> 中的 <code>State</code> 中存储。在 <code>state</code> 对象中可以添加我们要共享的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建仓库 store</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // state 状态, 即数据, 类似于 vue 组件中的 data,</span><br><span class="line">  // 区别在于 data 是组件自己的数据, 而 state 中的数据整个 vue 项目的组件都能访问到</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>访问<code>State</code>数据</p><p>通过仓库直接访问</p><p>组件中可以使用 <code>this.$store</code> 获取到 <code>vuex</code> 中的 <code>store</code> 对象实例，可通过 <code>state</code> 属性属性获取 <code>count</code>：</p><pre><code>state的数据---&#123;&#123; $store.state.count &#125;&#125;</code></pre><p>在非组件内,先引入当前的 <code>store</code> 对象,使用 <code>store.state.count(属性名)</code>来获取</p><p>或者将 <code>state</code> 属性定义在计算属性中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 把 state 中数据，定义在组件内的计算属性中</span><br><span class="line">computed: &#123;</span><br><span class="line">  count () &#123;</span><br><span class="line">    return this.$store.state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用计算属性简化了代码，但是每次都需要依次提供计算属性，比较繁琐，<code>vuex</code> 辅助函数帮我们解决了这个问题</p><h5 id="辅助函数-mapState"><a href="#辅助函数-mapState" class="headerlink" title="辅助函数 mapState"></a>辅助函数 <code>mapState</code></h5><p><code>mapState</code> 是辅助函数，帮助我们把 <code>store</code> 中的数据映射到组件的计算属性中<br>使用步骤：</p><p>导入 <code>mapState</code> ( <code>mapState</code> 是 <code>vuex</code> 中的一个函数 )</p><pre><code>import &#123; mapState &#125; from &#39;vuex&#39;</code></pre><p>采用数组形式引入 <code>state</code> 属性</p><pre><code>mapState([&#39;count&#39;]) </code></pre><p>利用展开运算符将导出的状态映射给计算属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([&#x27;count&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><p><code>Mutation</code>（变化）: 变化是修改数据的唯一方式。它类似于事件，每个变化都有一个类型和一个处理函数。通过提交一个变化，可以触发状态的修改</p><p>事实上确实是可以直接修改 <code>store</code> 中的数据，无需通过 <code>mutation</code>，并且不会报错。但直接修改可能会造成很严重的后果， <code>Vue</code> 官方也不希望我们这么做，如若担心自己可能无意间直接修改了 <code>store</code> 中的数据，可以开启严格模式 <code>strict: true</code> ，让 <code>Vue</code> 来监督我们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const store  = new Vuex.Store(&#123;</span><br><span class="line">  strict: true</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 定义mutations</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>访问<code>mutations</code></p><p><code>state</code> 数据的修改只能通过 mutations，并且 mutations 必须是同步的。mutations 是一个对象，对象中存放修改 state 的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  // 第一个参数是当前 store 的 state 属性,也就是 vuex 里面存储的数据</span><br><span class="line">  // payload载荷 运输参数，调用mutaiions时，可以传递参数，传递载荷</span><br><span class="line">  addCount (state) &#123;</span><br><span class="line">    state.count += 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中提交 mutations（其实就是触发对应函数的执行）</p><pre><code>this.$store.commit(&#39;addCount&#39;)</code></pre><p>带参数的mutations</p><p>提交 mutations 是可以传递参数的 this.$store.commit(states, 参数)</p><p>提供 mutations 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  ...</span><br><span class="line">  addCount (state, count) &#123;</span><br><span class="line">    state.count = count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>提交 mutations</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle ( ) &#123;</span><br><span class="line">  this.$store.commit(&#x27;addCount&#x27;, 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用触发函数执行的时候只能传递两个参数,1. states, 2.携带的数据 ,如需传递多条数据使用数组或是对象进行传递<code>this.$store.commit(&#39;addCount&#39;,&#123;***&#125;/[***])</code><br>辅助函数</p><h5 id="辅助函数mapMutations"><a href="#辅助函数mapMutations" class="headerlink" title="辅助函数mapMutations"></a>辅助函数mapMutations</h5><p>mapMutations 和 mapState 很像</p><p>mutations 里面存的是一个函数,它是把位于 mutations 中的方法在methods中展开</p><p>而 mapState 是数据,映射的数据是在计算属性computed中展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import  &#123; mapMutations &#125; from &#x27;vuex&#x27;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([&#x27;addCount&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，就可以直接通过 this.addCount()调用</p><pre><code>&lt;button @click=&quot;addCount&quot;&gt;+1&lt;/button&gt;</code></pre><p>mutations 中不能写异步代码，如果有异步的 ajax 请求，应该放置在 actions 中</p><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>Action（动作）: action 类似于变化，它可以包含任意异步操作。它们是通过提交一个 action 来触发的，然后在 actions 中可以执行异步操作并通过提交变化来修改状态</p><p>state 用于存放数据，mutations 用于同步更新数据（便于监测数据的变化，更新视图等，方便于调试工具查看变化），actions 则负责进行异步操作</p><p>定义actions</p><p>actions 的函数第一个参数是 context (上下文对象，参数名可修改)，可以理解为是一个简化版本的 store 对象，它里面也有commit方法,触发mutation的执行,第二个参数同 mutations 一样，只能接受一个参数，多个参数用对象包裹后传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  setAsyncCount (context, num) &#123;</span><br><span class="line">    // 一秒后, 给一个数, 去修改 num</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      context.commit(&#x27;changeCount&#x27;, num)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>调用 actions 来进行异步修改 count</p><p>语法: this.$store.dispatch(参数一:context ,参数二:要进行修改的参数)</p><p>commit调用的是mutation函数</p><p>dispatch调用的是actions函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setAsyncCount () &#123;</span><br><span class="line">  this.$store.dispatch(&#x27;setAsyncCount&#x27;, 666)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="辅助函数mapActions"><a href="#辅助函数mapActions" class="headerlink" title="辅助函数mapActions"></a>辅助函数mapActions</h5><p>actions 也有辅助函数（mapActions），可以将 actions 导入到组件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions &#125; from &#x27;vuex&#x27;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([&#x27;setAsyncCount&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过 this.方法就可以调用</p><pre><code>&lt;button @click=&quot;setAsyncCount(200)&quot;&gt;异步修改数值&lt;/button&gt;</code></pre><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p>Getter（获取器）: 获取器用于从状态中派生出新的状态。它可以将现有的状态进行计算和转换，并提供一个类似于计算属性的方式来访问这些派生状态</p><p>例如，state 中定义了 list 数组，而在组件中，需要显示所有大于5的数据，正常的方式，是需要 list 在组件中进行再一步的处理，但是 getters 可以帮助我们实现它：</p><p>…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">&#125;</span><br><span class="line">getters: &#123;</span><br><span class="line">  // getters函数的第一个参数是 state</span><br><span class="line">  // 必须要有返回值</span><br><span class="line">   filterList:  state =&gt;  state.list.filter(item =&gt; item &gt; 5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始方式$store</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Getter 辅助函数与上文类似，均是用于用于获取对象属性值的函数，简化了代码</span><br><span class="line"></span><br><span class="line">mapGetters</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([&#x27;filterList&#x27;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><pre><code>&#123;&#123; filterList &#125;&#125;</code></pre><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>概念</p><p>Module（模块）: 模块可以将整个状态树分割成更小的模块，每个模块都有自己的状态(state)、变化(mutation)、动作(action) 和获取器(getter)。这样可以将复杂的应用程序拆分成可维护和可测试的模块。通过模块化的方式，可以更好地组织和维护大型的状态管理</p><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿，于是就有了 Vuex 的模块化。模块化是使用 Vuex 的一种重要的模式，开发中基本上都是基于模块化思想来开发</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识vue（中）</title>
      <link href="/2021/07/10/%E5%88%9D%E8%AF%86vue%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2021/07/10/%E5%88%9D%E8%AF%86vue%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="工程化开发"><a href="#工程化开发" class="headerlink" title="工程化开发"></a>工程化开发</h1><h2 id="什么是前端工程化"><a href="#什么是前端工程化" class="headerlink" title="什么是前端工程化?"></a>什么是前端工程化?</h2><p>前端工程化开发是一种通过使用各种工具、技术和最佳实践来提高前端开发效率、质量和可维护性的方法。它旨在将前端开发从简单的代码编写转变为一个更系统化、自动化的过程，以便团队能够更高效地协作、管理代码库、处理依赖关系，并确保最终交付的前端应用具有稳定性和性能优势。</p><p>前端工程化的核心概念和实践包括：</p><ol><li><strong>模块化开发：</strong> 将前端代码拆分为小模块，每个模块专注于特定的功能。这有助于代码的可维护性、复用性和团队协作。</li><li><strong>包管理器：</strong> 使用工具如npm或Yarn来管理项目所需的外部依赖库。这可以确保项目依赖的版本一致性，并简化依赖的安装过程。</li><li><strong>构建工具：</strong> 使用工具如Webpack、Parcel或Rollup来自动化构建过程，包括合并、压缩、转换代码以及处理资源文件，从而减少手动操作，优化性能并生成生产就绪的代码。</li><li><strong>代码分割和懒加载：</strong> 通过将代码拆分成更小的块，并在需要时按需加载，从而减少初始加载时间，提高页面性能。</li><li><strong>自动化测试：</strong> 实施单元测试、集成测试和端到端测试，以确保代码在不同层面上的质量和稳定性。</li><li><strong>版本控制：</strong> 使用工具如Git来管理代码版本，使团队能够协同开发、解决冲突，并轻松地回退到之前的版本。</li><li><strong>代码风格检查和格式化：</strong> 使用工具如ESLint和Prettier来强制执行一致的代码风格和格式，以提高代码的可读性和一致性。</li><li><strong>持续集成和持续交付：</strong> 集成自动化构建、测试和部署流程，使团队能够频繁地交付新功能和修复，从而减少发布时的风险。</li></ol><h2 id="为什么使用前端工程化开发-好处"><a href="#为什么使用前端工程化开发-好处" class="headerlink" title="为什么使用前端工程化开发?(好处)"></a>为什么使用前端工程化开发?(好处)</h2><ol><li><strong>提高开发效率：</strong> 自动化流程减少了重复性的手动操作，开发人员可以更专注于实际的编码和创意工作。</li><li><strong>代码质量提升：</strong> 使用自动化测试和代码检查工具，可以降低bug率，改善代码质量。</li><li><strong>可维护性增强：</strong> 模块化和标准化的开发实践使得代码更易于理解、扩展和维护。</li><li><strong>团队协作改进：</strong> 通过版本控制、自动化构建和持续集成，团队成员能够更好地协同工作，减少冲突和交付问题。</li><li><strong>性能优化：</strong> 使用构建工具和代码优化策略，可以减小代码体积，提高页面加载速度和性能。</li><li><strong>降低风险：</strong> 自动化测试和持续交付减少了发布时的人为错误，使发布更加可靠。</li></ol><h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><p>1.全局安装: <code>npm i @vue/cli  -g</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f96f358dc01a438282644f9b1478f28c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1261&h=522&s=479733&e=png&b=0d0d0d" alt="全局安装vue脚手架.png"></p><p>2.查看vue版本 : <code>vue --version (vue -V)</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a823a46fed6c4fd3ad6e0386c27e3017~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=546&h=108&s=34233&e=png&b=0d0d0d" alt="image-20230827114503341.png"></p><p>3.创建项目框架: <code>vue create  vue-demo</code> (项目名,不可以使用中文)</p><p>创建完项目之后会出现一个选择vue版本的界面,使用上下键选择对应的vue版本</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07ec58276d74407b9464cc801d035e8e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=656&h=227&s=62935&e=png&b=0c0c0c" alt="image-20230827114930819.png"></p><p>这个时候我们的脚手架就已经创建好了</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3ca19cf4ede43368a9367162d81b3bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1416&h=630&s=245663&e=png&b=0d0d0d" alt="image-20230827114737142.png"></p><p>cd 进入创建项目的根目录, 打开</p><p>4.启动项目: <code>npm run serve</code>使用yarn的用 <code>yarn serve</code>运行项目</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ebf73d3f6a040df9378a51bacb18388~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=308&s=95459&e=png&b=0c0c0c" alt="image-20230827115626536.png"></p><p>打开这个本地地址就可以看见你的一个最初始的vue项目了</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d4944d3df14627ad1865780bd40270~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1073&h=629&s=118802&e=png&b=fdfdfd" alt="image-20230827134037443.png"></p><p>脚手架目录文件</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abb9f4288884e9386461cd5d6a62e91~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=328&s=155750&e=png&b=242424" alt="image-20230827140553976.png"></p><p>当我们使用<code>npm run serve</code>或是 <code>yarn serve</code> 把项目跑起来的时候就会去找 <code>package.json</code> 里面的命令</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3651b784c991439597d19aa55aab2f0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=602&h=170&s=66540&e=png&b=23272d" alt="image-20230827141523390.png"></p><p><code>vue-cli-service serve</code>是脚手架的命令,是对 <code>webpack</code> 的封装</p><p>等同于<code>webpack serve</code>,把项目跑起来之后就会去找项目的入口,也就是 <code>main.js</code></p><p>来看一看 <code>mian.js</code> 里面的代码究竟干了什么?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 vue 构造函数(去node_modules里去找到 vue 的包,相当于之前在html文件里引入 vue 的核心包)</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 2. 引入 app.vue 的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// 3. 设置生产环境的提示,不提示</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 4. 创建 vue 的实例对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">     <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),<span class="comment">//根据 app 组件来创建 DOM 元素并挂载到指定的容器中</span></span><br><span class="line">    <span class="comment">// render 函数的完整写法:</span></span><br><span class="line">    <span class="comment">//render(createElement) &#123;</span></span><br><span class="line">       <span class="comment">// return createElement(App)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// render 是一个函数 而调用 render 函数的时候传入的 参数createElement又是一个函数,用来创建对象,它在里面调用的时候会基于传过来的 app 模板来创建,最后返回</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// .$mount(&#x27;#app&#x27;) 完全等同于之前的 el:&#x27;#app&#x27;,设置挂载点,也就是 vue 管理的范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终渲染到 #app 盒子里面的内容完全取决于 app 模版里面的内容</span></span><br></pre></td></tr></table></figure><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>组件(Component): 一个页面可以拆分成<strong>一个一个的组件</strong>,每一个组件都有着自己独立的<strong>结构</strong>, <strong>样式</strong>, <strong>行为</strong></p><p>优点:便于维护,利于复用,提高开发效率</p><p>组件分类: 普通组件,根组件</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/821a776f545d43658f415824dd3d5636~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=579&h=514&s=79953&e=png&b=4c9fc3" alt="image-20230827151110761.png"></p><p>组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e874bbf76246ac81d177b65f6b3eb6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1406&h=544&s=16239&e=png&a=1&b=fefefe" alt="components.png"></p><h3 id="组件的组成和基本使用"><a href="#组件的组成和基本使用" class="headerlink" title="组件的组成和基本使用"></a>组件的组成和基本使用</h3><p>组成:</p><p><code>template</code>结构(有且只能有一个根元素)</p><p><code>script</code>js逻辑</p><p><code>style</code>样式(支持less,sass,需要装包)</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffc3b3ab3bdb4a37964d27feb3e55018~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1786&h=494&s=207781&e=png&b=fefefe" alt="image-20230827174118047.png"><br>基本使用流程:</p><p>①创建  <code>vue</code>  组件</p><blockquote><p><code>vue</code> 组件的命名遵循大驼峰命名法(如:<code>GoodsHeader</code>),或是烤串命名法(如:<code>goods-header</code>)</p></blockquote><blockquote><p>tips:</p><p>当创建完 <code>vue</code> 组件可直接到需要使用的组件内使用,无需导入和注册,方便快捷</p></blockquote><p>②导入到需要使用的组件内</p><p>③注册组件</p><p>组件注册的两种方式:</p><p>局部注册: 只能在注册的组件内使用</p><p>全局注册:  所有组件内都能使用</p><p>④使用组件</p><p>直接当成普通的 <code>html</code> 标签使用</p><blockquote><p>组件命名的时候使用大驼峰命名法,在使用的时候推荐使用烤串命名法</p></blockquote><h4 id="局部组件注册"><a href="#局部组件注册" class="headerlink" title="局部组件注册"></a>局部组件注册</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;p&gt;我是根组件&lt;/p&gt;</span><br><span class="line">  &lt;!-- 使用组件 --&gt;</span><br><span class="line">  &lt;dl-header&gt;&lt;/dl-header&gt;</span><br><span class="line">  &lt;dl-main&gt;&lt;/dl-main&gt;</span><br><span class="line">  &lt;dl-footer&gt;&lt;/dl-footer&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">//1.  导入组件</span><br><span class="line">import DlHeader from &#x27;./components/dl-header.vue&#x27;</span><br><span class="line">import DlMain from &#x27;./components/dl-main.vue&#x27;</span><br><span class="line">import DlFooter from &#x27;./components/dl-footer.vue&#x27;</span><br><span class="line">// 注册组件</span><br><span class="line">// 组件中的 js 默认导出一个对象,就是组件对象</span><br><span class="line">export default (&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    DlHeader,</span><br><span class="line">    DlMain,</span><br><span class="line">    DlFooter,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">background-color: purple;</span><br><span class="line">width: 600px;</span><br><span class="line">height: 500px;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: space-between;</span><br><span class="line">flex-direction: column;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">p &#123;</span><br><span class="line">color: #fff;</span><br><span class="line">font-size: 20px;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baa46a8dba24ac6a7eaa2c98ebffff7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=644&s=18996&e=png&b=800080" alt="image-20230827162758205.png"></p><h4 id="全局组件注册"><a href="#全局组件注册" class="headerlink" title="全局组件注册"></a>全局组件注册</h4><p>使用:  在 <code>main.js</code> 内导入，并全局注册 <code>Vue.component(组件名, 组件对象)</code></p><p>一般都用局部注册，如果发现确实是通用组件，再定义到全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main.js 中导入需要全局注册的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProjectButton</span> <span class="keyword">from</span> <span class="string">&#x27;./components/search&#x27;</span></span><br><span class="line"><span class="comment">// 调用 Vue.component 进行全局注册</span></span><br><span class="line"><span class="comment">// Vue.component(&#x27;组件名&#x27;, 组件对象)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;search&#x27;</span>, search)</span><br></pre></td></tr></table></figure><h3 id="组件的样式冲突"><a href="#组件的样式冲突" class="headerlink" title="组件的样式冲突"></a>组件的样式冲突</h3><p><strong>默认情况</strong>：写在组件中的样式会 全局生效 → 因此很容易造成多个组件之间的样式冲突问题。</p><ol><li>全局样式: 默认组件中的样式会作用到全局</li><li>局部样式: 可以给组件加上 <code>scoped</code> 属性, 可以让样式只作用于当前组件</li></ol><p><strong><code>scoped</code>原理</strong></p><ol><li>当前组件内标签都被添加 <code>data-v-hash</code>值 的属性</li><li><code>css</code> 选择器都被添加 <code>[data-v-hash值]</code> 的属性选择器</li></ol><p>最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977d6f22443a4e7b9502126508cefcdd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=609&h=196&s=43224&e=png&a=1&b=f8f7f7" alt="image-20230827172419839.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8ec87cdd5084651afc892e33e47c851~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=600&h=202&s=32653&e=png&a=1&b=fffefe" alt="image-20230827172441501.png"></p><h3 id="组件中的-data"><a href="#组件中的-data" class="headerlink" title="组件中的 data"></a>组件中的 data</h3><p>一个组件的 data 选项必须是一个函数</p><p>保证每个组件实例,维护独立的一份数据对象</p><h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><p>组件通讯就是指组件与组件之间的数据传递</p><p>组件关系分类</p><p>父子关系</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c252e60802e148158447fe1a3902c7c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=400&h=189&s=10184&e=png&b=fdfdfd" alt="image-20230827175236435.png"></p><p>非父子关系</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f64094c0fca406ab154a552879552e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=378&h=252&s=22068&e=png&b=ffffff" alt="image-20230827175247512.png"></p><p>父子通讯流程图</p><ol><li>父组件通过 <code>props</code> 将数据传递给子组件</li><li>子组件利用 <code>$emit</code> 通知父组件修改更新</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaee7f1577d447a49c2c36bd0ca7fca7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=305&s=53096&e=png&b=8063a0" alt="image-20230827175544075.png"></p><p><strong>父向子传值</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0046009860bc4059a93dd6d90fc90b80~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1337&h=717&s=264477&e=png&b=24282f" alt="父向子传值.png"></p><p><strong>子向父传值</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7abb0bbc3002463c8d7d9b8c0d2e5572~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1728&h=885&s=337132&e=png&b=23272e" alt="image-20230827221950163.png"></p><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><p><code>prop</code> 是子组件用来接受父组件传递过来的数据的一个自定义属性。</p><p>父组件的数据需要通过 <code>props</code> 把数据传给子组件，子组件需要显式地用 <code>props</code> 选项声明 “<code>prop</code>“,说白了就是接收到父组件传递过来的数据</p><p><code>props</code>是单向数据流，只能从父组件传递到子组件，子组件不能直接修改<code>props</code>中的值,这也是为什么不能在子组件中直接修改数据需要通过触发事件的方式与父组件进行沟通,让父组件去修改数据</p><h3 id="prop校验"><a href="#prop校验" class="headerlink" title="prop校验"></a>prop校验</h3><p>语法: ①类型校验  ②非空校验  ③默认值  ④自定义校验</p><p>在<code>Vue</code>中，<code>prop</code>是一种用于父组件向子组件传递数据的机制。通过在子组件中定义<code>props</code>属性，可以声明需要从父组件接收的数据，并在子组件中使用这些数据</p><p>特点：</p><ul><li>可以传递<strong>任意数量</strong>的 prop</li><li>可以传递<strong>任意类型</strong>的 prop</li></ul><p>当接收到的数据不符合要求的时候就需要进行类型校验,并给予开发者提示</p><p>基础写法的类型校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  校验的属性名: 类型 <span class="comment">// Number String Boolean ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整写法的类型校验</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  校验的属性名: &#123;</span><br><span class="line">    <span class="attr">type</span>: 类型,  <span class="comment">// Number String Boolean ...</span></span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>, <span class="comment">// 是否必填</span></span><br><span class="line">    <span class="attr">default</span>: 默认值, <span class="comment">// 默认值</span></span><br><span class="line">    validator (value) &#123;</span><br><span class="line">      <span class="comment">// 自定义校验逻辑，通过返回true，不通过返回false并报错</span></span><br><span class="line">      <span class="keyword">return</span> 是否通过校验</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组</p><h2 id="深入v-model-原理"><a href="#深入v-model-原理" class="headerlink" title="深入v-model 原理"></a>深入v-model 原理</h2><p>v-model 本质是一个语法糖,在内部实现了两个功能:<br>1. 使用 v-bind 绑定了 value 属性,获取 value 值<br>2. 使用 v-on 监听 input 事件 , 一旦 input 框的内容改变就把最新的值赋给 msg2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;msg1&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;msg2&quot; @input=&quot;handleInput&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;msg2&quot; @input=&quot;msg2=$event.target.value&quot;/&gt;</span><br><span class="line">      //在事件处理函数中第一个参数默认就是事件对象, 在模版中可以使用 $event 表示事件处理函数的第一个参数, $ event 就是 vue 在模版中定义的一个变量,写法更加的简单</span><br><span class="line">    //v-model 本质是一个语法糖,在内部实现了两个功能:</span><br><span class="line">    1. 使用 v-bind 绑定了 value 属性,获取 value 值</span><br><span class="line">    2. 使用 v-on 监听 input 事件 , 一旦 input 框的内容改变就把最新的值赋给 msg2</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg1: &#x27;&#x27;,</span><br><span class="line">      msg2: &#x27;&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleInput(e) &#123;</span><br><span class="line">      this.msg2 = e.target.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h2><p>作用:用于实现父组件和子组件之间的数据的双向绑定,简化代码,在本质上和 v-model一样是一个语法糖</p><p>在原来不使用.sync语法的时候,在子组件内是无法直接修改父组件传递过来的数据的,只能向</p><p>事件的名字可以自己随意的定义,不必在必须规定为 value 类型<br>本质: <code>: 属性名</code>和<code>update:属性名</code>的合写形式</p><p>当我们在属性名,后面使用了.sync 修饰符 它在后面做了两件事:</p><p>1 .把数据传递给子组件</p><p>2 .同时监听了 update:××× (后面的×××就是传给子组件的属性名)的事件</p><p>要实现父子组件之间的双向数据绑定就直接在属性名的后面使用 .sync 修饰符号就可以了</p><p>封装弹框类组件案例</p><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;openDialog&quot;&gt;退出按钮&lt;/button&gt;</span><br><span class="line">    &lt;BaseDialog :isShow.sync=&quot;isShow&quot;&gt;&lt;/BaseDialog&gt; 优雅</span><br><span class="line">    &lt;BaseDialog :isShow=&quot;isShow&quot; @changeShow=&quot;(isShow=false)&quot;&gt;&lt;/BaseDialog&gt; 传统</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import BaseDialog from &#x27;./components/BaseDialog.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    openDialog() &#123;</span><br><span class="line">      this.isShow = true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    BaseDialog,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 使用接收到的数据给盒子设置默认的隐藏状态为 false --&gt;</span><br><span class="line">  &lt;div v-if=&quot;isShow&quot; class=&quot;base-dialog-wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;base-dialog&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;title&quot;&gt;</span><br><span class="line">        &lt;h3&gt;温馨提示：&lt;/h3&gt;</span><br><span class="line">        &lt;button @click=&quot;$emit(&#x27;update:changeShow&#x27;,false)&quot; class=&quot;close&quot;&gt;x&lt;/button&gt;  传统</span><br><span class="line">       &lt;button @click=&quot;$emit(&#x27;changeShow&#x27;,false)&quot; class=&quot;close&quot;&gt;x&lt;/button&gt;  优雅</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;p&gt;你确认要退出本系统么？&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">        &lt;button&gt;确认&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;$emit(&#x27;update:changeShow&#x27;,false)&quot;&gt;取消&lt;/button&gt; 传统</span><br><span class="line">        &lt;button @click=&quot;$emit(&#x27;changeShow&#x27;,false)&quot;&gt;取消&lt;/button&gt;  优雅</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 使用 props 接收父组件传递过来的数据</span><br><span class="line">  props: &#123;</span><br><span class="line">    isShow: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      required: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="ref和$refs"></a>ref和$refs</h2><p><code>ref</code> 被用来给DOM元素或子组件注册引用信息。引用信息会根据父组件的 <code>\$refs</code> 对象进行注册。</p><p>如果在普通的DOM元素上使用，引用信息就是DOM元素;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;textInput&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>使用<code>this.$refs.textInput</code>来访问这个元素,并操作它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">textInput</span>.<span class="title function_">focus</span>(); <span class="comment">// 将焦点设置到文本输入框</span></span><br></pre></td></tr></table></figure><p>如果用在子组件上，引用信息就是组件实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">ref</span>=<span class="string">&quot;myComponentRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>想要获取到元素使用<code>this.$refs.name</code>来获取元素如果是普通的<code>dom</code>元素则获取到的是<code>dom</code>元素</p><p>如果是子组件则获取到的是<strong>组件实例，可以使用组件的所有方法</strong></p><h2 id="vue的异步更新-nextTick"><a href="#vue的异步更新-nextTick" class="headerlink" title="vue的异步更新,$nextTick"></a>vue的异步更新,$nextTick</h2><p><code>$nextTick</code> 是一个用于在 DOM 更新队列被清空之后执行回调的方法。</p><p>Vue的更新是异步的，当你修改数据后，Vue并不会立即进行DOM更新，而是会将这些更新操作放入一个队列中，然后在下一个事件循环周期中进行更新，这样可以有效地减少DOM操作的次数，提高性能。</p><p>有时候，你可能需要在DOM更新完成后执行一些操作，比如在某个元素渲染完成后获取其几何信息，或者在更新后执行一些动画效果。这时就可以使用 <code>$nextTick</code> 方法来确保你的回调在DOM更新之后被调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p ref=&quot;message&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;updateMessage&quot;&gt;更新信息&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello, Vue!&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage() &#123;</span><br><span class="line">      this.message = &#x27;我已经不是原来的我了,我变心了&#x27;;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        // 在DOM更新后执行这里的回调</span><br><span class="line">        console.log(this.$refs.message.textContent); // 输出：我已经不是原来的我了,我变心了</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>自定义指令:大白话就是自己定义的指令,封装<code>dom</code>操作,扩展额外功能,使用时就像使用 <code>v-for</code> 这些指令一样直接在标签上就可以使用</p><p>封装一个自动获取焦点的 自定义指令 <code>v-focus</code></p><p>和组件注册的方式一样有<strong>全局注册</strong>和<strong>局部注册</strong></p><p>全局注册</p><p>在 <code>main.js</code> 注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.directive(指令名,配置对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inserted() 是指令的钩子函数,被指令绑定了的元素会在被插入到 DOM 树上时自动执行</span></span><br><span class="line"><span class="comment">//执行时会将绑定该指令的元素传过来,然后就可以对其进行操作了</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="attr">directives</span>: &#123;</span><br><span class="line">     <span class="comment">// 指令名: 配置对象</span></span><br><span class="line">     <span class="attr">focus</span>: &#123;</span><br><span class="line">       <span class="comment">// inserted 函数: 当使用指令的元素被插入到 DOM 中时触发, 自动执行</span></span><br><span class="line">    <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;我被插入到 DOM 啦!&#x27;, el)</span></span><br><span class="line">       el.<span class="title function_">focus</span>() <span class="comment">// DOM 操作 封装到此处了!</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册完成了之后就可以在想要使用该组件的地方使用 <code>v-focus</code> 即可</p><h3 id="自定义指令的值"><a href="#自定义指令的值" class="headerlink" title="自定义指令的值"></a>自定义指令的值</h3><p>依据传入不同的值显示不同的颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 v-color=&quot;color1&quot;&gt;指令的值1测试&lt;/h1&gt;</span><br><span class="line">    &lt;h1 v-color=&quot;color2&quot;&gt;指令的值2测试&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      color1: &#x27;gray&#x27;,</span><br><span class="line">      color2: &#x27;orange&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 参数1: el 指令绑定的元素对象</span></span><br><span class="line">    <span class="comment">// 参数2: binding 指令绑定的参数, 对象</span></span><br><span class="line">    <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// update 钩子: 指令的值发生变化时自动触发</span></span><br><span class="line">    <span class="comment">// 参数1: el 指令绑定的元素对象</span></span><br><span class="line">    <span class="comment">// 参数2: binding 指令绑定的参数, 对象</span></span><br><span class="line">    <span class="title function_">update</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>插槽:让组件内部的结构支持<strong>自定义</strong>,说白了就是我在这里挖个坑,你可以往这里面填东西,至于要填什么东西你自己来决定</p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>插槽的基本使用语法:</p><p>1.在组件内在需要定制结构的部分使用<slot></slot>标签占位置</p><p>2.在使用组件时,在标签内部,传入需要定制的结构替换 slot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyDialog&gt;</span><br><span class="line">     &lt;img src=&quot;https://s1.aigei.com/src/img/gif/a2/a23e1935964d4465bcfe1f17625fc8a6.gif?imageMogr2/auto-orient/thumbnail/!240x225r/gravity/Center/crop/240x225/quality/85/&amp;e=1735488000&amp;token=P7S2Xpzfz11vAkASLTkfHN7Fw-oOZBecqeJaxypL:jwsq63qB0OOfuMOr-KKnCye7ln4=&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;/MyDialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-header&quot;&gt;</span><br><span class="line">      &lt;h3&gt;友情提示&lt;/h3&gt;</span><br><span class="line">      &lt;span class=&quot;close&quot;&gt;✖️&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;dialog-content&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">      &lt;button&gt;取消&lt;/button&gt;</span><br><span class="line">      &lt;button&gt;确认&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>通过插槽完成了内容的定制,传入什么就显示什么.如果不传,则会是空白</p><p>设置默认值也非常的简单,只需要在slot标签内写入你想要设置的默认值即可,如果没有就会显示默认值的内容,如果传了内容,默认值就会失效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-header&quot;&gt;</span><br><span class="line">      &lt;h3&gt;友情提示&lt;/h3&gt;</span><br><span class="line">      &lt;span class=&quot;close&quot;&gt;✖️&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;dialog-content&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;h1&gt;这里是默认值&lt;/h1&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">      &lt;button&gt;取消&lt;/button&gt;</span><br><span class="line">      &lt;button&gt;确认&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>具名插槽顾名思义,就是有名字的插槽</p><p>一个组件内有多处结构需要从外部传入标签进行定制</p><p>使用步骤:</p><ol><li><p>给每个 slot 标签设置 name 属性</p></li><li><p>使用插槽时通过 template 标签结合 v-slot 指令来设置需要分发的插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyDialog&gt;</span><br><span class="line">      &lt;!-- 如果不指定插槽名字, 默认名字叫 default --&gt;</span><br><span class="line">      &lt;!-- &lt;p&gt;嘿嘿嘿&lt;/p&gt; --&gt;</span><br><span class="line">      &lt;template #header&gt;</span><br><span class="line">        &lt;h3&gt;温馨提示!&lt;/h3&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;template #content&gt;</span><br><span class="line">        &lt;p&gt;恭喜您中了 500 万美金的大奖,请到缅北 妙瓦底  &lt;a href=&quot;https://www.alipay.com&quot;&gt;kk园区&lt;/a&gt; 领取!&lt;/p&gt;</span><br><span class="line">       </span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- v-slot: 可以简写成 # --&gt;</span><br><span class="line">      &lt;template #footer&gt;</span><br><span class="line">        &lt;button&gt;&lt;a href=&quot;www.aliyun.com&quot;&gt;点击前往&lt;/a&gt;&lt;/button&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/MyDialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-header&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;span class=&quot;close&quot;&gt;✖️&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;dialog-content&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽其实就时可以带数据的插槽,即可以携带参数的插槽</p><p>简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。</p><p><strong>基本使用步骤:</strong></p><ol><li>在子组件的 slot 标签上使用自定义属性,携带数据传递给父组件</li><li>父组件使用 template 配合 v-slot 获取传递过来的数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;td&gt;</span><br><span class="line">  &lt;!-- </span><br><span class="line">    注意: :item 相当于往插槽上加了一个自定义属性, 最终以对象包裹属性的形式传递过去</span><br><span class="line">    例如: 此处传过去的数据格式 &#123; item: item, index: index &#125;</span><br><span class="line">     --&gt;</span><br><span class="line">  &lt;slot :index=&quot;index&quot; :item=&quot;item&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyTable :data=&quot;list&quot;&gt;</span><br><span class="line">  &lt;!-- </span><br><span class="line">    定义形参接收</span><br><span class="line">    插槽默认名字叫 default</span><br><span class="line">    可以简写为 #default=&quot;变量名&quot;,这个变量名保存的是由子组件传递过来的数据,</span><br><span class="line">    //一般通常情况下直接在这里对传递过来的对象进行解构操作,方便后面的使用</span><br><span class="line">    如果不用 # 也可以不指定名字, 直接写为 v-slot=&quot;变量名&quot;</span><br><span class="line">   --&gt;</span><br><span class="line">    完整写法: v-slot:default = &#x27;变量名&#x27;</span><br><span class="line">    简写形式: #default = &#x27;变量名&#x27;</span><br><span class="line">    不指定插槽名,接收数据:v-solt = &#x27;变量名&#x27; // 对象解构 v-solt = &#123; 属性名1,属性名2 , ...&#125;</span><br><span class="line">  &lt;template v-slot=&quot;scope&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;del(scope.item.id)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/MyTable&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始vue（上）</title>
      <link href="/2021/06/25/%E5%88%9D%E5%A7%8Bvue%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2021/06/25/%E5%88%9D%E5%A7%8Bvue%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Vue"><a href="#初识Vue" class="headerlink" title="初识Vue"></a>初识Vue</h1><h2 id="vue是什么"><a href="#vue是什么" class="headerlink" title="vue是什么?"></a>vue是什么?</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad091e0b60e045e0965367e36319bf02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=626&e=png&b=ffffff" alt="image-20230820110850516.png"></p><p>在vue官网的简介是:用于 <em>构建用户界面</em>1 的 <em>渐进式</em>2 <em>框架</em>3</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9272c423b36642e6849d3ecf9bec16ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=361&e=png&b=67ceb6" alt="image-20230820111223712.png"></p><p>构建用户界面:基于数据动态渲染出用户看到的页面</p><p>渐进式:循序渐进逐步学习,使用</p><p>框架:一套完整的项目解决方案,可以极大地提高开发的效率</p><p>既然那么好用,让我们来盘一盘这个vue</p><h2 id="vue中的MVVM"><a href="#vue中的MVVM" class="headerlink" title="vue中的MVVM"></a>vue中的MVVM</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba6453bf13845ef93d2d658976d6bfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=808&h=398&e=png&b=ffffff" alt="image-20230826201735352.png"></p><ul><li>M指的是model（模型），对应data中的数据。</li><li>V指的是view(视图),一个展示用户界面的模板，可以简单的理解为HTML标签页面。</li><li>MV指的是ViewModel(视图模层)，它是Vue的实例对象，一个连接view和model的桥梁，负责把model对象封装成可以显示和接受输入的界面对象。</li></ul><h2 id="vue的基本使用"><a href="#vue的基本使用" class="headerlink" title="vue的基本使用"></a>vue的基本使用</h2><p><strong>核心步骤（4步）：</strong></p><ol><li><p>准备容器</p></li><li><p>引包（官网） — 开发版本&#x2F;生产版本</p></li><li><p>创建Vue实例 new Vue()</p></li><li><p>指定配置项，渲染数据</p><ol><li>el:指定挂载点</li><li>data提供数据</li></ol></li></ol><h3 id="创建vue实例-初始化渲染"><a href="#创建vue实例-初始化渲染" class="headerlink" title="创建vue实例,初始化渲染"></a>创建vue实例,初始化渲染</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/218216304d814e85a8d38ac1552f77b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=190&e=png&b=fdfdfd" alt="image-20230820115249589.png"></p><p>来到vue2的官网看看该如何使用</p><p><a href="https://v2.cn.vuejs.org/">vue2</a></p><p>依照上面的顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//准备容器 (Vue所管理的范围)</span><br><span class="line">       &lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">       //引包 (开发版本包 / 生产版本包) 官网</span><br><span class="line">       &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">       &lt;script&gt;</span><br><span class="line">           //创建实例</span><br><span class="line">           const box = new Vue(&#123;</span><br><span class="line">             // 制定 vue 托管的区域</span><br><span class="line">               el: &#x27;#app&#x27;,</span><br><span class="line">               // 渲染的数据</span><br><span class="line">               data: &#123;</span><br><span class="line">                   message: &#x27;Hello Vue!&#x27;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure><p>这样的话data里面的数据就被渲染到页面上了</p><blockquote><p>只能渲染由vue托管的区域,没有托管的区域不会动态渲染</p></blockquote><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><p>数据绑定最常见的形式就是使用<code>Mustache</code>语法 (小胡子语法) 的文本插值</p><p>作用:利用表达式进行插值,渲染到页面上</p><p>语法:<code>&#123;&#123; 表达式&#125;&#125;</code></p><pre><code>&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</code></pre><p>所谓的<strong>表达式</strong>,就是一段可以被求值的代码,js引擎会将其计算并最终得出一个结果</p><pre><code>money + 100money - 100money * 10money / 10 price &gt;= 100 ? &#39;真贵&#39;:&#39;还行&#39;obj.namearr[0]fn()obj.fn()</code></pre><p>以上这些都是表达式</p><p>可以简单的直接渲染数据,既然支持表达式那么也可以往里面写一些复杂的计算表达式,就像这样</p><pre><code>&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;h3&gt;&lt;p&gt;&#123;&#123;nickName.toUpperCase()&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;age >= 18 ? '成年':'未成年'&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;obj.name&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;fn()&#125;&#125;&lt;/p&gt;</code></pre><p>当msg里面的数据发生变化的时候,对应页上的信息也会进行动态的渲染和更新</p><p>通过使用 <code>v-once 指令</code>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><pre><code>&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</code></pre><blockquote><p><strong>注意</strong>:</p><p>数据必须存在</p><p>插值表达式，只能支持表达式，而非语句: if ,for…</p><p>不能够在标签中使用</p></blockquote><h3 id="响应式特性"><a href="#响应式特性" class="headerlink" title="响应式特性"></a>响应式特性</h3><p>当data里面的数据发生变化的时候,对应页上的信息也会进行动态的渲染和更新</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e11c5cfbf35464dac88acd41017c28d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=817&h=253&e=png&b=fefefe" alt="image-20230820124523229.png"></p><p>data中的数据, 最终会被添加到实例上</p><p>① 访问数据： “实例.属性名”</p><p>② 修改数据： “实例.属性名”&#x3D; “值”</p><h2 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h2><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>作用:设置元素的innerHTML</p><p>语法: v-html &#x3D; 表达式</p><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <code>v-html</code> 指令</p><pre><code> &lt;div id=&quot;app&quot;&gt;    &lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt;      &lt;/div&gt;       &lt;script&gt;            const app = new Vue(&#123;         el: &#39;#app&#39;,          data: &#123;                msg: &#39;&lt;h1&gt;燕子,你别走!!!没了你我可怎么活啊!&lt;/h1&gt;&#39;               &#125;           &#125;)       &lt;/script&gt;</code></pre><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfbd41bd21f4435f8bb2bf05b2e3508e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=858&h=314&e=png&b=ffffff" alt="image-20230820130841220.png"></p><p>v-if 底层原理:通过<strong>创建</strong> &#x2F; <strong>删除</strong> dom 元素来实现盒子的显示隐藏,当表达式的值为 true 时就显示,为 false 时就隐藏</p><p>适用于<code>初始状态</code>就决定了显示隐藏的场景</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show 底层原理: 通过设置 <code>display:none</code>,来改变盒子的显示隐藏</p><p>当表达式的值为 true 时就显示,为 false 时就隐藏</p><p>适用于<code>频繁切换</code>显示隐藏的场景</p><h3 id="v-else-v-else-if"><a href="#v-else-v-else-if" class="headerlink" title="v-else ,v-else-if"></a>v-else ,v-else-if</h3><ol><li>作用：辅助v-if进行判断渲染</li><li>语法：v-else v-else-if&#x3D;”表达式”</li><li>需要紧接着v-if使用</li></ol><!----><pre><code>  &lt;div id=&quot;app&quot;&gt;    &lt;p v-if=&quot;gender===0&quot;&gt;性别：♂ 男&lt;/p&gt;    &lt;p v-else&gt;性别：♀ 女&lt;/p&gt;    &lt;hr&gt;    &lt;p v-if=&quot;score&gt;=90&quot;&gt;成绩评定A：奖励电脑一台&lt;/p&gt;    &lt;p v-else-if=&quot;score&gt;=70&quot;&gt;成绩评定B：奖励周末郊游&lt;/p&gt;    &lt;p v-else-if=&quot;score&gt;=60&quot;&gt;成绩评定C：奖励零食礼包&lt;/p&gt;    &lt;p v-else&gt;成绩评定D：惩罚一周不能玩手机&lt;/p&gt;  &lt;/div&gt;​  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    // 目标:    // 1. 根据条件渲染姓名    // 2. 根据成绩来渲染奖励    const app = new Vue(&#123;      el: &#39;#app&#39;,      data: &#123;        gender: 0,        score: 95      &#125;    &#125;)  &lt;/script&gt;</code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/434cbdc984d045da8024bef05c9ba030~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=548&h=153&e=png&b=ffffff" alt="image-20230820134529444.png"></p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>作用: 注册事件 &#x3D; 添加监听 + 处理逻辑</p><p>语法:</p><ol start="0"><li><em>v-on :事件名 &#x3D; “内联语句”</em></li><li>v-on: 事件名 &#x3D; “methods中的函数名”</li></ol><p>简写形式</p><p><code>@事件名</code></p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;button @click=&#123;&#123;count--&#125;&#125;&gt;-&lt;/button&gt;            &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt;            &lt;button @click=&#123;&#123;count++&#125;&#125;&gt;+&lt;/button&gt;        &lt;/div&gt;        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;        &lt;script&gt;            // 目标: 点击 - 让数字减一, 点击 + 让数字加一            const app = new Vue(&#123;                el: &#39;#app&#39;,                data: &#123;                    count: 100                &#125;            &#125;)        &lt;/script&gt;</code></pre><p>methods 中存放函数</p><p>只要是定义在 methods 中的函数,最终都会放到实例对象上,所以内部的 this 指向实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;isShow = !isShow&quot;&gt;切换显示隐藏&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;change&quot;&gt;切换显示隐藏&lt;/button&gt;</span><br><span class="line">    &lt;h1 v-show=&quot;isShow&quot;&gt;我又出来了&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    /**</span><br><span class="line">     * 目标:</span><br><span class="line">     *    点击切换 h1 标签显示隐藏</span><br><span class="line">     */</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        isShow: true</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        change() &#123;</span><br><span class="line">          this.isShow = !this.isShow</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="v-on调用传参"><a href="#v-on调用传参" class="headerlink" title="v-on调用传参"></a>v-on调用传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">                &lt;h3&gt;小黑自动售货机&lt;/h3&gt;</span><br><span class="line">                &lt;button @click=&quot;buy(5)&quot;&gt;可乐5元&lt;/button&gt;</span><br><span class="line">                &lt;button @click=&quot;buy(10)&quot;&gt;咖啡10元&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;p&gt;银行卡余额：&#123;&#123; money &#125;&#125;元&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">​</span><br><span class="line">        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            /**</span><br><span class="line">             * 目标:</span><br><span class="line">             *  点击不同按钮, 银行卡余额减少对应的金额</span><br><span class="line">             */</span><br><span class="line">            const app = new Vue(&#123;</span><br><span class="line">                el: &#x27;#app&#x27;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    money: 100</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    buy(price) &#123;</span><br><span class="line">                        this.money -= price</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>作用:动态设置标签的属性值</p><p>语法: v-bind:属性名&#x3D;”表达式”</p><p>简写:</p><p>:属性名 &#x3D; “表达式”</p><p>以下是一些常见的HTML标签属性</p><p>1.<strong>src 属性（用于图像、音频、视频等）：</strong></p><pre><code>&lt;img :src=&quot;imageSource&quot;&gt;&lt;audio :src=&quot;audioSource&quot;&gt;&lt;/audio&gt;&lt;video :src=&quot;videoSource&quot;&gt;&lt;/video&gt;</code></pre><p>2.<strong>href 属性（用于链接）：</strong></p><pre><code>&lt;a :href=&quot;externalLink&quot;&gt;Visit Website&lt;/a&gt;</code></pre><p>3.<strong>title 和 alt 属性（用于提示信息）：</strong></p><pre><code>&lt;img :title=&quot;imageTitle&quot; :alt=&quot;imageAlt&quot; src=&quot;imageSource&quot;&gt;</code></pre><p>4.<strong>disabled 属性（用于禁用表单元素）：</strong></p><pre><code>&lt;button :disabled=&quot;isDisabled&quot;&gt;Submit&lt;/button&gt;</code></pre><p>5.<strong>placeholder 属性（用于表单元素的占位符文本）：</strong></p><pre><code>&lt;input :placeholder=&quot;inputPlaceholder&quot;&gt;</code></pre><p>6.<strong>value 属性（用于表单元素的值）：</strong></p><pre><code>&lt;input :value=&quot;inputValue&quot;&gt;</code></pre><p>7.<strong>readonly 属性（用于设置表单元素为只读）：</strong></p><pre><code>&lt;input :readonly=&quot;isReadOnly&quot;&gt;</code></pre><p>8.<strong>checked 属性（用于复选框和单选按钮）：</strong></p><pre><code>&lt;input type=&quot;checkbox&quot; :checked=&quot;isChecked&quot;&gt;&lt;input type=&quot;radio&quot; :checked=&quot;isSelected&quot;&gt;</code></pre><p>9.<strong>data-属性（用于存储自定义数据）：</strong></p><pre><code>&lt;div :data-custom-value=&quot;customData&quot;&gt;&lt;/div&gt;</code></pre><!----><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img :src=&quot;imgUrl&quot; :title=&quot;msg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    /**</span><br><span class="line">     * 目标:</span><br><span class="line">     *  使用 v-bind 指令动态绑定标签属性</span><br><span class="line">     */</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        imgUrl: &#x27;./imgs/10-02.png&#x27;,</span><br><span class="line">        msg: &#x27;hello&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br></pre></td></tr></table></figure><h4 id="v-bind-操作-class-类名"><a href="#v-bind-操作-class-类名" class="headerlink" title="v-bind 操作 class 类名"></a>v-bind 操作 class 类名</h4><p>语法 :class &#x3D;”{对象}”</p><p><strong>设置对象使用布尔值控制是否使用这个类名,比较常用动态设置类名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;box&quot; :class=&quot;&#123;pink:flag&#125;&quot;&gt;键盘敲烂,月薪过万&lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">       &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">       &lt;script&gt;</span><br><span class="line">           const app = new Vue(&#123;</span><br><span class="line">               el: &#x27;#app&#x27;,</span><br><span class="line">               data: &#123;</span><br><span class="line">                   flag: true</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>语法 :class&#x3D;”[数组]”</p><p><strong>使用数组一次性设置多个类名,或删除多个类名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;box&quot; :class=&quot;[&#x27;pink&#x27;,&#x27;big&#x27;]&quot;&gt;今天天气真不挫!&lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">       &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">       &lt;script&gt;</span><br><span class="line">           const app = new Vue(&#123;</span><br><span class="line">               el: &#x27;#app&#x27;,</span><br><span class="line">               data: &#123;</span><br><span class="line">                   flag: true</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="v-bind-操作-style-类名"><a href="#v-bind-操作-style-类名" class="headerlink" title="v-bind 操作 style 类名"></a>v-bind 操作 style 类名</h4><p>语法 :style &#x3D; “{ 样式属性 }”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot; :style=&quot;&#123;width: &#x27;50rem&#x27;,height: &#x27;18.75rem&#x27;&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">​</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>作用:基于数组循环,多次整个渲染整个元素</p><p>语法: v-for &#x3D;”(item,index) in list”</p><ul><li>item 是数组中的每一项</li><li>index 是每一项对应的索引，不需要可以省略</li><li>list是被遍历的数组</li></ul><!----><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    const app = new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">           booksList: [</span><br><span class="line">           &#123; id: 1, name: &#x27;《红楼梦》&#x27;, author: &#x27;曹雪芹&#x27; &#125;,</span><br><span class="line">           &#123; id: 2, name: &#x27;《西游记》&#x27;, author: &#x27;吴承恩&#x27; &#125;,</span><br><span class="line">           &#123; id: 3, name: &#x27;《水浒传》&#x27;, author: &#x27;施耐庵&#x27; &#125;,</span><br><span class="line">           &#123; id: 4, name: &#x27;《三国演义》&#x27;, author: &#x27;罗贯中&#x27; &#125;</span><br><span class="line">            ]</span><br><span class="line">             &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">            del(id) &#123;</span><br><span class="line">            this.booksList =this.booksList.filter(item=&gt; &#123;</span><br><span class="line">                          this.booksList = item.id !== id</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>key属性</p><p>当使用 <code>v-for</code> 来渲染一个列表时，Vue 需要一个唯一的 <code>key</code> 值来追踪每个循环项。这有助于 Vue 在更新列表时识别出哪些项被添加、删除或移动了，从而提供更快速的 DOM 更新以及更精准的变化追踪。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">      &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="v-modal"><a href="#v-modal" class="headerlink" title="v-modal"></a>v-modal</h3><p>作用:双向数据绑定,快速获取或设置表单元素内容</p><p><strong>什么是双向数据绑定?</strong></p><p>Vue是一个MV VM框架， 即数据双向绑定， 即当数据发生变化的时候， 视图也就发生变化， 当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue的精髓之处了。</p><p>v-model 会根据控件类型自动选取正确的方法来更新元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    账户：&lt;input type=&quot;text&quot;&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot;&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;重置&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        username: &#x27;&#x27;,</span><br><span class="line">        password: &#x27;&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd9d53860f474e4791788c28b32827de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1077&h=288&e=png&b=fdfdfd" alt="1681913125738.png"></p><h4 id="复选框的数据绑定"><a href="#复选框的数据绑定" class="headerlink" title="复选框的数据绑定"></a>复选框的数据绑定</h4><p>复选框如果是一个为逻辑值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Vue 测试实例&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;单个复选框：&lt;/p&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">​</span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checked : false,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果是多个则绑定到同一个数组,会把选中的选项里面的 value 值,添加到数组中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Vue 测试实例&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;多个复选框：&lt;/p&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; id=&quot;runoob&quot; value=&quot;苹果&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;runoob&quot;&gt;苹果&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; id=&quot;google&quot; value=&quot;香蕉&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;google&quot;&gt;香蕉&lt;/label&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; id=&quot;taobao&quot; value=&quot;荔枝&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;taobao&quot;&gt;荔枝&lt;/label&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;span&gt;选择的值为: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">​</span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="单选框的数据绑定"><a href="#单选框的数据绑定" class="headerlink" title="单选框的数据绑定"></a>单选框的数据绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;!-- 1.name:  给单选框加上 name 属性可以分组，同一组互相会互斥 --&gt;</span><br><span class="line">  &lt;!-- 2.value: 给单选框加上 value 属性，用于提交给后台的数据 --&gt;</span><br><span class="line">  性别: </span><br><span class="line">    &lt;input v-model=&quot;gender&quot; name=&quot;gender&quot; value=&quot;male&quot; type=&quot;radio&quot;&gt;男</span><br><span class="line">    &lt;input v-model=&quot;gender&quot; name=&quot;gender&quot; value=&quot;female&quot; type=&quot;radio&quot;&gt;女</span><br><span class="line">    &lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      gender: &#x27;female&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="下拉菜单的数据绑定"><a href="#下拉菜单的数据绑定" class="headerlink" title="下拉菜单的数据绑定"></a><strong>下拉菜单的数据绑定</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;!-- 1. option 需要设置 value 值，提交给后台 --&gt;</span><br><span class="line">  &lt;!-- 2. select 的 value 值，关联了选中的 option 的 value 值 --&gt;</span><br><span class="line">  &lt;!-- 注意: 下拉选择框使用 v-model 要绑定在 select 上 --&gt;</span><br><span class="line">  所在城市:</span><br><span class="line">  &lt;select v-model=&quot;city&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.7.14/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      city: &#x27;beijing&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="指令修饰符"><a href="#指令修饰符" class="headerlink" title="指令修饰符"></a>指令修饰符</h3><h4 id="1-v-model修饰符"><a href="#1-v-model修饰符" class="headerlink" title="1.v-model修饰符"></a>1.v-model修饰符</h4><p>.lazy</p><p>在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：</p><pre><code>&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt;</code></pre><p>.number</p><p>如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：</p><pre><code>&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</code></pre><p>.trim</p><p>如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</p><pre><code>&lt;input v-model.trim=&quot;msg&quot;&gt;</code></pre><h4 id="2-按键修饰符"><a href="#2-按键修饰符" class="headerlink" title="2.按键修饰符"></a>2.按键修饰符</h4><p>Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：</p><pre><code>&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</code></pre><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p><pre><code>&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;</code></pre><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获 “删除” 和 “退格” 键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>系统修饰键：</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><p>鼠标按钮修饰符:</p><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><h4 id="3-事件修饰符"><a href="#3-事件修饰符" class="headerlink" title="3.事件修饰符"></a>3.事件修饰符</h4><p>Vue 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。</p><p>Vue 通过由点 <strong>.</strong> 表示的指令后缀来调用修饰符。</p><ul><li><code>.stop</code> - 阻止冒泡</li><li><code>.prevent</code> - 阻止默认事件</li><li><code>.capture</code> - 阻止捕获</li><li><code>.self</code> - 只监听触发该元素的事件</li><li><code>.once</code> - 只触发一次</li><li><code>.left</code> - 左键事件</li><li><code>.right</code> - 右键事件</li><li><code>.middle</code> - 中间滚轮事件</li></ul><!----><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class="line">&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class="line">&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class="line">&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line">​</span><br><span class="line">&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;</span><br><span class="line">&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h2><p>计算属性，字如其名，首先它是<strong>属性</strong>，其次有计算的“功能”</p><p>说的官方一点：<strong>计算属性就是当其依赖属性的值发生变化时，这个属性的值会自动变化，与之相关的DOM部分也会同步自动更新。</strong></p><p>在computed配置项中添加我们的计算属性，在属性里面写我们的逻辑代码</p><blockquote><p>注意：计算属性其实是属性，在页面上使用只需要用属性值，不要带（），不然就变成方法了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;小黑的礼物清单&lt;/h3&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;名字&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;数量&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; item.num &#125;&#125;个&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">​</span><br><span class="line">    &lt;!-- 目标：统计求和，求得礼物总数 --&gt;</span><br><span class="line">    &lt;p&gt;礼物总数：&#123;&#123;totalCount&#125;&#125; 个&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        // 现有的数据</span><br><span class="line">        list: [</span><br><span class="line">          &#123; id: 1, name: &#x27;篮球&#x27;, num: 1 &#125;,</span><br><span class="line">          &#123; id: 2, name: &#x27;玩具&#x27;, num: 2 &#125;,</span><br><span class="line">          &#123; id: 3, name: &#x27;铅笔&#x27;, num: 5 &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        totalCount() &#123;</span><br><span class="line">          return this.list.reduce((sum,item)=&gt;sum+item.num,0)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h5 id="计算属性computed和methods的区别"><a href="#计算属性computed和methods的区别" class="headerlink" title="计算属性computed和methods的区别"></a>计算属性<code>computed</code>和<code>methods</code>的区别</h5><p>computed是一个方法,而methods里面也是一个方法,那么他们之间的区别是什么呢?</p><p>我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。</p><p>我们可以通过多次调用,打印出来看看结果有什么不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;小黑的礼物清单🛒&lt;span&gt;?&lt;/span&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;名字&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;数量&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; item.num &#125;&#125;个&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">​</span><br><span class="line">    &lt;p&gt;礼物总数：&#123;&#123; getNum() &#125;&#125; 个&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;礼物总数：&#123;&#123; getNum() &#125;&#125; 个&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;礼物总数：&#123;&#123; getNum() &#125;&#125; 个&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;礼物总数：&#123;&#123; getNum() &#125;&#125; 个&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;礼物总数：&#123;&#123; getNum() &#125;&#125; 个&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        // 现有的数据</span><br><span class="line">        list: [</span><br><span class="line">          &#123; id: 1, name: &#x27;篮球&#x27;, num: 3 &#125;,</span><br><span class="line">          &#123; id: 2, name: &#x27;玩具&#x27;, num: 2 &#125;,</span><br><span class="line">          &#123; id: 3, name: &#x27;铅笔&#x27;, num: 5 &#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        totalCount () &#123;</span><br><span class="line">          console.log(&#x27;我是 computed 里的求和属性&#x27;);</span><br><span class="line">          let total = this.list.reduce((sum, item) =&gt; sum + item.num, 0)</span><br><span class="line">          return total</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        getNum() &#123;</span><br><span class="line">          console.log(&#x27;我是 methods 里的求和属性&#x27;);</span><br><span class="line">          return this.list.reduce((sum, item) =&gt; sum + item.num, 0)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9539c7374c974460b96ccd24a0702176~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=737&h=187&e=png&b=fefdfd" alt="image-20230823114418161.png"></p><p>可以清晰地看到,用methods方法数据每更新一次就会被调用一次,而computed方法只被调用了一次</p><p><strong>优点:计算属性最重要的特性: 带缓存</strong></p><p>在第一次使用了该属性时进行计算,计算完了后他就会把结果存起来,后面有用到会直接在缓存里面把结果取出来</p><p>只在相关响应式依赖发生改变（相关的属性变化）时它们才会重新求值</p><p>这样做的主要目的也是为了提高性能</p><p><strong>计算属性的完整写法</strong></p><p>计算属性都包含有一个get和一个set，<strong>计算属性会默认使用 get函数</strong>,<strong>如果你要使用 set函数，那么你必须要手动写出 set 函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        firstName: &#x27;李&#x27;,</span><br><span class="line">        lastName: &#x27;雷&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        change() &#123;</span><br><span class="line">          this.fullName = &#x27;韩梅梅&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        fullName: &#123;</span><br><span class="line">          // 当访问这个计算属性时, get 函数会自动执行,并将返回值作为计算属性的值</span><br><span class="line">         get() &#123;</span><br><span class="line">          return this.firstName + this.lastName</span><br><span class="line">         &#125;,</span><br><span class="line">        //  当修改这个计算属性时, set 函数会自动执行, 并将修改的新值作为参数传递过来</span><br><span class="line">         set(val) &#123;</span><br><span class="line">          this.firstName = val.substring(0,1)</span><br><span class="line">          this.lastName = val.substring(1)</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器"></a>watch侦听器</h2><p>作用:监视数据变化,<strong>执行业务逻辑</strong>或是<strong>异步操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            const app = new Vue(&#123;</span><br><span class="line">                el: &#x27;#app&#x27;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    words: &#x27;&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                watch: &#123;</span><br><span class="line">                    //要监听什么数据,就以什么数据命名,定义函数</span><br><span class="line">                    // 该函数会在数据变化时自动执行,并携带两个参数</span><br><span class="line">                    // 参数一:新值</span><br><span class="line">                    // 参数二:旧值 ,不常用</span><br><span class="line">                    words(newValue,oldValue) &#123;</span><br><span class="line">                        console.log(value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>完整写法:</p><ul><li><code>deep: true</code> 对复杂类型深度监视</li><li><code>immediate: true</code> 初始化立刻执行一次handler方法</li></ul><!----><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;// watch 完整写法</span><br><span class="line">    数据属性名: &#123;</span><br><span class="line">      deep: true, // 深度监视(针对复杂类型)</span><br><span class="line">      immediate: true, // 是否立刻执行一次handler</span><br><span class="line">      handler (newValue) &#123;</span><br><span class="line">        console.log(newValue)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>一个Vue实例从 <strong>创建</strong> 到 <strong>销毁</strong> 的整个过程</p><p>vue的生命周期分为四个阶段:</p><p>①创建 ②挂载 ③更新 ④销毁</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d172237839fa43a4b09ee968e63e38ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1876&h=410&e=png&b=fefefe" alt="image-20230826115137667.png"></p><p>Vue生命周期过程中，会自动运行一些函数，被称为【生命周期钩子】</p><p>这个时候我们就可以在【特定阶段】运行自己的代码</p><ol><li>实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载，只是一个空壳，无法访问到数据和真实的dom，一般不做操作</li><li>挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据，在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染，在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取</li><li>接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情…</li><li>当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿</li><li>当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom</li><li>当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等</li><li>组件的数据绑定、监听…去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a40afd679d441ebb21989359d70b3cc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1231&h=391&e=png&b=fefefe" alt="image-20230826115225732.png"></p><p>生命周期图示</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee7294109b3f4daa91ad79975b684d44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1325&h=1440&e=png&b=fffbfb" alt="20190725165224557.png"></p><table><thead><tr><th>生命周期钩子</th><th>实例阶段</th><th>说明</th><th>能否获取到data</th><th>能否获取到 methods</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td><td>实例已初始化，但数据观测，watch&#x2F;event 事件回调还未配置</td><td>NO</td><td>NO</td></tr><tr><td>created</td><td>创建后</td><td>已完成如下配置，数据观测 (data observer)，property 和方法的运算，watch&#x2F;event 事件回调</td><td>NO</td><td>OK</td></tr><tr><td>beforeMount</td><td>挂载前</td><td>dom已初始化，但并未挂载和渲染</td><td>OK</td><td>OK</td></tr><tr><td>mounted</td><td>挂载后</td><td>dom已完成挂载和渲染</td><td>OK</td><td>OK</td></tr><tr><td>beforeUpdate</td><td>更新前</td><td>数据已改变，但dom为更新</td><td>OK</td><td>OK</td></tr><tr><td>updated</td><td>更新后</td><td>dom已更新</td><td>OK</td><td>OK</td></tr><tr><td>beforeDestroy</td><td>销毁前</td><td>实例销毁前，实例仍然可用</td><td>OK</td><td>OK</td></tr><tr><td>destroyed</td><td>销毁后</td><td>实例已销毁，所有指令被解绑，事件监听器被移除，子实例都被销毁</td><td>OK</td><td>OK</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html基础入门</title>
      <link href="/2020/07/23/html%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/23/html%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="#%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5">基础认知</a></p><p><a href="#web%E6%A0%87%E5%87%86">web标准</a></p><p><a href="#HTML%E6%A6%82%E5%BF%B5">HTML概念</a></p><p><a href="#HTML%E6%B3%A8%E9%87%8A">HTML注释</a></p><p><a href="#HTML%E6%A0%87%E9%A2%98%E3%80%81%E6%AE%B5%E8%90%BD">HTML标题、段落</a></p><p><a href="#%E6%B0%B4%E5%B9%B3%E7%BA%BF%E6%A0%87%E7%AD%BE">水平线标签</a></p><p><a href="#%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE">图片标签</a></p><h2 id="基础认知"><a href="#基础认知" class="headerlink" title="基础认知"></a>基础认知</h2><p><strong>网页有哪些组成部分?<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ef02488c1104956bf02e114201ceae3~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p>文字、图片、视频、音频、超链接</p><p><strong>我们看到的网页背后的本质是什么？</strong></p><p>前端程序员写的代码</p><p><strong>程序员写的代码是通过什么软件转换成网页的？</strong></p><p>浏览器</p><p><strong>五大浏览器和渲染引擎</strong></p><p>常见的五大浏览器</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02476294868f40bb8c0e405ebd80ce55~tplv-k3u1fbpfcp-zoom-1.image"></p><p> 浏览器：是网页运行、显示的平台，是前端开发的必备利器<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c40ea8710577422ea705b5c86b87f09a~tplv-k3u1fbpfcp-zoom-1.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc7bdeb7e7547b8a96a3c2627dccab1~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>渲染引擎</strong></p><p>渲染引擎（浏览器内核）：浏览器中专门对代码进行解析渲染的部分</p><table><thead><tr><th>浏览器</th><th>内核</th><th></th></tr></thead><tbody><tr><td>IE</td><td>Triden</td><td>IE、猎豹安全、360极速浏览器、百度浏览器</td></tr><tr><td>FireFox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td>Safari</td><td>webkit</td><td>苹果浏览器内核</td></tr><tr><td>Chrome&#x2F;Opera</td><td>Blink</td><td>Weblink分支</td></tr></tbody></table><p>注意点：渲染引擎不同，导致解析相同的代码时的速度、性能、效果也不相同</p><h2 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b901783be8604c019549ee98201eaf31~tplv-k3u1fbpfcp-zoom-1.image"></h2><p>Web标准是一组由W3C（World Wide Web Consortium）制定的技术规范和指南，用于确保网页在不同浏览器和设备上的一致性和互操作性。Web标准的目标是推动Web技术的发展和进步，使开发者能够创建具有良好可访问性、可用性和可维护性的网页。</p><ol><li>HTML标准：HTML是网页的基础语言，W3C发布了HTML规范，定义了HTML的语法、标签和元素的使用方式，确保网页的结构和内容能够被正确解析和渲染。</li><li>CSS标准：CSS用于控制网页的样式和布局，W3C发布了CSS规范，定义了CSS的语法、选择器、属性和值的使用方式，以及样式在网页中的应用规则，确保网页的外观和布局在不同浏览器上保持一致。</li><li>JavaScript标准：JavaScript是用于网页交互和动态效果的脚本语言，ECMAScript是JavaScript的标准规范，由Ecma国际组织维护。该标准定义了JavaScript的语法、数据类型、函数、对象等，确保在不同环境和浏览器中的一致性和互操作性。</li><li>Web API标准：Web API提供了访问浏览器功能和设备功能的接口，例如DOM操作、网络请求、媒体播放、地理位置等。W3C制定了一系列的Web API标准，确保开发者可以在不同浏览器上使用相同的API来实现相似的功能。</li></ol><p>遵循Web标准的好处包括：</p><ul><li>跨浏览器兼容性：遵循Web标准可以使网页在不同浏览器和设备上呈现一致的外观和功能，提供更好的用户体验。</li><li>可访问性：遵循Web标准可以使网页更易于被辅助技术（如屏幕阅读器）解读和访问，提高网站的可访问性，包容更多用户群体。</li><li>可维护性：遵循Web标准可以使代码结构清晰、语义化，易于维护和扩展。</li><li>SEO友好性：遵循Web标准可以提高网页在搜索引擎中的排名，提高搜索引擎优化（SEO）效果。</li></ul><p>通过遵循Web标准，开发者可以构建可靠、可持续和可扩展的Web应用程序，确保网页的质量和性能，并提供更好的用户体验。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/415ea3240547421cb491a2761682c37a~tplv-k3u1fbpfcp-zoom-1.image"></p><p>web标准要求页面实现：结构、表现、行为三层分离</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cde4d38f4c244ffdb53accf8306af7b8~tplv-k3u1fbpfcp-zoom-1.image"></p><p> 结构:HTML(决定了身体,骨架)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a22df398f06d4b56a1774999b575fb35~tplv-k3u1fbpfcp-zoom-1.image"></p><p> 表现:css(决定了色彩样式)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/090150ad43184a659b6d72c415f2e0fa~tplv-k3u1fbpfcp-zoom-1.image"></p><p> 行为:JavaScript(决定了动态交互效果)</p><h2 id="HTML概念"><a href="#HTML概念" class="headerlink" title="HTML概念"></a><strong>HTML概念<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de8eca44f1ab4838a62d4c19fdef99c4~tplv-k3u1fbpfcp-zoom-1.image"></strong></h2><p>HTML(Hyper Text Markup Language)中文译为：超文本标记语言</p><p>它描述了网页的结构和内容，并使用标签（Tag）来定义文本、图像、链接、表格等元素在网页中的展示方式。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0246fad517714cdbac090d060fc7d34e~tplv-k3u1fbpfcp-zoom-1.image"></p><p>网页类似于一篇文章：</p><p>每一页文章内容是有固定的结构的，如：开头、正文、落款等…</p><p>网页中也是存在固定的结构的，如：整体、头部、标题、主体</p><p>网页中的固定结构是要通过特点的HTML标签进行描述的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e347541925c482ba475857775a879c6~tplv-k3u1fbpfcp-zoom-1.image"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  网页的主体内容</span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3899383c3218449ebd33153938e86e82~tplv-k3u1fbpfcp-zoom-1.image"></h3><p>注释的作用：为代码添加的具有解释性、描述性的信息，主要用来帮助开发人员理解代码</p><p>浏览器执行代码时会忽略所有的注释</p><p>快捷键：在VS Code中：<strong>ctrl+&#x2F;</strong></p><p><strong>HTML标签组成、关系</strong></p><p>标签的结构图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df31f50c2a7c471cb2d0df0f9e1621dd~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>结构说明：</strong></p><p>1.标签由**&lt; <strong>、** &gt; <strong>、</strong> &#x2F; <strong>、</strong>英文单词</strong>或<strong>字母</strong>组成。并且把标签中&lt;&gt;包括起来的英文单词或字母称为**标签名**</p><p>2.常见标签由两部分组成，我们称之为：<strong>双标签</strong>。前部分叫<strong>开始标签</strong>，后部分叫<strong>结束标签</strong>，两部分之间包裹内容</p><p>3.少数标签由一部分组成，我们称之为：<strong>单标签</strong>。自成一体，无法包裹内容。</p><p><strong>HTML标签与标签之间的关系</strong></p><p>父子关系（嵌套关系）<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa3672a0e1af45eb8f94560ee3a6299a~tplv-k3u1fbpfcp-zoom-1.image"></p><p>&lt;head&gt;</p><p>   &lt;title&gt;</p><p>   &lt;&#x2F;title&gt;</p><p>&lt;&#x2F;head&gt;</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bc50297b3b54a4a94bad60d438e7062~tplv-k3u1fbpfcp-zoom-1.image"></p><p>兄弟关系（并列关系）<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05f4754417cb40a4981c72a834f90ca5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>&lt;head&gt;&lt;&#x2F;head&gt;</p><p>&lt;body&gt;&lt;&#x2F;body&gt;</p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d1d1bc951834d8185ef25c0c952b9fd~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="HTML标题、段落"><a href="#HTML标题、段落" class="headerlink" title="HTML标题、段落"></a><strong>HTML标题、段落</strong></h2><p><strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3e9c8e071e5491aa6021639b951ed2d~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p><strong>标题标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7de2bf3aee2f4b8ab565a0bc9a0b247d~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p>代码：h系列标签</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fd89e302584fba9f50727ca597c9b3~tplv-k3u1fbpfcp-zoom-1.image"></p><p>语义：1~6级标题，重要程度依次递减</p><p>特点： 文字都有加粗</p><p>文字都有变大，并且从h1一h6文字逐渐减小</p><p>独占一行</p><p>段落标签</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637d06808986473f91c242788859d51e~tplv-k3u1fbpfcp-zoom-1.image"></p><p>代码：&lt;p&gt;我是一段文字&lt;&#x2F;p&gt;</p><p>语义：段落</p><p>特点： 段落之间存在间隙 独占一行</p><p><strong>HTML换行和水平线标签</strong></p><p><strong>换行标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9446dd0296ee4c8da3051e29c32abfde~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93b3cbfd9e4444791157fd725772063~tplv-k3u1fbpfcp-zoom-1.image"></p><p>代码：&lt;br&gt;</p><p>语义：换行</p><p>特点： 单标签 让文字强制换行</p><h3 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a><strong>水平线标签</strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0151c85a98e43b1ba1e5e9b2554009c~tplv-k3u1fbpfcp-zoom-1.image"></p><p>代码：&lt;hr&gt;</p><p>语义：主题的分割转换</p><p>特点：单标签 在页面中显示一条水平线</p><p><strong>文本格式化标签</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f6dbbf63f18496c8f2fffdd4dcc64dc~tplv-k3u1fbpfcp-zoom-1.image"></p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>b</td><td>加粗</td></tr><tr><td>u</td><td>下划线</td></tr><tr><td>i</td><td>倾斜</td></tr><tr><td>s</td><td>删除线</td></tr></tbody></table><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>strong</td><td>加粗</td></tr><tr><td>ins</td><td>下划线</td></tr><tr><td>del</td><td>删除线</td></tr><tr><td>em</td><td>倾斜</td></tr></tbody></table><p>语义：突出重要性的强调语境</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09412abbd8384ec0a10493eb376efffd~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a><strong>图片标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee8aec4917d143c5aeb740db25c5bd5f~tplv-k3u1fbpfcp-zoom-1.image"></strong></h2><p><strong>src属性</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc829257e5e74f18b74bf360665a052b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>属性注意点： 1.标签的属性写在<strong>开始标签内部</strong> 2.标签上可以同时存在多个属性 3.属性之间以空格隔开 4.标签名与属性之间<strong>必须以空格隔开</strong> 5.属性之间没有顺序之分</p><p><strong>alt属性</strong></p><p>替换文本</p><p>当图片加载失败时，才显示alt的文本 当图片加载成功时，不会显示alt的文本</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dadafe5752f4ea6a6f9417847799a84~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>title属性<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f0026fb65bd4bc1a5e6bb583f65bdc2~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p>提示文本</p><p>当鼠标悬停时，才显示的文本 注：title属性不仅仅可以用于图片标签，还可以用于其他标签</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d078d4688c4825988290cba6248737~tplv-k3u1fbpfcp-zoom-1.image"></p><p>width、height属性</p><p>设置图片的宽高</p><p>注：</p><p>如果只设置widthi或height中的一个，另一个没设置的会自动等比例缩放（此时图片不会变形） 如果同时设置了width和heighti两个，若设置不当此时图片可能会变形</p><p><strong>路径 src</strong></p><p><strong>绝对路径</strong>：指目录下的绝对位置，可直接到达目标位置，通常从盘符开始的路径（不常用）</p><p>【一个固定的指定的位置】 例如： 盘符开头：D.Aday01\ images\1.jpg 完整的网络地址：https:&#x2F;www.itcast.cn&#x2F;2018czgw&#x2F;images&#x2F;logo.gif(了解)</p><p><strong>相对路径</strong>：从<strong>当前文件开始</strong>出发找目标文件的过程</p><p>分类：</p><p>同级目录</p><p><strong>.&#x2F;</strong> 或 直接填写文件名字 下级目录</p><p>直接进入对应文件夹查找 上级目录</p><p><strong>..&#x2F;</strong> 进入上一级目录</p><p>..&#x2F;..&#x2F;上两级目录,<strong>可以多次叠加</strong></p><p>音频标签支持三种格式分别是 MP3,wav ogg ; 推荐使用平时最常见的mp3格式</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/997e71a6ef254404ad3a3470f668d90f~tplv-k3u1fbpfcp-zoom-1.image"></p><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>src</td><td>音频的路径</td></tr><tr><td>controls</td><td>显示播放控件</td></tr><tr><td>loop</td><td>循环播放</td></tr><tr><td>autoplay</td><td>自动播放(部分浏览器不支持)</td></tr></tbody></table><p> 视频标签</p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39f1b08945fc4ac699992b7740f546e9~tplv-k3u1fbpfcp-zoom-1.image"></p><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>src</td><td>视频的路径</td></tr><tr><td>controls</td><td>显示播放的控件</td></tr><tr><td>loop</td><td>循环播放</td></tr><tr><td>autoplay</td><td>自动播放（谷歌浏览器中需配合muted实现静音播放）</td></tr></tbody></table><p>视频标签支持 MP4,webm,ogg,推荐使用MP4格式</p><p><strong>超链接标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c80ef070a914a7db0c3ad77f6bf7040~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9603649a7fff4fa999d1eb2b5e61d793~tplv-k3u1fbpfcp-zoom-1.image"></p><p>特点： 双标签，内部可以包裹内容 如果需要a标签点击之后去指定页面，需要设置a标签的href属性</p><p>注：当开发网站初期，我们还不知道跳转地址的时候，href的值书写#（空链接）</p><p>超链接标签target属性:</p><p>_self：默认值,在当前窗口中跳转(覆盖原始窗口)</p><p>_blank：在新窗口中跳转(保留原始窗口)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fa87b16716242249c47f686c2c6c3c4~tplv-k3u1fbpfcp-zoom-1.image"></p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5452d75476ab4f6cadef6d7000caffc8~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>列表标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6c4d3a86c084f759b2215fa8a500e74~tplv-k3u1fbpfcp-zoom-1.image"></strong> </p><p>有序列表</p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>ol</td><td>表示有序列表的整体，用于包裹li标签</td></tr><tr><td>li</td><td>表示有序列表的每一项，用于包含每一行的内容</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327c3bc2d2534a359662e37b0c465883~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>无序列表</strong></p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>ul</td><td>表示无序列表的整体，用于包裹li标签</td></tr><tr><td>li</td><td>表示无序列表的每一项，用于包含每一行的内容</td></tr></tbody></table><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9467e5649ca445582f0790e3eeb6cc3~tplv-k3u1fbpfcp-zoom-1.image"></p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff40bf61c507496cbb901223b3fcebc5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>在网页中表示一组无顺序之分的列表，如：新闻列表。</p><p>显示特点： 列表的每一项前默认显示圆点标识</p><p>注：</p><p>ul标签中只允许包含li标签 li标签可以包含任意内容</p><p><strong>自定义列表<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/930c9d4bbc2646f9a8a152f7e20be4a1~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>dl</td><td>表示自定义列表的整体，用于包裹dt&#x2F;dd标签</td></tr><tr><td>dt</td><td>表示自定义列表的主题</td></tr><tr><td>dd</td><td>表示自定义列表的针对主题的每一项内容</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64c7f5f9062040bab6c0c66835812cec~tplv-k3u1fbpfcp-zoom-1.image"></p><p>显示特点：</p><p>dd前会默认显示缩进效果</p><p>注：</p><p>dl标签中只允许包含dt&#x2F;dd标签 dt&#x2F;dd标签可以包含任意内容</p><p><strong>表格标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7499831c1d4142a2a889143abb0dca8e~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>表格整体，可用于包裹多个tr</td></tr><tr><td>tr</td><td>表格每行，可用于包裹td</td></tr><tr><td>td</td><td>表格单元格，可用于包裹内容</td></tr></tbody></table><p>注意点： 标签的嵌套关系：table&gt;tr&gt;td</p><p>表格属性</p><table><thead><tr><th>属性名</th><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>border</td><td>数字</td><td>边框宽度</td></tr><tr><td>width</td><td>数字</td><td>表格宽度</td></tr><tr><td>height</td><td>数字</td><td>表格高度</td></tr><tr><td>rules</td><td>all</td><td>表格单线</td></tr></tbody></table><p>注： <strong>实际开发时针对于样式效果推荐用CSS设置</strong></p><p><strong>表格标题和表头单元格标签</strong></p><table><thead><tr><th>标签名</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>caption</td><td>表格大标题</td><td>表示表格整体大标题，默认在表格整体顶部居中位置显示</td></tr><tr><td>th</td><td>表头单元格</td><td>表示一列小标题，通常用于表格第一行，默认内部文字加相并居中显示</td></tr></tbody></table><p>注：</p><p>caption标签书写在table标签内部</p><p>th标签书写在tr标签内部（用于替换td标签）</p><p>表格结构标签（了解）</p><table><thead><tr><th>标签名</th><th>名称</th></tr></thead><tbody><tr><td>thead</td><td>表格头部</td></tr><tr><td>tbody</td><td>表格主体</td></tr><tr><td>tfoot</td><td>表格底部</td></tr></tbody></table><p>注： <strong>表格结构标签内部用于包裹t标签</strong> 表格的结构标签可以省略</p><p><strong>合并单元格</strong></p><p>合并单元格</p><p>步骤：</p><p>1.明确合并哪几个单元格</p><p>2.通过左上原则，确定保留谁删除谁</p><p>上下合并一只保留最上的，删除其他</p><p>左右合并一只保留最左的，删除其他</p><p>3.给保留的单元格设置：跨行合并(rowspan)或者跨列合并(colspan)</p><p>注：</p><p>只有同一个结构标签中的单元格才能合并，不能跨结构标签合并（不能跨：thead、tbody、tfoot)</p><p><strong>表单标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28e869d3ca6a4a0ca1b4ae10c337e512~tplv-k3u1fbpfcp-zoom-1.image"></strong> </p><p>用于登陆、注册、搜索页面</p><p>input标签</p><table><thead><tr><th>标签名</th><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>text</td><td>文本框，用于输入单行文本</td></tr><tr><td>input</td><td>password</td><td>密码框，用于输入密码</td></tr><tr><td>input</td><td>radio</td><td>单选框，用于多选一</td></tr><tr><td>input</td><td>checkbox</td><td>多选框，用于多选多</td></tr><tr><td>input</td><td>file</td><td>文件选择，用于之后上传文件</td></tr><tr><td>input</td><td>submit</td><td>提交按钮，用于提交</td></tr><tr><td>input</td><td>reset</td><td>重置按钮，用于重置</td></tr><tr><td>input</td><td>button</td><td>普通按钮，默认无功能，之后配合js添加功能</td></tr></tbody></table><p><strong>text标签【placehoder属性】</strong></p><p>作用：占位符，提示用户输入文本的内容</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e72ed3a534e492f804f55a36077e2ce~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>radio属性值</strong></p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>分组。有相同name属性值的单选框为一组，一组中同时只能有一个被选中</td></tr><tr><td>checked</td><td>默认选中</td></tr></tbody></table><p>注： name属性对于单选框有分组功能 有相同name属性值的单选框为一组，一组中只能同时有一个被选中</p><p><strong>file标签【multiple属性】</strong></p><p>作用：多文件选择</p><p>reset标签【form表单预标签】</p><p><strong>value属性<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2097f9c7a5f74cd9b35e2046d50fd125~tplv-k3u1fbpfcp-zoom-1.image"></strong> </p><p>作用：用于给按钮命名</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9652b8844e3549b4ae628f3efd354e55~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>select下拉菜单标签</strong></p><p>作用：在网页中提供多个选择项的下拉菜单表单控件</p><p>标签组成：</p><p>selecti标签：下拉菜单的整体</p><p>option标签：下拉菜单的每一项</p><p>常见属性：</p><p>selected:下拉菜单的默认选中</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da08b3bbbe64489904d0f6b742f99b2~tplv-k3u1fbpfcp-zoom-1.image"></p><p> textarea文本域标签</p><p>作用：在网页中提供可输入多行文本的表单控件</p><p>标签名：textarea 常见属性：</p><p>cols:规定了文本域内可见宽度</p><p>rows:规定了文本域内可见行数</p><p>注意点：</p><p><strong>右下角可以拖拽改变大小 实际开发时针对于样式效果推荐用CSS设置</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2faa603b85d4337a5048e69284f77f9~tplv-k3u1fbpfcp-zoom-1.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5ac5c22d764403a8790808f81f5feb9~tplv-k3u1fbpfcp-zoom-1.image"></p><p>label标签</p><p>作用：常用于绑定内容与表单标签的关系, 增加点击范围,提高用户体验</p><p>标签名：label</p><p>方法①：</p><p>1.使用label标签把内容（如：文本）包裹起来</p><p>2.在表单标签上添加id属性 3.在label标签的for属性中设置对应的id属性值</p><p>方法②：(推荐)</p><p>1.直接使用label标签把内容（如：文本）和表单标签一起包裹起来</p><p>2.需要把label标签的for属性删除即可 </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc2a4b70aa64500a74526144cc2ce82~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>语义化标签<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81faa03306a4469beafa88ac6c33e6c~tplv-k3u1fbpfcp-zoom-1.image"></strong> </p><p>没有语义的布局标签div和span 作用：实际开发网页时会大量频繁的使用到div和span这两个没语义的布局标签</p><p>div标签：一行只显示一个（独占一行）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2797e50569284d7eb7a27b97e36f6086~tplv-k3u1fbpfcp-zoom-1.image"></p><p>span标签：一行可以显示多个</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0738bdb2c4614e7c8f77d9dde9952e11~tplv-k3u1fbpfcp-zoom-1.image"></p><p><strong>字符实体<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4edfb4294cc48209392db60e965e6e1~tplv-k3u1fbpfcp-zoom-1.image"></strong></p><p>标签名： </p><p>在文字之间添加空格</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a0c70c012924f43bf7642296a55f27e~tplv-k3u1fbpfcp-zoom-1.image"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
