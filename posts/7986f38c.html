<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>前端常见面试题合集 | DL Blog</title><meta name="keywords" content="面试经验"><meta name="author" content="dleei"><meta name="copyright" content="dleei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="前端常见面试题合集"><meta name="application-name" content="前端常见面试题合集"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="前端常见面试题合集"><meta property="og:url" content="http://example.com/posts/7986f38c.html"><meta property="og:site_name" content="DL Blog"><meta property="og:description" content="vue对vue的理解Vue.js（&amp;#x2F;vjuː&amp;#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。Vue所关注的核心是MVC模式中的视图层,由数据驱动视图,把重点放在操作数据上 1.vue的核心特征就是主要有三点 数据驱动"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202311142355783.png"><meta property="article:author" content="dleei"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202311142355783.png"><meta name="description" content="vue对vue的理解Vue.js（&amp;#x2F;vjuː&amp;#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。Vue所关注的核心是MVC模式中的视图层,由数据驱动视图,把重点放在操作数据上 1.vue的核心特征就是主要有三点 数据驱动"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/posts/7986f38c"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: dleei","link":"链接: ","source":"来源: DL Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'DL Blog',
  title: '前端常见面试题合集',
  postAI: '',
  pageFillDescription: 'vue, 对vue的理解, 前端路由原理, 什么是mvvm?优缺点, 工厂函数与构造函数的区别, 在vue2中是如何监听数组的变化, 有没有了解虚拟列表, vue2中element-ui的自动按需导入, 1. 安装 babel-plugin-import 插件, 2. 配置 .babelrc 文件, 3. 在 main.js 中引入 Element UI 样式, libraryName 配置, 图片懒加载实现, vue-cli基于webpack底层封装了mode环境变量配置(开发或是生产环境)可以实现手动配置选项覆盖, css选择器优先级, 可继承的属性有哪些, 清除浮动, 盒子居中方法, 1.flex布局, 2.脱标利用margin自动实现居中, 3.利用位移和定位, 自定义指令的生命周期, 依赖注入, 前端路由两个形式, 给你一个数组实现去重, computed和watch的区别, 对SPA的理解, v-show和v-if怎么理解, 聊一聊vue的生命周期, 题外话数据请求在created和mounted的区别, vue实例挂载的过程中发生了什么, 三、结论, 为什么不建议v-for和v-if一起用, 为什么data属性是一个函数而不是对象, 组件间的通信方式, 父子组件之间的通讯, 父向子传值, 子向父传值, 非父子组件之间的传值, 兄弟之间, 复杂组件, vue双向绑定的理解及原理, 谈谈你对 $nextTick 的理解, slot的理解应用场景, 默认插槽, 具名插槽, 作用域插槽, vue.observable 你有了解过吗？, 对vue中key的理解, 对keep-alive的理解如何缓存当前组件、缓存后如何更新, keep alive原理, vue常用修饰符应用场景, 你有写过自定义指令吗？应用场景, vue中的过滤器了解过吗？应用场景, 什么是虚拟DOM？如何实现一个虚拟DOM, 了解diff算法吗？, vue2及vue3的区别, vue项目本地开发完成后部署到服务器后报404是什么原因呢？, 你是怎么处理vue项目中的错误的？, 父子组件的生命周期, vue如何监听对象或者数组某个属性的变化, 对象属性的监听, 数组元素的监听, 使用 $watch, 使用 Vue.Set, assets和static的区别, VueRouter是什么 有那些组件, router和route的区别, 路由开发的优缺点, VueRouter的使用方式, 路由跳转有那些方式, 编程式导航使用的方法以及常用的方法, 路由的传参方式, 路由重定向和404, 路由配置项常用的属性及作用, 路由守卫, 说说你对vuex的理解, 数据不响应的情况有哪些如何解决, vue.use的原理, mixin的作用和组件冲突的优先级, mixin 的作用：, 组件和 mixin 冲突的优先级：, 如何强制更新vue组件, vue3, vue3.0的设计目标是什么？做了哪些优化, vue3.0性能的提升主要通过那几个方面体现的, Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？, Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？, 1. 组织代码的方式：, 2. 响应式数据的声明：, 3. 生命周期钩子：, 4. 代码重用：, 5. Typescript 支持：, 说说Vue 3.0中Treeshaking特性？举例说明一下？, 举例说明：, 用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？, 其他, 你了解axios原理吗？有看过源码吗？, SSR解决了什么问题？有做过吗？如何做的, 说说vue项目目录结构若是大型项目如何划分组件及结构, 权限管理如何做？控制到按钮级别的权限如何做？, 浏览器底层原理, 浏览器是如何解析css选择器的, 浏览器是如何进行界面渲染的, 前端如何实现实时通讯?, 特性：, 工作原理：, JavaScript 中的使用：, 什么是浏览器同源策略?, 如何实现跨域获取数据, JavaScript, 说说JavaScript中的数据类型？存储上的差别？, 基本数据类型7种, 引用数据类型, js数据类型的检测, 数组的常用方法有哪些？, JavaScript字符串的常用方法有哪些？, x3Dx3D 和 x3Dx3Dx3D区别分别在什么情况使用, ==（相等操作符）：, ===（严格相等操作符）：, 如何选择使用：, 深拷贝浅拷贝的区别？如何实现一个深拷贝？, 说说你对闭包的理解？闭包使用场景, 说说你对作用域链的理解, JavaScript原型原型链 ? 有什么特点？, Javascript如何实现继承？, cookie 、localstorage 、 sessionstrorage 之间有什么区别？, 谈谈this对象的理解, JavaScript中执行上下文和执行栈是什么？, 说说JavaScript中的事件模型, typeof 与 instanceof 区别, 解释下什么是事件代理？应用场景？, 说说new操作符具体干了什么？, ajax原理是什么？如何实现？, bind、call、apply 区别？如何实现一个bind?, 说说你对正则表达式的理解？应用场景？, 说说你对事件循环的理解, DOM常见的操作有哪些？, 说说你对BOM的理解常见的BOM对象你了解哪些？, 举例说明你对尾递归的理解有哪些应用场景, 说说 JavaScript 中内存泄漏的几种情况？, Javascript本地存储的方式有哪些？区别及应用场景？, 说说你对函数式编程的理解？优缺点？, Javascript中如何实现函数缓存？函数缓存有哪些应用场景？, 说说 Javascript 数字精度丢失的问题如何解决？, 什么是防抖和节流？有什么区别？如何实现？, 如何判断一个元素是否在可视区域中？, 大文件上传如何做断点续传？, 一、是什么, 分片上传, 断点续传, 如何实现上拉加载下拉刷新？, 什么是单点登录？如何实现？, web常见的攻击方式有哪些？如何防御？, 解释下什么是变量声明提升, js的参数是以什么方式进行传递的, js的垃圾回收机制是怎么做的, 谈谈你平时都用了哪些方法进行性能优化？, 谈谈你对继承的理解, 继承的主要类型：, 继承的实现方式：, 继承的优缺点：, 如何判断是否为数组, Promise的静态方法, 微任务x2F宏任务是什么?, asyncx2Fawait是什么?相较于Promise有什么优势, 请写出至少两种常见的数组排序的方法（原生js）, 请写至少三种数组去重的方法？（原生js）, 知道lodash吗？它有哪些常见的API  ？, 平时都是用那些工具进行打包的？babel是什么？, 谈谈Set 、 map 是什么？, Set（集合）, Map（映射）, 使用场景：, 图片懒加载是怎么实现的？, for in 和 for of 的区别, slice和aplice的区别, slice 方法：, splice 方法：, 区别总结：, substr和substring的区别, substr 方法：, substring 方法：, 区别总结：, 能修改原数组的方法有哪些?, 说一下你对事件委托的理解, 说一说事件的执行过程, 中断循环的方式如何中断forEach, 如何判断后台返回的数据是一个空对象, 数组、对象解构如何实现, 如何二次封装axios, 如何进行接口联调, 严格模式, promise, promise 是什么?, promise 的API, 如何改变 promise 的状态, 链式调用 promisesx2FA+规范, 手写系列, 手写 promise, 手写闭包, 手写递归, ES6, 说说var、let、const之间的区别, var, let, const, 区别, ES6中数组新增了哪些扩展?, ES6中对象新增了哪些扩展?, ES6中函数新增了哪些扩展?, ES6中新增的Set、Map两种数据结构怎么理解?, 你是怎么理解ES6中 Promise的？使用场景？, 怎么理解ES6中 Generator的？使用场景？, 你是怎么理解ES6中Proxy的？使用场景?, 你是怎么理解ES6中Module的？使用场景？, 你是怎么理解ES6中 Decorator 的？使用场景？, ES6有哪些新特性？, css, 说说你对盒子模型的理解?, css选择器有哪些？优先级？哪些属性可以继承？, 优先级, 可继承属性, 说说emx2Fpxx2Fremx2Fvhx2Fvw区别?, em：, px：, rem：, vh（视窗高度单位）：, vw（视窗宽度单位）：, 区别总结：, 说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？, 谈谈你对BFC的理解？, BFC的特性：, 创建BFC的条件：, BFC的应用场景：, 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？, 元素水平垂直居中的方法：, 元素不定宽高的水平垂直居中：, 如何实现两栏布局右侧自适应？三栏布局中间自适应呢？, 两栏布局右侧自适应：, 三栏布局中间自适应：, 说说flexbox（弹性盒布局模型）以及适用场景？, 介绍一下grid网格布局, CSS3新增了哪些新特性？, css3动画有哪些？, 怎么理解回流跟重绘？什么场景下会触发？, 回流（Reflow）：, 重绘（Repaint）：, 优化建议：, 什么是响应式设计？响应式设计的基本原理是什么？如何做？, 如果要做优化CSS提高性能的方法有哪些？, 如何实现单行／多行文本溢出的省略样式？, 如何使用css完成视差滚动效果?, CSS如何画一个三角形？原理是什么？, 让Chrome支持小于12px 的文字方式有哪些？区别？, 说说对Css预编语言的理解？有哪些区别?, 在css中有哪些定位方式, 如何理解z-index?, 如何画一个0.5像素的线, 1. 使用半透明颜色：, 2. 使用box-shadow：, 如何清除浮动?, 你对媒体查询的理解, 标准盒模型和怪异盒模型有哪些区别?, 伪类和伪元素的区别, http, 什么是HTTP? HTTP 和 HTTPS 的区别?, 为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？, 如何理解UDP 和 TCP? 区别? 应用场景?, 如何理解OSI七层模型?, 如何理解TCPx2FIP协议?, DNS协议 是什么？说说DNS 完整的查询过程?, 如何理解CDN？说说实现原理？, 说说 HTTP1.0x2F1.1x2F2.0 的区别?, 说说 HTTP 常见的状态码有哪些适用场景？, 说一下 GET 和 POST 的区别？, 说说 HTTP 常见的请求头有哪些? 作用？, 说说地址栏输入 URL 敲下回车后发生了什么？, 说说TCP为什么需要三次握手和四次挥手？, 三次握手（Three-Way Handshake）：, 四次挥手（Four-Way Handshake）：, 说说对WebSocket的理解？应用场景？, WebSocket的特点和工作原理：, WebSocket的工作过程：, 应用场景：, 小程序, 说说你对微信小程序的理解？优缺点？, 小程序里面怎么发请求？, 小程序有跨域吗？, 小程序常见的组件通信方式, 使用过哪些小程序原生的组件和Api, uni-app开发的特点, 说说微信小程序的生命周期函数有哪些？, 说说微信小程序中路由跳转的方式有哪些？区别？, 说说提高微信小程序的应用速度的手段有哪些？, 小程序分包流程, 小程序实现导航栏自定义, 说说微信小程序的登录流程？, 说说微信小程序的发布流程？, 说说微信小程序的支付流程？, 小程序和h5和pc端开发有什么不一样？, git, 说说你对版本管理的理解？常用的版本管理工具有哪些？, 说说你对Git的理解？, 说说Git中 fork clonebranch这三个概念有什么区别?, 说说Git常用的命令有哪些？, 说说Git 中 HEAD、工作树和索引之间的区别？, 说说对git pull 和 git fetch 的理解？有什么区别？, 说说你对git stash 的理解？应用场景？, 应用场景：, 注意事项：, 说说你对git rebase 和 git merge的理解？区别？, 区别：, 选择使用场景：, 说说 git 发生冲突的场景？如何解决？, 说说你对git reset 和 git revert 的理解？区别？, 区别：, 使用场景：, 注意事项：, git分支规范, git如何合并分支部分代码, 如何切换新分支且不产生新记录, TypeScript, 说说你对 TypeScript 的理解？与 JavaScript 的区别？, 二、特性, 类型批注, 类型推断, 接口, 三、区别, 说说 typescript 的数据类型有哪些？, 说说你对 TypeScript 中枚举类型的理解？应用场景？, 说说你对 TypeScript 中接口的理解？应用场景？, 说说你对 TypeScript 中类的理解？应用场景？, 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？, 说说你对 TypeScript 中泛型的理解？应用场景？, , 说说你对 TypeScript 中高级类型的理解？有哪些？, 说说你对 TypeScript 装饰器的理解？应用场景？, 说说对 TypeScript 中命名空间与模块的理解？区别？, 说说如何在 React 项目中应用 TypeScript？, 说说如何在Vue项目中应用TypeScript？, node.js, 说说你对 Node.js 的理解？优缺点？应用场景？, 说说 Node.js 有哪些全局对象？, 说说对 Node 中的 process 的理解？有哪些常用方法？, 说说对 Node 中的 fs模块的理解? 有哪些常用方法, 说说对 Node 中的 Buffer 的理解？应用场景？, 说说对 Node 中的 Stream 的理解？应用场景？, 说说Node中的EventEmitter? 如何实现一个EventEmitter?, 说说对 Node.js 中的事件循环机制理解?, 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?, 说说对中间件概念的理解如何封装 node 中间件？, 如何实现jwt鉴权机制？说说你的思路, 如何实现文件上传？说说你的思路, 如果让你来设计一个分页功能 你会怎么设计? 前后端如何交互?, Node性能如何进行监控以及优化？, 项目, 1. 项目中有封装过axios吗？主要是封装哪些方面, 2. vue项目中跨域问题的解决, 二、如何解决, CORS, Proxy, 3. 本地开发完后部署到服务器后404是什么原因, 4. 项目中的错误处理对的理解或简称为是一个用于创建用户界面的开源框架也是一个创建单页应用的应用框架所关注的核心是模式中的视图层由数据驱动视图把重点放在操作数据上的核心特征就是主要有三点数据驱动所谓的数据驱动就是模型层负责处理业务逻辑以及和服务器端进行交互视图层负责将数据模型转化为展示出来可以简单的理解为页面视图模型层用来连接和是和之间的通信桥梁组件化开发把一整个页面拆成各个不同的组件然后再整合在一起实现各个功能布局的隔离降低整个系统的耦合度调试方便因为不同的功能布局是分离的在出现问题的时候就可以通过错误快速的定位源头方便快捷的查找排查错误提高可维护性和复用性每个组件的职责是单一的丰富的指令系统指令是带有前缀的特殊属性作用当表达式的值改变时将其产生的连带影响响应式地作用于常用的指令有双向数据绑定监听事件绑定属性列表循环渲染条件渲染前端路由原理前端路由的核心就是访问不同的地址对应切换不同的组件显示不同的内容而不是重新加载刷新页面就是把组件一一对应的映射到路由地址上然后渲染出来主要有三种模式在地址的后面是以分隔的但是需要和后端配合进行配置不然用户访问的页面就是在的后面是以分隔的比较丑不美观这也是路由的默认模式一般会在开发的时候使用在上线的时候可以把模式改为好看一点通常用于非浏览器环境例如在服务器端渲染中什么是优缺点表示的是模型层负责处理业务逻辑以及和服务器端进行交互视图层负责将数据模型转化为展示出来可以简单的理解为页面视图模型层用来连接和是和之间的通信桥梁负责监听的变化并更新实现数据和视图之间的双向数据绑定就像前面介绍的时候说的一样用户只需要把重点放在操作数据上面而不是去操作工厂函数与构造函数的区别工厂函数没有共享原型工厂函数需要手动构造函数是通过关键字创建在中是如何监听数组的变化在中提供了一种称为数组变异方法的机制用于监听数组的变化这些变异方法包括数组尾部添加返回修改后数组长度数组尾部删除返回删除的数据数组头部删除返回删除的元素数组头部添加返回新数组长度删除数组任意位置元素删除元素对应位置的索引删除的个数不填默认从头部开始删除新增的元素返回值删除的元素数组数组排序数组翻转当你使用这些方法修改数组时能够检测到变化并及时更新视图的数组变异方法通过重写数组的原型方法来实现当你调用这些方法时会在修改数组之前和之后执行一些特定的逻辑以便通知相关的依赖比如视图以下是一个简单的例子演示了如何在中监听数组的变化在上面的例子中当点击按钮时方法会使用数组变异方法向数组中添加一个新的元素由于监听了这个数组的变化它会在数组被修改后自动更新相关的视图使新的元素在页面上显示出来需要注意的是对数组变异的监听仅限于这些特定的数组变异方法直接通过索引修改数组的元素或修改属性的方式是无法被检测到的如果你需要监听这些非变异操作可以使用方法或方法有没有了解虚拟列表虚拟列表是一种优化长列表渲染性能的技术当需要展示大量数据时传统的方式是将所有数据都渲染到中这可能导致页面加载缓慢占用大量内存和性能下降虚拟列表通过只渲染用户当前可见的部分数据以及根据滚动位置动态加载和卸载列表项来减轻这些问题基本思想是只渲染视口可见区域内的数据项而不是整个数据集这可以通过以下几个关键概念来实现可视区域用户当前看到的部分页面在虚拟列表中只有可视区域内的数据项会被真正渲染到中滚动监听监听滚动事件以确定用户浏览的位置当用户滚动时虚拟列表会相应地更新可视区域的内容动态加载和卸载根据滚动位置动态加载进入可视区域的数据项同时卸载离开可视区域的数据项以保持的轻量级虚拟列表的优势在于减少了初始加载时的渲染压力提高了页面的响应速度这对于处理大型数据集的情况非常有用比如在前端框架如等中使用虚拟列表来渲染大量的列表数据实现虚拟列表的方式可以有多种具体的实现可能依赖于所用的前端框架或库许多现代前端框架都提供了虚拟列表的支持或者有相关的第三方库中的自动按需导入安装插件在项目中安装插件配置文件在项目根目录下创建文件配置插件在中引入样式在你的文件中引入的样式配置选项通常用于指定按需加载的组件库的名称对于插件它的配置对象中还有一些其他可用的选项可以根据需要进行配置以下是一些常见的选项字符串必需用于指定要按需加载的组件库的名称即插件将按照这个名称来寻找组件并进行按需加载字符串默认为用于指定组件库源代码的目录通常是包含组件定义的目录这是相对于组件库的主目录的路径布尔值或函数默认为是否同时导入样式文件如果设置为插件将尝试导入样式文件如果设置为则只导入文件你还可以提供一个函数根据需要返回样式文件路径布尔值默认为是否将组件名从驼峰式转为短横线形式例如可以被转换为这里是一个示例配置图片懒加载实现图片的加载是由引起的当对赋值时浏览器就会请求图片资源根据这个原理我们使用的属性来储存图片的路径在需要加载图片的时候将中图片的路径赋值给这样就实现了图片的按需加载即懒加载注意中的可以自定义这里我们使用来定义懒加载的实现重点在于确定用户需要加载哪张图片在浏览器中可视区域内的资源就是用户需要的资源所以当图片出现在可视区域时获取图片的真实地址并赋值给图片即可使用原生实现懒加载知识点是浏览器可视区的高度是浏览器滚动的过的距离是元素顶部距离文档顶部的高度包括滚动条的距离图片加载条件基于底层封装了环境变量配置开发或是生产环境可以实现手动配置选项覆盖选择器优先级在属性后面写上这条样式会覆盖掉页面上任何位置定义的元素的样式行内样式在属性里面写的样式选择器选择器标签选择器通配符选择器浏览器的自定义属性和继承可继承的属性有哪些以下是一些常见的可继承属性文本属性文本颜色字体系列字体大小等字体系列字体大小字体样式正常斜体等字体粗细行高属性行高列表属性列表样式类型位置等列表项标志的类型列表项标志的位置用作列表项标志的图像表格布局属性表格边框的折叠方式表格边框的间距用户界面属性鼠标指针样式可见性属性元素的可见性生成内容属性用于和伪元素的生成内容光标属性光标类型需要注意的是并非所有的属性都是可继承的例如等尺寸相关的属性就不是可继承的清除浮动使用清除浮动的伪元素这是一种常见的清除浮动的方法通过在父元素上应用伪元素清除浮动兼容在父元素上添加类这样就会在父元素最后插入一个空的块级元素该元素通过规则清除浮动使用属性将父元素的属性设置为或也可以触发块级格式化上下文从而清除浮动或这样设置会创建一个新的使得父元素包含浮动的子元素盒子居中方法布局脱标利用自动实现居中利用位移和定位定位移动的距离参考的父级的大小位移移动参考的距离是自己自身的大小利用父相子绝向右位移向下位移因为定位参考的大小是父级这时就会超出了向上反方向位移自身大小的这时子盒子就会居中显示自定义指令的生命周期当指令被第一次绑定到元素时触发在这个阶段你可以执行一次性的初始化设置在绑定时执行一次性的初始化设置当被绑定元素插入到中时触发通常用于执行初始化操作比如获取焦点在元素插入到时执行初始化操作在包含组件的更新时触发但可能在其子更新之前在组件的更新时触发在包含组件的及其子全部更新后触发在组件的及其子全部更新后触发在指令与元素解绑时触发可以执行一些清理工作在解绑时执行清理工作你在中给添加一个属性但是没有刷新如果你在对象或数组上新增属性或元素也无法检测到变化这样新增的元素不会触发响应式更新解决方法同样使用方法或者扩展运算符来确保变化被观察到使用或者使用扩展运算符依赖注入选项选项允许你指定一个对象其中包含你想要提供给后代组件的属性或方法选项选项用于接收祖先组件通过提供的值你还可以使用对象语法来更详细地配置注入或者如果没有被提供执行提供的函数或者是空函数如果没有被提供前端路由两个形式给你一个数组实现去重使用是一种集合类型它只允许存储唯一的值因此可以用来快速去重数组使用方法使用方法结合或方法来筛选出不重复的元素或者使用使用方法使用方法来构建一个新数组只添加第一次出现的元素使用数据结构使用数据结构来存储数组中的唯一值和的区别计算属性具有缓存的特性当我们初次访问的时候会把数据缓存起来下次访问直接在缓存里面直接取只有当依赖的数据发生变化时才会重新计算它会返回一个经过计算之后的值并且是只能执行同步任务而起到的是一个观察的作用监听数据的变化当监听的数据发生变化时就会执行自定义的回调函数它没有返回值是可以执行异步任务例如发起异步的请求对的理解翻译过来就是单页面应用程序是一种网络应用程序或是网站的模型它是通过动态的重写当前页面来实现与用户之间的交互避免了页面之间的切换跳转打断用户的体验所有页面上的资源和内容都是在用户点击访问的时候按需加载在任何时候都不会重新加载页面优点有桌面应用端的快速访问的及时性和高效性用户体验好用户切换页面是不会重新加载整个页面良好的前后端分离分工更加明确缺点首屏加载速度慢只有一个页面不利于搜索引擎抓取解决首屏加载慢问题减少入口文件的体积静态资源本地缓存框架的按需加载不要使用全局导入使用路由懒加载只有在用户访问的时候才加载对应的页面内容使用使用可以在服务器端预先渲染页面减少客户端渲染时间提高页面加载速度和性能组件重复打包将中重复使用的组件进行打包避免重复加载相同的代码减少服务器响应时间和带宽占用和怎么理解都是依据条件来选择性的决定是否显示元素是通过动态的设置的来显示隐藏元素元素还是在页面上的占据位置应用场景是页面的元素切换显示隐藏比较频繁模态框的显示隐藏是设置依据条件创建或是销毁元素销毁了后页面上是没有元素的相较于开销更加大应用场景一般用在初始状态就是显示或是隐藏在进入页面后检查用户是否登录聊一聊的生命周期概念实例从创建到销毁的整个过程就叫作生命周期生命周期主要有四个阶段八个钩子函数分别是生命周期钩子阶段描述创建前组件实例还未创建常用于插件开发的一些初始化任务创建后组件初始化完毕可以获取数据使用常用于发起的异步数据请求挂载前已被初始化但并未挂载和渲染挂载后已完成挂载和渲染可用于访问数据和操作页面的元素更新前数据已被更新但页面数据并未更新更新后数据已更新完毕销毁前实例销毁前实例目前实例仍然可用常用于一些定时器的清除销毁后实例已被销毁完毕题外话数据请求在和的区别是在组件实例一旦创建完成的时候立刻调用这时候页面节点并未生成是在页面节点渲染完毕之后就立刻执行的触发时机上是比要更早的两者的相同点都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机放在中的请求时间超时就会造成页面渲染阻塞或是造成白屏的状况因为此时页面结构已经生成但如果在页面加载前完成请求则不会出现此情况建议对页面内容的改动放在生命周期当中实例挂载的过程中发生了什么首先找到的构造函数源码位置是用户传递过来的配置项如等常用的方法构建函数调用方法但我们发现本文件中并没有此方法但仔细可以看到文件下方定定义了很多初始化方法定义定义等定义事件定义定义返回虚拟首先可以看方法发现该方法在原型上定义了方法源码位置合并属性判断初始化的是否是组件这里合并主要是或的方法合并属性初始化拦截器初始化组件生命周期标志位初始化组件事件侦听初始化渲染方法初始化依赖注入内容在初始化之前初始化挂载元素仔细阅读上面的代码我们得到以下结论在调用之前数据初始化并未完成像这些属性无法访问到到了的时候数据已经初始化完成能够访问这些属性但这时候并未完成的挂载因此无法访问到元素挂载方法是调用方法方法是完成的初始化源码位置初始化组件的列表初始化初始化方法初始化我们和这里主要看初始化的方法为它与在同一文件上获取到组件上的属性名不能与方法名重复属性名不能与名称重复验证值的合法性将中的数据挂载到组件上这样就可以通过访问到组件上的数据响应式监听是数据的变化仔细阅读上面的代码我们可以得到以下结论初始化顺序定义的时候可选择函数形式或者对象形式组件只能为函数形式关于数据响应式在这就不展开详细说明上文提到挂载方法是调用方法源码位置获取或查询元素不允许直接挂载到或页面文档上存在模板解析模板文件通过选择器获取元素内容将解析将转换成语法字符串生成方法阅读上面代码我们能得到以下结论不要将根元素放到或者上可以在对象中定义或者直接使用表示元素选择器最终都会解析成函数调用会将解析成函数对的解析步骤大致分为以下几步将文档片段解析成描述符将描述符解析成字符串生成函数生成函数挂载到上后会再次调用方法源码位置渲染组件调用渲染组件如果没有获取解析的函数则会抛出警告是解析模板文件生成的没有获取到的模板文件执行钩子定义更新函数实际调是在中定义的和中定义的监听当前组件状态当有数据变化时更新组件数据更新引发的组件更新阅读上面代码我们得到以下结论会触发钩子定义渲染页面视图的方法监听组件数据一旦发生变化触发生命钩子方法主要执行在初始化时声明的方法的作用主要是生成源码位置定义原型上的方法函数来自于组件的调用方法自己的独特的方法传入参数生成主要功能是调用将转换为真实并且更新到页面中源码位置设置当前激活的作用域执行具体的挂载逻辑三结论的时候调用会调用方法定义等方法定义等事件定义生命周期调用进行页面的挂载挂载的时候主要是通过方法定义更新函数执行生成虚拟将虚拟生成真实结构并且渲染到页面中为什么不建议和一起用用于条件性的渲染页面元素遍历数组循环渲染列表数据的优先级比要高会先执行页面的循环渲染再依据的条件选择性的渲染对应的元素若是初次循环渲染的时候有不符合条件的元素就会被渲染出来再依据的条件来判断是否删除和创建元素这样就会造成不必要的性能损耗所以永远不要把和放在同一个元素上如果必须要使用可以使用计算属性先把每个元素依据条件过滤一遍再执行渲染为什么属性是一个函数而不是对象保持数据私有化避免数据污染如果是一个普通的对象当你创建多个相同的组件实例的时候他们就会共享同一个数据对象当你修改其中一个组件实例的数据是另外一个也会被修改这样就会造成影响如果是一个函数当组件被创建的时候函数被调用返回的是一个新的数据对象这样每一个组件的初始数据都是不一样的保持数据的一个私有化修改一个另外一个不会被影响到组件间的通信方式组件通讯可以分为组件和通讯两部分来理解组件每一个文件都可以理解为是一个组件通讯是指以某种方式或是以某种手段来实现信息的传递或者是交互每一个文件都有自己独立的作用域组件之间的数据无法实现数据之间的共享而我们在开发的时候有这种需求组件通讯的目的就是实现组件之间数据的共享把各个组件构成一个完整的有机的整体组件之间的关系主要有父子关系和非父子关系父子组件之间的通讯父向子传值父向子传递父组件绑定一个自定义属性向子组件传递数据子组件就可以使用属性接收到传递过来的数据进行页面渲染子向父传值子向父传递数据使用触发一个自定义事件并传递数据父组件监听到这个自定义事件就可以获取到这个数据来操作获取到的数据非父子组件之间的传值兄弟之间事件总线一方传递数据触发自定义事件并携带数据另一方就可以使用监听到自定义事件和传递过来的数据复杂组件复杂的组件之间的通信推荐使用开发实际中使用的也是比较多的双向绑定的理解及原理是采用数据劫持结合发布者订阅者模式的方式通过来劫持各个属性的在数据变动时发布消息给订阅者触发相应的监听回调主要分为以下几个步骤需要的数据对象进行递归遍历包括子属性对象的属性都加上和这样的话给这个对象的某个值赋值就会触发那么就能监听到了数据变化解析模板指令将模板中的变量替换成数据然后初始化渲染页面视图并将每个指令对应的节点绑定更新函数添加监听数据的订阅者一旦数据有变动收到通知更新视图订阅者是和之间通信的桥梁主要做的事情是在自身实例化时往属性订阅器里面添加自己自身必须有一个方法待属性变动通知时能调用自身的方法并触发中绑定的回调则功成身退作为数据绑定的入口整合和三者通过来监听自己的数据变化通过来解析编译模板指令最终利用搭起和之间的通信桥梁达到数据变化视图更新视图交互变化数据变更的双向绑定效果谈谈你对的理解在更新的时候是异步的当数据发生变化的时候就会开启一个异步更新队列页面视图需要等待队列中所有的数据完成变化之后再统一进行更新如果没有那么每次修改数据都会触发页面视图的更新有了机制就只需要更新一次本质上也是对性能的一种优化策略使用场景在修改数据后想要立即得到修改后的元素或者是一进入页面就要对搜索框获取到焦点就可以使用的理解应用场景艺名叫做插槽花名占坑可以对组件内容进行个性化的定制当我们使用组件的时候不会所有的组件的内容都是符合我们业务的需求这个时候我门就需要使用插槽来完成我们的开发需求应用场景当我们的父组件在使用一个复用组件的时候仅仅只需要修改一小部分内容那我们再去重写一个一样的显然是不明智的通过插槽向不同的位置分发不同的内容实现组件在不同场景下的应用三种插槽默认插槽在子组件内使用标签来占位置也可以在的标签内写入内容这会作为标签的后备内容如果父组件没有传递内容就会显示设置的默认值具名插槽顾名思义就是有名字的插槽在子组件上使用属性给插槽起一个名字不填为默认插槽父组件在分发内容的使用属性名来向子组件内分发指定的内容作用域插槽作用域插槽其实就时可以带数据的插槽即可以携带参数的插槽简单的来说就是子组件提供给父组件的参数该参数仅限于插槽中使用父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容基本使用步骤在子组件的标签上使用自定义属性携带数据传递给父组件父组件使用配合获取传递过来的数据注意相当于往插槽上加了一个自定义属性最终以对象包裹属性的形式传递过去例如此处传过去的数据格式定义形参接收插槽默认名字叫可以简写为变量名这个变量名保存的是由子组件传递过来的数据一般通常情况下直接在这里对传递过来的对象进行解构操作方便后面的使用如果不用也可以不指定名字直接写为变量名完整写法变量名简写形式变量名不指定插槽名接收数据变量名对象解构属性名属性名删除你有了解过吗对中的理解数组循环列表给每一项添加一个唯一标识主要是为了更加高效的更新元素在没有属性的时候更新和改变数据的时候会将整个列表全部重新渲染浪费性能默认采用的是就地复用的原则当列表数据发生变化的时候他会根据属性去判断某一项到底是不是需要被修改如果需要修改就直接渲染这一项否则就会复用之前的对的理解如何缓存当前组件缓存后如何更新路由之间在切换的时候对应的组件就会被销毁和创建这样就会导致状态丢失主要目的就是保持组件的状态确保组件在销毁时不会丢失数据和状态而是把它缓存起来使用使用标签包裹需要缓存的组件即可有三个属性组件名数组只有被匹配中的组件才会被缓存起来组件名数组任何被匹配中的组件都不会被缓存数字最多缓存多少组件会触发两个生命周期函数在进入组件的时候触发在离开组件的时候触发组件在被缓存后就不会有钩子函数了只会有在进入页面的时候的那一次所以提供了和钩子函数来帮我们实现业务需求原理常用修饰符应用场景表单修饰符去除表单首尾的空格将用户输入的值转换为数字类型事件修饰符阻止事件冒泡阻止默认行为绑定事件后只会触发一次按键修饰符修饰符数据的双向绑定你有写过自定义指令吗应用场景的核心就是由数据驱动视图为了方便的实现数据驱动视图设计了一些内置的由开头的指令来实现不同的功能像常用的有的双向数据绑定的数据绑定的数据的条件渲染等等但是有的时候并不是所有的指令都满足我们的需求也是支持我们自己自定义指令的实现个性化的需求组件的注册又分为全局注册和局部注册全局注册全局注册在里面使用方法进行注册该方法会接受两个参数一个是要自定义的指令的名字一个是指令的配置对象配置对象里面会有一个指令的钩子函数会在被插入到树上时自动执行并把绑定了该指令的对象传递过来我们就可以对该元素进行一些你自己想要的一些自定义需求局部注册局部注册在组件的选项中设置属性和全局注册差不多里面有自定义的指令名和配置对象等绑定了自定义指令的元素被插入到树上面的时候对它进行你自己想要的自定义操作应用场景封装一个在初始一进入页面时就获取到框的一个焦点指令名配置对象是指令的钩子函数被指令绑定了的元素会在被插入到树上时自动执行执行时会将绑定该指令的元素传过来然后就可以对其进行操作了或者是封装一个的一个阻止表单重复提交的一个自定义指令设置自定义指令节流时间用户若不设置节流时间则默认第一次执行为标签设置自定义指令提交权限校验自定义指令中的过滤器了解过吗应用场景什么是虚拟如何实现一个虚拟虚拟的解析过程首先对将要插入到文档中的树结构进行分析使用对象将其表示出来比如一个元素对象包含和这些属性然后将这个对象树给保存下来最后再将片段插入到文档中当页面的状态发生改变需要对页面的的结构进行调整的时候首先根据变更的状态重新构建起一棵对象树然后将这棵新的对象树和旧的对象树进行比较记录下两棵树的的差异最后将记录的有差异的地方应用到真正的树中去这样视图就更新了了解算法吗在新老虚拟对比时首先对比节点本身判断是否为同一节点如果不为相同节点则删除该节点重新创建节点进行替换如果为相同节点进行判断如何对该节点的子节点进行处理先判断一方有子节点一方没有子节点的情况如果新的没有子节点将旧的子节点移除比较如果都有子节点则进行判断如何对这些新老节点的子节点进行操作核心匹配时找到相同的子节点递归比较子节点在中只对同层的子节点进行比较放弃跨级的节点比较使得时间复杂从降低值也就是说只有当新旧都为多个子节点时才需要用核心的算法进行同层级比较及的区别性能优化引入了响应式系统的重大改进通过实现了更高效的响应式数据追踪从而提高了性能的编译器生成的代码更小运行时性能更好使应用程序加载更快组合引入了这是一种新的风格使得组件的逻辑更易于组织和重用允许开发者按照功能划分代码而不是像那样按照选项的顺序全局的修改在中全局发生了一些变化例如变成了变成了等这是为了更好地支持模块化的开发方式传送引入了组件用于更灵活地在中的不同位置渲染组件这在处理模态框等场景时非常有用和多根节点允许组件返回多个根节点而要求组件有且只有一个根节点还引入了语法使得在模板中使用多个根节点更加方便动态属性在中可以使用绑定动态的属性名而在中需要使用和的结合来实现项目本地开发完成后部署到服务器后报是什么原因呢项目使用需要后端搭配进行配置当我们在地址栏输入时这时会打开我们目录下的文件然后我们在跳转路由进入到关键在这里当我们在页执行刷新操作是没有相关配置的所以就会出现的情况修改规则无论我们访问任何页面都会重定向到你是怎么处理项目中的错误的父子组件的生命周期加载渲染过程父父父子子子子父子组件更新过程父子子父父组件更新过程父父销毁过程父子子父如何监听对象或者数组某个属性的变化在中你可以使用特性来监听对象或数组中某个属性的变化对于对象你可以使用方法而对于数组你可以使用方法或者直接使用来确保数组变动也被观察到以下是一些示例对象属性的监听这里修改了对象的属性在上述例子中通过选项我们监听了的变化数组元素的监听使用使用确保变化被观察使用直接使用在这两个数组的例子中我们通过选项监听了整个数组的变化如果你需要监听特定元素的变化你可以使用更深层次的属性路径就像在对象属性监听的例子中一样和的区别相同点和两个都是存放静态资源文件项目中所需要的资源文件图片字体图标样式文件等都可以放在这两个文件下不相同点中存放的静态资源文件在项目打包时也就是运行时会将中放置的静态资源文件进行打包上传所谓打包简单点可以理解为压缩体积代码格式化而压缩后的静态资源文件最终也都会放置在文件中跟着一同上传至服务器中放置的静态资源文件就不会要走打包压缩格式化等流程而是直接进入打包好的目录直接上传至服务器因为避免了压缩直接进行上传在打包时会提高一定的效率但是中的资源文件由于没有进行压缩等操作所以文件的体积也就相对于中打包后的文件提交较大点在服务器中就会占据更大的空间建议将项目中需要的样式文件文件等都可以放置在中走打包这一流程减少体积而项目中引入的第三方的资源文件如等文件可以放置在中因为这些引入的第三方文件已经经过处理不再需要处理直接上传是什么有那些组件和的区别相当于正在跳转的路由对象可以从里面获取等属性方法是的实例是一个全局的路由对象里面有很多的属性和方法比如等等路由开发的优缺点优点整体不刷新页面用户体验更好数据传递容易开发效率高缺点开发成本高需要学习专门知识首次加载会比较慢一点不利于的使用方式使用将插入创建路由规则创建路由对象将路由对象挂到实例上设置路由挂载点路由跳转有那些方式通过方法在组件中你可以通过方法进行编程式的导航可以传递一个路径或一个描述地址的对象字符串路径对象形式该方法会导致路由的切换类似于用户点击浏览器的前进或后退按钮通过方法与方法类似但是不会留下历史记录不会在浏览器的历史堆栈中创建新的记录通过方法用于在浏览器的历史记录中前进或后退指定步数可以传递一个负数表示后退正数表示前进后退一步前进一步编程式导航使用的方法以及常用的方法使用方法用于向栈添加一个新的记录然后导航到该记录它接受一个字符串路径或一个描述地址的对象字符串路径对象形式使用方法与类似但是它不会留下历史记录而是替换当前的记录使用方法用于在浏览器的历史记录中前进或后退指定步数可以传递一个负数表示后退正数表示前进后退一步前进一步使用和方法相当于用于后退一步方法相当于用于前进一步后退一步前进一步路由的传参方式路由重定向和匹配后强制切换到另一个目标上是设置要重定向到哪个路由路径网页默认打开匹配路由强制切换到上配置项值为要强制切换的路由路径强制重定向后还会重新来数组里匹配一次规则路由配置项常用的属性及作用路由配置参数跳转路径路径相对于的组件命名路由子路由的配置参数路由嵌套路由解耦重定向路由路由守卫全局前置守卫全局前置守卫会在路由切换开始前被调用可以用来进行一些全局的权限校验或导航控制在路由切换前执行一些逻辑全局解析守卫全局解析守卫会在导航被确认之前解析异步组件它类似于但是在全局后置守卫之前调用在导航被确认之前执行一些逻辑全局后置守卫全局后置守卫会在路由切换完成后被调用可以用来进行一些清理或日志记录等操作在路由切换后执行一些逻辑路由独享守卫路由独享守卫可以直接在路由配置中定义仅对该路由生效在进入路由前执行一些逻辑组件内守卫这些守卫钩子是在组件内部定义的在路由进入时调用在路由更新时调用在路由离开时调用在路由进入时执行一些逻辑在路由更新时执行一些逻辑在路由离开时执行一些逻辑说说你对的理解状态的核心就是一个全局的状态存储即存放所有组件共享的数据这些数据被称为状态通常以一个对象的形式存在状态的改变状态的变更必须通过进行是包含一系列对状态进行操作的方法每个都有一个字符串的事件类型和一个回调函数负责实际修改状态动作用于处理异步操作通过提交来修改状态提供了一种将业务逻辑和异步操作从组件中抽离的方式使得代码更容易维护和测试模块为了应对大型应用中的状态管理问题允许将分割成模块每个模块可以有自己的使得代码组织更加灵活允许你在访问状态时进行一些计算类似于中的计算属性它们对中的状态进行派生返回新的值单一状态树使用单一状态树来存储整个应用的状态这使得状态的变化变得可追踪方便调试和查看整个应用的状态严格模式提供了严格模式可以在开发环境中检测状态的修改是否是通过进行的这有助于捕获在组件外部直接修改状态的错误插件允许通过插件的方式扩展其功能你可以编写插件来添加额外的特性例如日志持久化存储等数据不响应的情况有哪些如何解决直接赋值如果你直接使用对一个对象或数组进行赋值无法检测到变化例如这样的赋值不会触发响应式更新解决方法使用方法或者扩展运算符来确保对象的属性或数组的元素被观察到使用或者使用扩展运算符新增属性或元素如果你在对象或数组上新增属性或元素也无法检测到变化这样新增的元素不会触发响应式更新解决方法同样使用方法或者扩展运算符来确保变化被观察到使用或者使用扩展运算符异步更新问题当在一个异步操作中修改数据时也可能无法立即检测到变化例如在回调函数中修改数据这样的修改可能无法触发响应式更新解决方法使用来确保在下一次更新循环中修改数据的原理是用来注册插件的方法当你使用注册一个插件时实际上它调用了插件的方法这个方法可以用来添加全局级别的功能如全局组件指令过滤器或者向的原型中添加方法具体来说的原理主要包括以下步骤检查插件是否已经被安装方法内部会检查插件是否已经被安装避免重复注册调用插件的方法如果插件尚未安装会调用插件的方法这个方法通常在插件的主文件中定义在这里添加全局功能方法的第一个参数是构造函数第二个参数是插件的选项你可以在这个方法中添加全局组件指令过滤器或者向的原型中添加方法标记插件已安装一旦插件的方法被调用会标记插件已经被安装避免重复注册全局注册组件指令过滤器在方法中你可以利用的全局注册组件指令过滤器全局注册组件全局注册指令全局注册过滤器总的来说的实现非常简单它主要是通过调用插件的方法来完成插件的注册和安装工作这样做的好处是可以让插件的使用变得简单而一致通过一行代码就能完成插件的注册的作用和组件冲突的优先级是中一种重用组件选项的方式它允许你在多个组件之间共享组件选项从而实现代码的复用对象可以包含组件选项如等以及生命周期钩子的作用代码复用通过使用你可以将一些组件选项提取出来使其可以在多个组件中重复使用这在一些具有相似功能或行为的组件中特别有用逻辑分离将一些通用的逻辑从组件中抽离通过进行管理有助于使组件更加清晰易于维护动态混入可以动态地混入到组件中实现更灵活的组合方式组件和冲突的优先级当一个组件和一个或多个都定义了相同的选项时它们之间的优先级是有规则的以下是优先级的规则全局如果有全局它将首先被应用其选项将被混入到每个组件中局部接下来如果在组件中使用了局部那么局部的选项将覆盖全局的选项组件本身最后组件本身的选项将覆盖全局和局部的选项这意味着如果组件和定义了相同的选项组件的定义将具有最高的优先级其选项将覆盖中相同选项的值如何强制更新组件的设计目标是什么做了哪些优化监测机制的改变将带来基于代理的实现提供全语言覆盖的反应性跟踪消除了当中基于的实现所存在的很多限制只能监测属性不能监测对象检测属性的添加和删除检测数组索引和长度的变更支持和模板作用域插槽的机制导致作用域插槽变了父组件会重新渲染而把作用域插槽改成了函数的方式这样只会影响子组件的重新渲染提升了渲染的性能同时对于函数的方面也会进行一系列更改来方便习惯直接使用来生成对象式的组件声明方式中的组件是通过声明的方式传入一系列和的结合需要通过一些装饰器的方式来做虽然能实现功能但是比较麻烦修改了组件的声明方式改成了类式的写法这样使得和的结合变得很容易其它方面的更改支持自定义渲染器从而使得可以通过自定义渲染器的方式来扩展而不是直接源码来改的方式支持多个根节点和在其他部分渲染组件内容组件针对一些特殊的场景做了处理基于优化提供了更多的内置功能性能的提升主要通过那几个方面体现的里为什么要用替代在中会改变原始数据而是创建对象的虚拟表示并提供和等处理器这些处理器可在访问或修改原始对象上的属性时进行拦截有以下特点不需用使用或触发响应式全方位的数组变化检测消除了无效的边界情况支持和实现的响应式原理与的实现原理相同实现方式大同小异收集依赖等触发依赖对于集合类型就是对集合对象的方法做一层包装原方法执行后执行依赖相关的收集或触发逻辑所采用的与使用的有什么不同组织代码的方式使用选项对象的方式组织代码在一个组件中数据计算属性方法生命周期钩子等都被放在一个对象中允许开发者按照功能划分代码将相关的代码逻辑组织在一起而不是按照选项的形式组织每个功能可以通过函数中的返回值来进行导出和重用响应式数据的声明在中响应式数据通常通过方法返回的对象进行声明在中可以使用等函数来声明响应式数据生命周期钩子在中生命周期钩子直接作为对象的属性进行声明在中生命周期钩子使用的形式进行声明代码重用在中代码重用通常通过混入来实现但有时可能会导致命名冲突或复杂性明确支持逻辑的提取和重用通过将相关逻辑放在一个函数内并在中导入和调用支持中的支持通常需要在组件的选项对象上进行类型声明有时可能不够直观在下更直观通过函数参数的类型推断可以更好地支持类型检查说说中特性举例说明一下中引入了特性这是一项优化技术用于在构建时剔除未使用的代码从而减小最终打包文件的体积主要依赖于静态分析通过分析模块的依赖关系识别和去除未使用的部分在中特性主要表现在以下方面模块的标记的模块系统使用了模块规范这使得引擎能够更好地理解和优化模块的导入和导出这种标准的模块系统有助于静态分析提高了的效果编译时标记的编译器在编译阶段会标记出哪些代码是可以被的这种标记是基于编译时的静态分析可以准确地识别不会被使用的部分举例说明考虑以下简单的组件未被使用的方法在这个组件中有一个未被使用的方法由于的特性如果这个方法没有在组件内被使用那么在构建时它将被剔除不会出现在最终打包的代码中这样即使你在组件内定义了一些方法或变量只要它们在实际渲染的过程中没有被使用它们就不会被包含在最终的打包文件中这对于减小应用的体积非常有帮助特别是在大型应用中很多时候我们可能引入了一些库或组件但只使用了其中的一部分功能通过未使用的部分将被自动去除减小了不必要的资源加载用写过组件吗如果想实现一个你会怎么设计其他你了解原理吗有看过源码吗解决了什么问题有做过吗如何做的说说项目目录结构若是大型项目如何划分组件及结构权限管理如何做控制到按钮级别的权限如何做封装自定义权限指令实现按钮级别的权限控制在全局注册自定义指令第一个参数是自定义指令名第二个参数是回调函数绑定了该指令的元素被插入到上时就会自动执行通过第二个参数获取其对应的权限点的属性然后在中的用户信息里进行筛选看用户是否具有该权限使用来决定是否显示对应的元素浏览器底层原理浏览器是如何解析选择器的浏览器是如何进行界面渲染的浏览器进行界面渲染的过程可以分为以下几个关键步骤构建树当浏览器接收到文件时它会解析并构建文档对象模型树树是一个由节点元素文本等构成的层次结构表示了页面的结构构建树浏览器解析样式表文件或内嵌样式并构建对象模型树树表示了页面中各个元素的样式信息包括它们的样式属性和如何相互影响构建树树和树结合起来构建树树是由浏览器用于渲染的树结构它只包含需要显示的节点和这些节点的样式信息一些不可见的元素例如的元素不会包含在树中布局在构建树后浏览器进行布局过程确定每个节点在屏幕上的确切位置和大小这个过程也称为回流浏览器需要考虑各种因素如盒模型文档流浮动等来计算元素的准确位置绘制在布局完成后浏览器进行绘制过程将页面的内容绘制到屏幕上这个过程也称为重绘绘制阶段使用绘图引擎将每个元素绘制成像素考虑元素的颜色边框阴影等样式属性合成浏览器将不同层的绘制结果合成在一起形成最终的页面现代浏览器通常使用图层来提高页面的性能图层是一个独立的绘制表面可以单独绘制和合成这样在页面更新时只需要重新绘制和合成发生变化的图层而不是整个页面渲染刷新当页面内容发生变化用户触发交互或浏览器窗口大小改变时浏览器会重新执行上述渲染流程以确保页面保持最新这个整个渲染过程是一个逐步的增量的过程浏览器采用这种方式以提高页面渲染的性能和用户体验前端如何实现实时通讯通常缩写为是一种在单个连接上进行全双工通信的协议与传统的请求响应模型不同允许在同一连接上同时进行双向数据传输实现实时通信协议最初由标准化目前的标准版本是以下是的一些重要特性和工作原理特性全双工通信允许客户端和服务器之间建立持久的连接实现双向实时通信而不是像请求响应那样需要不断地发起新的请求低延迟由于使用了单个连接可以减少因为建立和关闭连接而引入的延迟轻量级的协议头较小通信过程较简单相对于传统的协议的开销较小跨域支持支持跨域通信允许在浏览器中进行跨域实时通信工作原理握手阶段连接的建立始于一个请求通常称为握手阶段客户端发起一个请求请求头中包含协议升级的信息服务器接受后会响应一个包含握手成功信息的响应之后连接协议升级为数据帧传输握手成功后客户端和服务器之间的通信就进入了数据帧传输阶段通信使用帧的概念每个帧可以携带文本二进制数据等信息帧的传输是双向的客户端和服务器可以同时发送和接收帧帧格式帧的格式相对简单通常包含一个头部和一个数据部分头部包含帧的类型长度等信息数据部分则是实际的传输数据关闭连接当需要关闭连接时客户端或服务器可以发送一个关闭帧通知对方关闭连接收到关闭帧的一方也会发送一个关闭帧双方最终关闭连接中的使用在浏览器中可以使用的来创建连接以下是一个简单的示例创建连接监听连接打开事件监听接收到消息事件监听连接关闭事件发送消息在这个例子中等是对象的事件处理函数用于处理连接打开接收消息连接关闭等事件方法用于向服务器发送消息什么是浏览器同源策略同源策略是浏览器的一种安全策略用于限制一个网页文档或脚本如何能够与其他源的资源进行交互同源策略的核心思想是不同源的客户端脚本在没有明确授权的情况下不能读取对方的资源同源是指协议如和域名和端口号都相同如果有任何一个不同就被视为不同源同源策略的主要目的是防止恶意网站通过脚本等方式窃取数据保护用户的隐私和安全如何实现跨域获取数据后端配置前端使用代理转发说说中的数据类型存储上的差别的数据类型主要分为基本数据类型和引用数据类型基本数据类型种字符串可以使用双引号单引号或反引号标示表示有值但是值为空可以理解为就是一个毛坯房里面什么东西都没有通常用来占据位置未来要往里面赋值使用或是声明了变量但是没有初始化那么这个变量的值就是只有两个和新增表示任意大的整数类型普通的整数类型只能安全地存储和运算到这个范围之间的整数而则没有这个限制新增是一种唯一的不可变的数据类型经常用于作为对象属性的键它的主要特点是每次创建都会生成一个唯一的值即使使用相同的字符串也无法创建出相同的引用数据类型是一种特殊类型的对象可以执行代码块是一种特殊类型的对象用于按顺序存储多个值用于存储复杂的数据结构可以包含属性和方法数据类型的检测操作符用于确定变量或表达式的数据类型返回一个表示数据类型的字符串例如返回的结果可以是以下字符串之一或返回返回返回返回返回返回操作符用于检查一个对象是否是某个构造函数的实例它通常用于检测自定义的对象类型返回属性可以使用对象的属性来检测其构造函数这通常用于检测自定义对象类型是一个对象方法这是一种通用的方法可以用于检测任何数据类型包括原始数据类型和引用数据类型返回返回返回返回方法用于检测一个值是否是数组返回函数用于检测一个值是否为非数字值返回数组的常用方法有哪些操作方法增方法接收任意数量的参数并将它们添加到数组末尾返回数组的最新长度在数组开头添加任意多个值然后返回新的数组长度传入三个参数分别是开始位置要删除的元素数量增加的元素返回一个空数组删修改原数组方法用于删除数组的最后一项同时减少数组的值返回被删除的项方法用于删除数组的第一项同时减少数组的值返回被删除的项传入两个参数分别是开始位置删除元素的数量返回包含删除元素的数组改查返回要查找的元素在数组中的位置如果没找到则返回返回要查找的元素在数组中的位置找到返回否则返回第一个匹配的元素排序方法数组翻转数组排序方法接受一个比较函数用于判断哪个值应该排在前面转换方法方法接收一个参数即字符串分隔符返回包含所有项的字符串迭代方法对数组每一项都运行传入的测试函数如果至少有个元素返回则这个方法返回对数组每一项都运行传入的测试函数如果所有元素都返回则这个方法返回对数组每一项都运行传入的函数没有返回值对数组每一项都运行传入的函数函数返回的项会组成数组之后返回对数组每一项都运行传入的函数返回由每次函数调用的结果构成的数组字符串的常用方法有哪些删除前后或前后所有空格符再返回新的字符串把字符串按照指定的分割符拆分成数组中的每一项和区别分别在什么情况使用相等操作符比较过程进行比较时会进行类型转换尝试将比较的两个值转换为相同的类型然后再进行比较示例因为字符串会被转换为数字因为布尔值会被转换为数字它们被视为相等严格相等操作符比较过程进行比较时不会进行类型转换只有在两个值的类型和值都相等的情况下才会返回示例因为它们的类型不同因为它们的类型不同它们的类型相同但值不同如何选择使用推荐使用因为它避免了类型转换带来的一些意外行为更加严格和可靠在特定情况下如果你明确需要进行类型转换或者想要利用的隐式类型转换规则可以使用但需要小心因为类型转换可能导致不直观的结果一般来说为了代码的清晰和可读性最好养成使用的习惯以避免因为隐式类型转换而引起的错误深拷贝浅拷贝的区别如何实现一个深拷贝说说你对闭包的理解闭包使用场景闭包简单来说就是一个嵌套的函数内层函数能够访问外层函数的局部变量这个时候就发生了闭包优点变量私有化延长变量的生命周期缺点变量没有被及时的释放会造成内存泄漏需要手动进行释放使用场景说说你对作用域链的理解说作用域之前先说一说这个作用域作用域一般分为三种分别是块级作用域在中引入的和变量的声明方式具有块级作用域即在包裹的范围之内都可以被访问到之外不可以函数作用域函数作用域只有在函数内部可以被访问到外部无法访问全局作用域全局作用域下声明的变量是在任何位置都是可以被访问到的作用域链当在执行代码访问变量的时候会优先在自身当前作用域查找看有没有如果没有就会到父级作用域依次逐级向上查找直到全局作用域这时如果还是没有找到在非严格模式下会隐式的声明该变量或者是直接报错原型原型链有什么特点原型每一个构造函数和通过构造函数创建出来的实例对象都有一个共同的原型对象构造函数是通过属性来访问实例对象通过属性来访问原型对象原型链简单来说它可以实现对象之间属性和方法的继承和共享当一个对象访问其身上的属性和方法的时候它会优先在自身查找如果没有就会到原型对象身上去查找如果还没有就会逐级向上到的原型对象身上查找直到找到或是到达原型链的末端这时如果还没有找到就会返回这样一个链式查找的过程就叫作原型链如何实现继承在父类的原型上添加共有的属性或者是方法使用创建了一个新的对象建立起关联比如说我们创建一个人类的构造函数给它添加了一个的方法然后我们又创建了一个学生的构造函数给它添加了一个方法使用建立起关联使其原型链指向这样当我们既可以使用使用学生自身的方法也可以使用它原型对象身上的方法因为学生自己身上是没有方法的就会去原型对象身上去查找这样就实现了原型的继承之间有什么区别大小大小大概为左右而和的存储空间比要大大概左右到期时间可以设置到期时间在到期时间没过之前一直有效将数据永久存储到本地页面和浏览器关闭后不会丢失当浏览器或是页面关闭后存储的数据就会丢失谈谈对象的理解的指向在不同的函数里面的指向是不一样的全局指向全局对象也就是普通函数普通函数被当做方法调用的时候指向事件源箭头函数箭头函数的指向是固定的它会继续沿用上一层作用域中的指向构造函数构造函数的指向新创建的实例对象指向也是也可以通过和方法来进行修改的中执行上下文和执行栈是什么说说中的事件模型与区别检测基本数据类型检测引用数据类型用于检测构造函数的属性是否出现在某个实例对象的原型链上解释下什么是事件代理应用场景说说操作符具体干了什么创建一个空的对象一个新的空对象被创建这个对象被称为构造函数的实例对象将新对象的属性指向构造函数的原型对象每个函数都有一个特殊的属性称为这个属性是一个指向对象的引用操作符会将新对象的属性指向构造函数的属性这样新对象就可以访问构造函数原型对象上的属性和方法执行构造函数将新对象绑定到构造函数内部的代码被执行关键字指向新创建的对象这允许构造函数将属性和方法添加到新对象上如果构造函数没有显式返回一个对象那么操作符会返回新创建的对象如果构造函数没有使用关键字返回一个对象则操作符会返回新创建的对象如果构造函数返回一个对象不管是显式返回的还是通过构造函数中的代码生成的则操作符会返回该对象而不是新创建的对象原理是什么如何实现区别如何实现一个都是用来改变的指向主要有三个方面的修改指向的时长不一样和只会改变一次的指向并且立即执行不会立即执行是返回一个改变指向之后的一个新的函数传参方式不一样是数组列表传参是伪数组传参可以分为多传入说说你对正则表达式的理解应用场景说说你对事件循环的理解是一门单线程语言这就意味这在同一时间只能执行一件任务遇到异步任务就会造成代码的阻塞所以里面所有的任务被分为同步任务和异步任务代码从上到下执行会先进入到调用栈执行遇到异步任务就会交给宿主环境浏览器去执行执行完成之后放到任务队列中进行排队接着执行同步任务等待所有的异步任务执行完毕之后就会到任务队列中去读取执行输出结果异步任务里面又有微任务和宏任务微任务的优先级比微任务要高会在任务队列之前插队执行如此不断循环往复的流程就是事件循环常见的操作有哪些说说你对的理解常见的对象你了解哪些举例说明你对尾递归的理解有哪些应用场景说说中内存泄漏的几种情况本地存储的方式有哪些区别及应用场景说说你对函数式编程的理解优缺点中如何实现函数缓存函数缓存有哪些应用场景说说数字精度丢失的问题如何解决什么是防抖和节流有什么区别如何实现一种性能优化手段防抖在单位时间内一个事件被多次触发只会执行最后一次节流早单位时间内一个事件被多次触发只会执行一次第二次触发就会重新开始计时当限制时间过了之后才会执行第二次实现原理防抖利用函数开启一个来实现当事件被点击了之后就清除掉原来的定时器重新开启一个新的定时器应用场景手机号邮箱的验证窗口大小只需窗口调整完成后计算窗口大小防止重复渲染节流在执行函数之前给他设置一个默认的开关或者是阀门为当事件被点击了之后立马把这个变量设置为只有在等延时时间过了之后就再次把开关设置为应用场景页面滚动的电梯导航搜索框搜索联想功能如何判断一个元素是否在可视区域中大文件上传如何做断点续传一是什么不管怎样简单的需求在量级达到一定层次时都会变得异常复杂文件上传简单文件变大就复杂上传大文件时以下几个变量会影响我们的用户体验服务器处理数据的能力请求超时网络波动上传时间会变长高频次文件上传失败失败后又需要重新上传等等为了解决上述问题我们需要对大文件上传单独处理这里涉及到分片上传及断点续传两个概念分片上传分片上传就是将所要上传的文件按照一定的大小将整个文件分隔成多个数据块来进行分片上传如下图上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件大致流程如下将需要上传的文件按照一定的分割规则分割成相同大小的数据块初始化一个分片上传任务返回本次分片上传唯一标识按照一定的策略串行或并行发送各个分片数据块发送完成后服务端根据判断数据上传是否完整如果完整则进行数据块合成得到原始文件断点续传断点续传指的是在下载或上传时将下载或上传任务人为的划分为几个部分每一个部分采用一个线程进行上传或下载如果碰到网络故障可以从已经上传或下载的部分开始继续上传下载未完成的部分而没有必要从头开始上传下载用户可以节省时间提高速度一般实现方式有两种服务器端返回告知从哪开始浏览器端自行处理上传过程中将文件在服务器写为临时文件等全部写完了文件上传完将此临时文件重命名为正式文件即可如果中途上传中断过下次上传的时候根据当前临时文件大小作为在客户端读取文件的偏移量从此位置继续读取文件数据块上传到服务器从此偏移量继续写入文件即可如何实现上拉加载下拉刷新什么是单点登录如何实现常见的攻击方式有哪些如何防御解释下什么是变量声明提升变量声明提升是中的一种行为它使得在代码执行前变量和函数的声明被提升到当前作用域的顶部这意味着可以在声明之前访问这些变量或函数在中有两种声明方式关键字和关键字对于声明的变量和使用声明的函数它们的声明会被提升下面是一个简单的例子演示了变量声明提升输出输出在上面的例子中虽然在之前被调用但由于变量声明提升在该语句执行时已经被声明只是尚未被赋值因此输出而在后续的赋值语句之后输出了注意只有声明会被提升赋值不会如果一个变量在声明之前被访问它的值会是函数声明也会被提升例如输出在上面的例子中在函数声明之前被调用但由于函数声明提升程序会正常输出需要注意的是使用和关键字声明的变量也有提升但与不同它们在提升阶段不会被初始化访问时会报错这被称为暂时性死区简称例如报错总的来说变量声明提升是语言中的一种特性了解它有助于避免在代码中出现一些意外的行为在编写代码时建议将变量和函数的声明放在当前作用域的顶部以提高代码的可读性和可维护性的参数是以什么方式进行传递的的垃圾回收机制是怎么做的谈谈你平时都用了哪些方法进行性能优化减少请求次数打包压缩上线代码使用懒加载使用雪碧图动态渲染组件加载包谈谈你对继承的理解继承是面向对象编程中的一个重要概念它允许一个对象子类派生类获得另一个对象父类基类的属性和方法继承是为了实现代码的重用和扩展使得代码更加模块化可维护和可扩展继承的主要类型单一继承一个子类只能继承自一个父类这是一种简单的继承关系存在较低的复杂性但有时可能会限制灵活性多重继承一个子类可以同时继承自多个父类这样可以更灵活地组合不同的功能但也可能导致复杂性增加引发一些设计上的问题多层继承类型之间形成一个层次结构子类可以继承自父类父类又可以继承自更上层的父类这样的继承关系可以形成一个层次结构继承的实现方式原型链继承通过将子类的原型设置为父类的实例从而让子类共享父类的属性和方法但存在共享引用类型属性的问题且无法传递参数给父类构造函数构造函数继承借用构造函数在子类的构造函数中调用父类的构造函数通过或方法来实现解决了原型链继承的引用类型问题但无法实现原型链上方法的复用借用构造函数组合继承结合原型链继承和构造函数继承既可以共享原型链上的方法又可以解决构造函数继承的问题借用构造函数原型链继承原型式继承利用一个简单的函数创建一个临时构造函数然后将该构造函数的实例作为子类的原型中可以使用方法实现中的类继承使用关键字定义类通过关键字实现继承的类继承更接近传统的面向对象语言的实现方式语法更简洁调用父类构造函数继承的优缺点优点代码复用继承允许子类重用父类的属性和方法减少代码冗余扩展性可以通过继承来扩展或修改现有类的行为缺点耦合性增加高度耦合的继承关系可能导致一个类的改变影响到其他相关的类可读性下降复杂的继承关系可能使代码难以理解和维护创建对象时的灵活性受限子类通常依赖于父类的实现而不能灵活地改变或替换父类的实现如何判断是否为数组方法是最推荐的方法它是引入的用于确定传递的值是否是一个数组返回一个布尔值操作符操作符用于检测构造函数的属性是否出现在对象的原型链中注意可能在涉及多个全局执行上下文的情况下失效因此在跨框架或跨窗口的环境中不是很可靠使用方法方法可以返回一个表示对象的字符串其中包含了对象的类型信息对于数组返回的字符串应该是这三种方法中推荐使用因为它是专门用于检查是否为数组的方法且更直观在兼容性较好的环境中这是最佳选择如果需要更通用的方法也是一种可靠的选择的静态方法调用结果带到实例方法成功的回调里面结果带到实例方法失败的回调优先输出第一个异步任务的结果等待所有的异步任务执行完毕之后执行的回调微任务宏任务是什么是什么相较于有什么优势的语法糖解决函数调用的回调地狱关键字是异步的简写用来声明一个函数是异步函数写在函数的最前面他会返回一个对象可以理解为等待异步他会等待一个异步任务返回的结果下面这两种方法是等效的正常情况下命令后面是一个对象返回该对象的结果如果不是对象就直接返回对应的值等同于不管后面跟着的是什么都会阻塞后面的代码阻塞上面的例子中会阻塞下面的代码即加入微任务队列先执行外面的同步代码同步代码执行完再回到函数中再执行之前阻塞的代码请写出至少两种常见的数组排序的方法原生请写至少三种数组去重的方法原生知道吗它有哪些常见的浅拷贝深拷贝平时都是用那些工具进行打包的是什么对代码进行语法降级解决兼容性谈谈是什么集合定义是一种值的有序列表其中的值必须是唯一的不允许重复特点不允许重复的值中的元素是有序的插入顺序即为遍历顺序可以包含任意数据类型包括基本类型和对象引用常用操作向集合中添加一个新元素从集合中删除一个元素判断集合中是否包含某个元素获取集合中元素的个数清空集合中的所有元素映射定义是一种键值对的集合每个键对应一个值特点键和值可以是任意数据类型与对象不同保留了键的插入顺序的键是唯一的每个键只能对应一个值常用操作设置键值对获取键对应的值删除键值对判断是否包含某个键获取中键值对的个数清空中的所有键值对使用场景的使用场景去重利用的唯一性可以轻松实现数组去重判断值是否存在的使用场景存储和查找键值对数据保持键的顺序与对象相比键可以是任意数据类型不仅限于字符串图片懒加载是怎么实现的图片的加载是由引起的当对赋值时浏览器就会请求图片资源根据这个原理我们使用的属性来储存图片的路径在需要加载图片的时候将中图片的路径赋值给这样就实现了图片的按需加载即懒加载注意中的可以自定义这里我们使用来定义懒加载的实现重点在于确定用户需要加载哪张图片在浏览器中可视区域内的资源就是用户需要的资源所以当图片出现在可视区域时获取图片的真实地址并赋值给图片即可使用原生实现懒加载知识点是浏览器可视区的高度是浏览器滚动的过的距离是元素顶部距离文档顶部的高度包括滚动条的距离图片加载条件图示和的区别遍历对象的键也就是属性名返回的是对应的索引下标遍历的是可迭代对象的元素也就是值和的区别方法作用方法用于创建一个新的数组其中包含从原始数组中选择的元素语法参数开始提取元素的位置包含该位置的元素提取元素的结束位置不包含该位置的元素特点不修改原始数组而是返回一个新的数组如果省略参数方法会提取从位置到数组末尾的所有元素参数可以是负数表示从数组末尾开始计数的位置方法作用方法用于在数组中添加或删除元素可以修改原始数组语法参数开始改变数组的位置要移除的元素个数可选如果设置为则不会删除元素要添加到数组的新元素可选特点修改原始数组返回被删除的元素组成的数组如果为可以用于插入新元素参数可以是负数表示从数组末尾开始计数的位置区别总结不会改变原始数组而是返回一个新的数组会改变原始数组返回被删除的元素组成的数组用于提取数组的一部分而不影响原数组用于添加删除或替换数组的元素并且会直接修改原数组的第二个参数是结束位置不包含该位置的元素而的第二个参数是要删除的元素个数还可以接受多个参数用于在指定位置插入新的元素和的区别方法作用方法用于返回字符串中从指定位置开始的指定长度的子字符串语法参数开始提取字符的位置可以是正整数或负整数如果是负数表示从字符串末尾开始计算可选要提取的字符数特点如果省略参数会一直提取到字符串的末尾如果是负数它将被视为从字符串末尾开始的位置如果是负数或零它会被视为零方法作用方法用于返回字符串中在两个指定下标之间的子字符串语法参数必须是非负整数指定子字符串的开始位置可选必须是非负整数指定子字符串的结束位置不包含该位置的字符特点如果省略参数会一直提取到字符串的末尾不接受负数参数如果出现负数会被视为零如果大于会自动交换这两个参数区别总结的第二个参数是要提取的字符数而的第二个参数是子字符串的结束位置允许使用负数作为起始位置而不接受负数参数如果省略第二个参数会一直提取到字符串的末尾而也会一直提取到末尾直到字符串的长度如果大于会自动交换这两个参数而对于如果大于字符串的长度返回空字符串能修改原数组的方法有哪些在数组末尾添加一个或多个元素并返回修改后数组的长度现在为移除数组末尾的元素并返回被移除的元素现在为为移除数组的第一个元素并返回被移除的元素现在为为在数组的开头添加一个或多个元素并返回修改后数组的长度现在为通过删除或替换现有元素或者添加新元素来修改数组该方法返回被删除的元素组成的数组现在为为颠倒数组中元素的顺序现在为对数组元素进行排序可以接受一个比较函数作为参数现在为说一下你对事件委托的理解说一说事件的执行过程中断循环的方式如何中断如何判断后台返回的数据是一个空对象数组对象解构如何实现如何二次封装如何进行接口联调严格模式是什么概念对象表示异步操作最终的完成或失败以及其结果值这是引用上面的概念十分的晦涩难懂简单来说所谓简单说就是一个容器里面保存着某个未来才会结束的事件通常是一个异步操作的结果从语法上说是一个对象它可以获取异步操作的消息它是新增的语法主要是为了解决异步函数的层层调用带来的回调地狱问题的静态方法在异步任务执行成功时会执行并最终会把结果作为参数带到外面的对象实例的方法里在异步任务执行失败时会执行并最终会把结果作为参数带到外面的对象实例的方法里并行执行多个异步任务并且会在所有的异步任务执行完毕之后执行回调他会接收一个数组异步函数作为参数它也是会进行异步执行的等上一个任务执行完毕之后才会执行第二个异步任务函数最终会等数组里面所有的异步任务函数执行完毕后返回一个结果方法是以谁跑的慢以谁为执行标准它会等待所有的异步任务执行完毕后再执行实例对象的方法输出结果而方法和方法相反它会看哪一个任务执行完毕了之后就直接执行了实例对象的方法输出结果实例方法如何改变的状态前面说过是一个对象他会接收一个回调函数作为参数并且会立即执行里面的回调函数有两个参数由引擎提供不用自己部署参数函数将表示从发送请求时的状态变为会在异步操作成功时调用并将结果作为参数传递出去参数函数将表示从发送请求时的状态变为会在异步操作失败时调用并将结果作为参数传递出去链式调用规范手写系列手写手写闭包手写递归说说之间的区别声明的变量是全局变量也就是顶级对象声明的变量会进行变量提升在对代码进行编译的时候会把变量的声明提升到代码最前面可以对变量重新赋值后面的变量会覆盖前面的函数内声明的变量是局部变量如果不使用那么变量就是全局的声明的变量有块级作用域无法重复赋值会报错变量声声明前都是不可用的也就是暂时性死区只读的一个常量一旦声明不可以被改变声明的变量必须要进行初始化区别变量提升会进行变量提升可以在变量在声明之前被调用值为不会暂时性死区没有暂时性死区和存在暂时性死区也就是只会在代码执行到变量声明的那一行才可以获取到值块级作用域没有块级作用域和有块级作用域重复声明可以重复声明和在同一作用域下不能重复声明变量声明的修改和可以修改声明的变量声明的是一个常量一旦声明不可以被修改修改会报错中数组新增了哪些扩展中对象新增了哪些扩展中函数新增了哪些扩展中新增的两种数据结构怎么理解你是怎么理解中的使用场景怎么理解中的使用场景你是怎么理解中的使用场景你是怎么理解中的使用场景你是怎么理解中的使用场景有哪些新特性箭头函数箭头函数提供了更简洁的函数定义语法并且绑定了词法作用域的和和替代了声明的变量具有块级作用域声明常量其值不可修改模板字符串使用反引号定义字符串模板可以跨行书写支持变量插值和表达式解构赋值方便地从数组或对象中提取数据赋值给变量默认参数函数参数可以设置默认值简化函数的调用展开运算符可以在数组对象等可迭代对象中展开元素简化数组拼接和对象合并等操作说说你对盒子模型的理解选择器有哪些优先级哪些属性可以继承选择器用于选择要样式化的元素以下是一些常见的选择器元素选择器通过元素名称选择元素例如选择所有段落元素类选择器通过类名选择元素以点开头例如选择所有具有类的元素选择器通过元素的选择元素以井号开头例如选择具有的元素属性选择器通过元素的属性选择元素例如选择所有属性为的元素后代选择器选择元素的后代例如选择所有元素下的元素伪类选择器选择元素的特定状态例如选择鼠标悬停在元素上的状态伪元素选择器选择元素的特定部分例如在元素前添加内容优先级规定了不同选择器的优先级优先级决定了当多个规则应用到同一元素时哪个规则的样式将被应用优先级从高到低依次是通过在样式规则中使用标志可以将其优先级提升到最高尽量少使用因为它会增加维护难度内联样式使用属性直接在元素上定义的样式选择器通过选择器定义的样式类选择器属性选择器伪类选择器类属性伪类选择器的优先级相同按照出现的顺序来决定元素选择器伪元素选择器元素选择器和伪元素选择器的优先级相同按照出现的顺序来决定可继承属性一些属性可以被子元素继承这意味着如果父元素具有特定样式子元素将继承这些样式除非子元素有自己的样式规则常见的可继承属性包括字体相关属性等文本相关属性等列表相关属性等表格相关属性等链接相关属性在标签中等生成内容属性在伪元素中说说区别相对单位是相对于其父元素的字体大小的单位继承性具有继承性如果一个元素的字体大小是那么它将是父元素字体大小的倍用途常用于设置字体大小绝对单位是绝对单位表示像素固定大小的大小在不同设备上是固定的用途常用于设置固定大小的元素如边框内外边距等相对根元素是相对于根元素的字体大小的单位相对一致的大小相对于根元素使得在整个页面中保持一致用途用于实现响应式布局特别是对于整个页面的缩放视窗高度单位相对视窗高度表示相对于视窗高度的百分比相对一致等于视窗高度的用途常用于制作具有视窗高度相关布局的元素视窗高度的视窗宽度单位相对视窗宽度表示相对于视窗宽度的百分比相对一致等于视窗宽度的用途常用于制作具有视窗宽度相关布局的元素视窗宽度的区别总结相对于父元素的字体大小绝对单位固定大小相对于根元素的字体大小用于实现整体页面的缩放相对于视窗高度的百分比用于视窗高度相关布局相对于视窗宽度的百分比用于视窗宽度相关布局说说设备像素像素设备独立像素之间的区别谈谈你对的理解即块级格式化上下文是中一个重要的概念是页面上的一个独立的渲染区域规定了内部的块级盒子如何布局并且与这个区域外部毫不相干的特性块级盒子内部的所有元素都是块级盒子这意味着它们按照块级盒子的标准布局上下文独立内部的元素不会影响到外部元素反之亦然这意味着内外的布局互不影响使得页面布局更加灵活阻止外边距重叠在同一个中相邻块级元素的外边距不会发生重叠包含浮动会包含其内部的浮动元素使得父元素可以自适应其内部浮动元素的高度阻止文字环绕可以阻止文字环绕浮动元素使得文字不会环绕在浮动元素的周围创建的条件根元素页面的根元素即为一个浮动元素元素的属性不为绝对定位元素元素的属性为或行内块元素元素的属性为表格单元格元素元素的属性为弹性盒子元素的属性为或网格布局容器元素的属性为或的应用场景清除浮动使用可以清除浮动避免父元素塌陷防止外边距重叠在需要阻止外边距重叠的情况下可以使用自适应两栏布局通过将父元素设为可以包含内部浮动元素实现自适应两栏布局阻止文字环绕在需要阻止文字环绕浮动元素的情况下可以使用元素水平垂直居中的方法有哪些如果元素不定宽高呢元素水平垂直居中的方法使用对于容器设置和使用布局对于容器设置和使用绝对定位和负边距对于需要居中的元素设置然后通过负边距和组合实现居中使用表格布局对于容器设置然后对子元素设置元素不定宽高的水平垂直居中使用和对于容器设置和然后对子元素设置使用绝对定位和对于需要居中的元素设置和使用和百分比定位对于容器设置和然后对子元素设置和如何实现两栏布局右侧自适应三栏布局中间自适应呢两栏布局右侧自适应固定宽度左侧栏右侧自适应三栏布局中间自适应固定宽度左右栏中间自适应说说弹性盒布局模型以及适用场景介绍一下网格布局新增了哪些新特性颜色和模式白色半透明和颜色代表色相饱和度和亮度而添加了通道这种颜色表示方法更直观允许你在颜色的基础上进行更精确的调整例如设置绿色背景文字阴影边框圆角盒子阴影盒子模型字体图标弹性布局动画有哪些怎么理解回流跟重绘什么场景下会触发回流定义回流是浏览器为了重新渲染部分或全部页面而重新计算元素的位置和几何结构的过程触发场景回流会在以下情况下触发添加或删除可见的元素元素位置发生变化元素的尺寸发生变化包括边距填充边框宽度和高度变化浏览器窗口尺寸发生变化影响回流是一种代价高昂的操作会触发布局的重新计算影响整个页面的渲染性能重绘定义重绘是当元素样式发生改变但不影响其布局时浏览器将之前绘制的内容重新绘制的过程触发场景重绘会在以下情况下触发修改元素的颜色修改元素的背景修改元素的可见性修改元素的轮廓边框影响重绘的性能开销相对较小因为它不会影响元素的布局只需重新绘制颜色等样式信息优化建议避免直接操作样式使用等方法修改类名一次性更改样式减少回流和重绘的次数使用文档片段对多次操作可以使用文档片段来减少回流离线操作在对进行复杂操作时可以将元素脱离文档流完成操作后再放回文档流使用定时器对于某些频繁触发的操作可以使用定时器将其延迟执行合并多次操作优化动画对于频繁发生的动画使用和等属性进行优化避免影响布局什么是响应式设计响应式设计的基本原理是什么如何做如果要做优化提高性能的方法有哪些如何实现单行多行文本溢出的省略样式如何使用完成视差滚动效果如何画一个三角形原理是什么让支持小于的文字方式有哪些区别说说对预编语言的理解有哪些区别在中有哪些定位方式静态定位默认值元素在正常文档流中定位不受属性的影响相对定位相对于元素在正常文档流中的位置进行定位通过设置属性可以使元素相对于其正常位置进行移动绝对定位相对于最近的已定位祖先元素不包括定位的元素如果没有已定位的祖先元素则相对于最初的包含块通常是元素进行定位固定定位相对于浏览器窗口进行定位即使页面滚动元素位置也不会改变粘性定位相对于用户滚动的容器滚动时相对于视窗不滚动时相对于最近的块级祖先进行定位在容器滚动到某个阈值之前元素为相对定位之后元素为固定定位如何理解如何画一个像素的线使用半透明颜色半透明黑色这样的话线条看起来会比较淡模拟出像素的效果使用垂直偏移像素的阴影颜色为黑色这种方式利用的模糊效果来实现同样也可以模拟出较细的线条如何清除浮动你对媒体查询的理解标准盒模型和怪异盒模型有哪些区别伪类和伪元素的区别什么是和的区别在回答这个问题时你可以提供以下基本信息超文本传输协议是一种用于在上进行数据传输的协议它基于客户端服务器模型客户端发送请求服务器返回响应安全超文本传输协议是的安全版本通过加密通信内容来提高安全性它使用或协议来保护数据传输的安全性区别安全性是明文传输的数据不加密容易被中间人攻击而通过加密通信内容确保数据的保密性和完整性防止窃听和篡改协议使用标准的协议而在的基础上加入了或协议通过这两种协议进行数据加密端口默认使用端口而默认使用端口证书在使用时服务器需要获得一个数字证书由可信任的证书颁发机构签发用于验证服务器身份而通信过程中无法验证服务器的真实性为什么说比安全是如何保证安全的加密传输使用或协议对数据进行加密这意味着在数据传输过程中即使被截获也难以被解读因为只有具备解密密钥的接收方才能还原原始数据这有助于防止窃听和数据篡改攻击身份验证使用的服务器需要获得数字证书由可信任的证书颁发机构签发这个证书用于验证服务器的身份这种机制有助于防止中间人攻击确保用户与服务器之间的通信是与正确的服务器建立的连接数据完整性在通信中数据的完整性得到了保护因为协议使用哈希函数对传输的数据进行摘要确保数据在传输过程中没有被篡改或损坏防范混合内容攻击可以防止混合内容攻击即阻止非安全来源的内容与安全来源的内容混合在同一个页面上提高了整体安全性如何理解和区别应用场景理解和用户数据报协议是一种无连接的协议它不提供像那样的可靠性和顺序传输通过数据包的方式发送数据每个数据包都是一个独立的实体相互之间没有关联不保证数据的可靠性和顺序性但由于其简单性和低开销适用于一些实时性要求较高的应用场景传输控制协议是一种面向连接的协议提供可靠的有序的数据传输服务通过建立连接数据传输和断开连接的三个阶段来确保数据的完整性和有序性使用流的方式传输数据数据被划分为小的数据块并确保它们按照顺序传送到目标区别可靠性是不可靠的不保证数据的可靠性和顺序性是可靠的通过确认机制和重传机制确保数据的可靠传输连接性是无连接的每个数据包独立处理相互之间没有关联是面向连接的通过建立连接来确保数据传输的完整性开销的开销相对较低适用于对实时性要求较高的场景的开销较大但能够提供可靠的有序的数据传输应用场景适用于实时性要求较高可以容忍少量数据丢失的场景如音频和视频流的传输在线游戏等由于的简单性和低开销也常用于广播和多播通信传输控制协议适用于对数据完整性和有序性要求较高的场景如文件传输页面加载电子邮件等在需要确保每个数据包都能被正确接收的情况下使用更为合适如何理解七层模型七层模型概述七层模型是国际标准化组织定义的网络体系结构模型用于指导不同厂商的网络设备和协议的开发它将网络通信划分为七个逻辑层次每个层次负责特定的功能每个层次的功能都建立在下一层提供的服务之上七个层次及其功能物理层主要关注数据的物理传输例如电缆光纤物理连接等定义了数据的传输速率电压等物理特性数据链路层提供了可靠的点对点和点对多点通信通过帧定义数据的格式进行错误检测和纠正网络层负责数据的路由和寻址实现不同网络之间的通信使用地址标识网络上的设备进行数据包的转发传输层提供端到端的通信服务确保数据的可靠传输通过和实现数据的流控制和错误处理会话层管理不同设备之间的通信会话确保数据的有序传输提供建立维护和关闭会话的功能表示层负责数据的格式转换加密和解密确保数据的格式一致性处理数据的语法和语义问题应用层提供网络服务和应用程序之间的接口包括用户界面网络协议和各种应用理解七层模型的好处模块化设计每个层次都有特定的功能使得网络设计更具模块化和可扩展性标准化每个层次的功能都有明确定义的标准促使了不同厂商设备和协议的互操作性问题定位当网络出现问题时七层模型有助于迅速定位问题所在的层次如何理解协议协议概述是一组用于互联网通信的协议包括和它是互联网的基础通信协议被用于在网络中传输数据和的角色传输控制协议提供可靠的面向连接的通信服务确保数据的可靠性有序性和完整性通过确认机制和重传机制实现互联网协议负责数据包的寻址和路由定义了数据包在网络中的传输方式通过地址标识设备和网络协议族协议族包含多个协议不仅限于和还包括一系列支持网络通信的协议如等分层结构协议以分层结构组织分为四个层次分别是应用层传输层网络层和数据链路层这种分层结构有助于实现模块化设计和互操作性应用场景协议被广泛应用于互联网支持各种应用包括浏览电子邮件文件传输等它也是局域网和广域网中常用的协议开放标准是一个开放标准使得不同厂商的设备和软件可以互相通信促进了互联网的发展和扩展协议是什么说说完整的查询过程是一种用于将域名例如转换为对应地址的分布式命名系统它是互联网中用于解析域名的一种关键服务查询过程涉及多个步骤以下是完整的查询过程本地缓存查询首先计算机会检查本地缓存查看之前解析过的域名是否存在于缓存中如果存在且尚未过期就直接使用缓存中的地址从而避免了向服务器发送请求递归查询如果本地缓存中没有相应的记录计算机将向本地服务器发起递归查询本地服务器通常由服务提供商或其他网络服务提供商提供本地服务器查询根域名服务器如果本地服务器无法解析域名它将向根域名服务器发送查询请求根域名服务器是全球体系结构的起始点负责指导查询进入正确的顶级域名服务器根域名服务器返回顶级域名服务器地址根域名服务器收到请求后返回顶级域名服务器的地址顶级域名服务器负责管理特定顶级域如下的域名信息本地服务器查询顶级域名服务器本地服务器向顶级域名服务器发起查询请求请求该域名对应的下一级域名服务器的地址顶级域名服务器返回权威域名服务器地址顶级域名服务器返回包含权威域名服务器地址的响应权威域名服务器是负责管理特定域的具体域名解析信息的服务器本地服务器查询权威域名服务器本地服务器向权威域名服务器发起查询请求请求解析特定域名的地址权威域名服务器返回解析结果权威域名服务器返回包含目标域名的地址的响应给本地服务器本地服务器缓存结果本地服务器将从权威域名服务器获取的地址存储在缓存中以备将来使用并将解析结果返回给计算机计算机使用地址访问目标网站最后计算机获得了域名对应的地址并可以使用该地址与目标服务器建立连接实现数据传输如何理解说说实现原理是一种用于提高网络性能减少加载时间以及增强网站安全性的分布式服务的主要目标是通过在全球范围内部署多个服务器节点将网站的静态资源如图像样式表脚本等缓存到这些节点上从而使用户可以从离他们更近的服务器获取这些资源提高访问速度和用户体验的实现原理包括以下关键步骤内容缓存和分发提供商将网站的静态内容如图片视频等复制到位于全球各地的多个服务器节点上这些节点通常分布在不同的地理位置覆盖各个大洲和国家解析优化当用户发起访问请求时通过解析确定用户的地理位置并将用户的请求引导到离用户最近的服务器这通过将域名映射到最近的服务器地址来实现请求处理和内容提供用户的请求被发送到最近的服务器该服务器检查是否已缓存所请求的内容如果缓存中存在则直接返回缓存的内容如果不存在则向源服务器请求内容并将内容缓存起来供将来的请求使用动态内容优化对于动态内容如个性化的用户数据动态生成的页面等提供商可能使用一些技术如边缘计算或者将请求转发到源服务器这确保了即使是动态生成的内容也能在用户附近快速响应负载均衡使用负载均衡算法来分配用户请求到不同的服务器节点以确保每个节点都能平均处理请求负荷提高整体的性能和可靠性安全性增强通常提供安全功能如攻击防护加密等以增强网站的安全性实时监控和分析提供商通常通过实时监控和分析来了解网络状况根据流量负载和性能指标动态调整服务器节点的分发策略以最优化内容传递说说的区别连接管理使用短连接每个请求响应都需要建立一个新的连接这导致了高延迟和性能低效性能每个请求只能得到一个响应不能复用连接导致性能相对较差无状态是无状态的每个请求都是独立的服务器不会保留任何关于客户端状态的信息持久连接引入了持久连接允许在单个连接上发送多个请求和响应减少了连接建立的开销管道化支持请求响应的管道化可以在一个连接上同时发送多个请求但由于实现的复杂性和一些潜在的问题该特性并没有被广泛采用分块传输编码支持分块传输编码允许服务器逐块发送响应而不需要等到整个响应生成完成多路复用最显著的改变是引入了多路复用允许在单个连接上同时发送多个请求和响应解决了头阻塞问题提高了性能二进制协议使用二进制格式替代了文本格式提高了解析的效率头部压缩引入了头部压缩减小了传输的开销服务器推送支持服务器推送服务器可以在客户端请求之前将额外的资源推送给客户端提高性能说说常见的状态码有哪些适用场景表示请求成功访问地址永久重定向临时重定向客户端错误表示未授权表示禁止访问没有权限表示请求地址错误没有对应的资源文件表示服务端错误说一下和的区别用途主要用于请求获取资源参数通常附加在的末尾通过查询字符串传递请求应该是幂等的即多次请求的结果应该是一致的不应该有副作用主要用于向服务器提交数据通常通过请求体传递参数请求可以用于更新服务器上的资源可能有副作用不一定是幂等的数据传输方式数据通过的查询字符串传递可见于中有长度限制适合传递少量的非敏感数据数据传递在请求体中对传输的数据类型没有限制可以传递大量数据更安全因为数据不会出现在中安全性因为数据在中可见不适合传递敏感信息例如密码等请求更容易被缓存被浏览器记录不适合用于传输敏感信息数据传递在请求体中相对于更安全适合用于传输敏感信息如登录凭据可缓存性请求结果容易被缓存可以被浏览器添加到浏览器历史记录请求结果不容易被缓存不会被浏览器添加到浏览器历史记录幂等性应该是幂等的多次请求的结果应该是一致的不要求幂等性多次请求可能导致不同的结果说说常见的请求头有哪些作用作用指定服务器的域名和端口号告诉服务器请求的目标是哪个主机示例作用标识客户端的类型和版本帮助服务器了解请求的来源示例作用告诉服务器客户端能够处理哪些类型的响应数据通常是指类型示例作用指定客户端能够接受的语言类型用于服务器选择合适的语言返回响应示例作用指定客户端支持的内容编码方式服务器可以使用这些编码来压缩响应数据示例作用控制是否需要持久连接或者在请求完成后关闭连接示例作用表示请求的来源即当前请求是从哪个过来的示例作用包含客户端的信息用于在请求中传递会话信息等状态示例作用包含了用于进行身份验证的凭证信息例如用户名和密码示例作用指定请求体的媒体类型用于告诉服务器发送的数据的格式示例说说地址栏输入敲下回车后发生了什么当在浏览器地址栏输入并按下回车时发生的过程可以简要概括为以下几个步骤解析浏览器首先对输入的进行解析提取出协议主机名端口号路径和查询参数等信息解析浏览器通过解析获取服务器的地址以便建立连接如果浏览器缓存中没有对应的地址将发起查询请求建立连接浏览器通过使用或等协议与服务器建立连接对于还需要进行握手过程建立安全连接发起请求浏览器向服务器发送请求包括请求方法等路径请求头可能的请求体等信息服务器处理请求服务器接收到请求后根据路径和其他信息处理相应的业务逻辑可能涉及到数据库查询动态页面生成等服务器发送响应服务器生成响应包括状态码响应头响应体等并将其发送回给浏览器浏览器接收响应浏览器接收到服务器的响应后根据响应头中的信息判断如何处理响应可能包括渲染执行加载资源等渲染页面如果响应是浏览器开始解析文档构建树同时解析创建样式规则构建树最终将树和树结合生成渲染树然后进行布局和绘制最终将页面显示在用户界面上执行如果中包含了浏览器会执行相应的代码可能导致对的修改发起新的网络请求等操作加载资源页面可能包含引用的其他资源如图片样式表脚本文件等浏览器会根据需要加载这些资源整个过程中浏览器和服务器之间的通信主要依赖于协议而浏览器通过解析执行等来呈现最终的用户界面这一系列的步骤被称为请求响应周期或浏览器渲染流程说说为什么需要三次握手和四次挥手是一种面向连接的协议为了确保可靠的数据传输建立和终止连接时采用了三次握手和四次挥手的过程三次握手第一次握手客户端发送一个报文其中标志位同步序列编号被置为同时选择一个初始序列号第二次握手服务器收到客户端的报文后会回复一个带有和标志位的报文表示同意建立连接并同时选择自己的初始序列号第三次握手客户端收到服务器的报文后向服务器发送一个带有标志位的报文表示握手过程完成原因第一次握手建立连接时客户端告诉服务器自己要发送数据了第二次握手服务器收到客户端的请求准备好并告诉客户端可以发送数据了第三次握手客户端收到服务器的同意此时连接建立双方可以开始进行数据传输四次挥手第一次挥手客户端发送一个报文其中标志位终止连接被置为表示客户端没有数据要发送了第二次挥手服务器收到客户端的报文后向客户端发送一个带有标志位的报文表示已经收到了客户端的关闭请求第三次挥手服务器关闭与客户端的连接发送一个带有标志位的报文告知客户端服务器也准备好关闭连接第四次挥手客户端收到服务器的报文后向服务器发送一个带有标志位的报文表示已经收到了服务器的关闭请求原因第一次挥手客户端没有数据要发送了告诉服务器可以关闭连接第二次挥手服务器收到客户端的关闭请求告诉客户端自己也准备好关闭连接第三次挥手服务器关闭连接告知客户端可以安全关闭了第四次挥手客户端收到服务器的关闭请求向服务器发送确认完成关闭过程这样的设计可以确保在连接的建立和断开过程中双方都能够明确地知道彼此的状态从而确保数据的可靠传输和连接的正确关闭说说对的理解应用场景是一种在单个连接上提供全双工通信的协议它允许在客户端和服务器之间进行实时双向的数据传输协议相对于传统的通信有更低的延迟和更小的开销因为它避免了在每次通信时都建立新的连接的特点和工作原理全双工通信允许客户端和服务器之间双向实时通信可以同时发送和接收数据而不需要等待对方的响应持久连接连接一旦建立可以保持持久性不需要重复的握手和断开低延迟相对于传统的轮询或长轮询可以实现更低的延迟因为通信是即时的而不需要等待定时轮询轻量级与相比协议的头部开销较小减少了通信的数据量的工作过程握手阶段客户端发起连接请求请求中包含头服务器返回状态码表示同意升级协议之后连接建立数据传输阶段客户端和服务器可以通过连接进行双向的实时数据传输可以同时发送和接收消息关闭阶段要关闭连接一方发送一个带有关闭标志的数据帧另一方接收到后也发送一个带有关闭标志的数据帧连接就被关闭应用场景即时通讯适用于实时通讯应用如在线聊天消息推送等因为它允许双方实时发送消息而无需不断建立新的连接在线游戏在线游戏通常需要实时的双向通信可以提供低延迟和高效的数据传输实时协作在协作应用中多个用户可以实时地编辑和查看共享的文档或画布可以用于同步用户的操作金融交易在金融领域实时性是非常重要的可以用于实时更新股票价格交易信息等实时监控可以用于实时监控系统及时推送监控数据和报警信息总体而言适用于需要实时双向通信的场景它提供了更为高效和低延迟的解决方案相对于传统的通信在某些应用场景中具有明显的优势小程序说说你对微信小程序的理解优缺点体积小无需安装直接在微信里面使用方便用户小程序里面怎么发请求这个是最麻烦的微信小程序原生有使用回调函数的方式发请求不支持更没有所以写起来比较麻烦我之前在原生开发的时候下载了一个第三方包包名好像叫有点忘记了可以支持支持写请求和响应拦截器等好用在里面开发的时候使用的是这个方法被自己封装为了的版本但是返回值是一个数组的形式也不是很好用最后我在上份工作里面用的是组件库这个框架除了给我们提供了组件以外还给全局的绑定了一些优化请求的方式我们就可以配置请求的基地址请求响应拦截器后面的工作一直用的是它小程序有跨域吗没有只有浏览器有跨域的说法服务器和小程序都没有跨域跨域是浏览器这个软件的安全策略小程序开发的时候在开发者工具勾选一个不校验的选项就可以了上线以后怎么办小程序的后台网站开发设置里面配置一下对应的域名好像可以添加个小程序常见的组件通信方式父子通信类似于父向子子向父通信全局数据我们一般在小程序里面将多个组件都需要使用的数据放到里面然后通过去用使用过哪些小程序原生的组件和这个就很多了我记不大清了常用的组件比如导航轮播图比较复杂的就是媒体组件地图组件等常用的就很多了我自己用过印象比较深刻的就是微信登录微信支付其他比较简单的就是发请求编程式导航获取基本信息其他的记不太清了看文档直接用比较简单开发的特点可以编写一套代码打包成个平台节约公司成本快速搭建各个平台的产品我之前公司就用这个写过微信小程序和的项目还比较好用就是有些兼容性有些细节需要注意全部是的语法写小程序上手无压力注册时使用组件的时候支持的模式只要符合了基本的结构不需要导入和注册直接使用即可技术选型是原生小程序就是原生语法说说微信小程序的生命周期函数有哪些首先小程序的生命周期有很多种应用级别页面界别和组件级别开发的时候因为是的语法所以还有的生命周期在里面所以我们小程序应用界别和页面级别的采用小程序的生命周期自定义组件采用的生命周期应用级别小程序的文件里面页面级别小程序定义在数组里面或者分包里面的文件组件级别的整个小程序的生命周期小程序初始化时触发全局只触发一次小程序启动或从后台进入前台时触发页面的生命周期页面加载时触发一个页面只会调用一次页面显示切入前台时触发页面初次渲染完成时触发一个页面只会调用一次当从当前页面切换到其他页面当前页面隐藏切入后台时触发当从其他页面返回到当前页面当前页面重新显示切入前台时触发当关闭当前页面或跳转到其他页面时页面卸载时触发当整个小程序被切入后台或被关闭时小程序从前台进入后台时触发小程序销毁时触发说说微信小程序中路由跳转的方式有哪些区别通过该方式进行页面跳转会保留当前页面新页面入栈应用场景一般用于不同业务逻辑的页面之间的跳转保留当前页面的状态可以通过返回按钮返回上一页通过该方式进行页面跳转会关闭当前页面新页面替换当前页面应用场景用于替换当前页面适用于一些不需要保留上一页状态的情况关闭所有页面打开到应用内的某个页面应用场景适用于一些重新登录进入新的模块等需要清空页面栈的情况跳转到页面并关闭其他所有非页面应用场景用于跳转到页面比如从其他业务页面返回到首页关闭当前页面返回上一页面或多级页面应用场景用于返回上一页或多级页面可以指定返回的层级说说提高微信小程序的应用速度的手段有哪些提高微信小程序应用速度的效果可以通过以下手段来实现优化图片压缩图片使用适当的图片压缩工具减小图片文件大小使用合适的图片格式选择适合场景的图片格式如等使用小程序提供的图片服务加速图片加载减少请求尽量减少页面请求的资源数合并和精简文件使用小程序的本地存储功能减少对服务器的频繁请求合理使用缓存合理使用小程序的缓存机制减少重复请求对于不常变化的数据可以通过缓存在本地减少网络请求次数异步加载使用异步加载方式减小首屏加载时间对于一些不是首屏必需的内容可以使用异步加载方式提高页面渲染速度避免使用全局样式尽量避免使用全局样式减少对整体样式的重新计算和渲染使用局部样式限定渲染范围提高渲染效率使用分包加载对于大型小程序可以使用分包加载机制将不同功能的页面分割成不同的包减小首次加载时的体积小程序分包流程小程序实现导航栏自定义说说微信小程序的登录流程通过获取到用户的判断用户是否授权读取用户信息调用读取用户数据由于小程序后台授权域名无法授权微信的域名所以需要自身后端调用微信服务器获取用户信息通过方法请求业务方服务器后端把和一起发送到微信服务器和都是微信提供的可以在管理员后台找到微信服务器返回了及本次登录的会话密钥后端从数据库中查找如果没有查到记录说明该用户没有注册如果有记录则继续往下走是对用户数据进行加密签名的密钥为了自身应用安全不应该在网络上传输然后生成并返回给小程序小程序把存到里面下次请求时先从里面读取然后带给服务端服务端对比对应的记录然后校验有效期说说微信小程序的发布流程说说微信小程序的支付流程打开某小程序点击直接下单获取用户临时登录凭证发送到后端服务器换取在下单时小程序需要将购买的商品商品数量以及用户的传送到服务器服务器在接收到商品商品数量后生成服务期订单数据同时经过一定的签名算法向微信支付发送请求获取预付单信息同时将获取的数据再次进行相应规则的签名向小程序端响应必要的信息小程序端在获取对应的参数后调用发起微信支付唤醒支付工作台进行支付接下来的一些列操作都是由用户来操作的包括了微信支付密码指纹等验证确认支付之后执行鉴权调起支付鉴权调起支付在微信后台进行鉴权微信后台直接返回给前端支付的结果前端收到返回数据后对支付结果进行展示推送支付结果微信后台在给前端返回支付的结果后也会向后台也返回一个支付结果后台通过这个支付结果来更新订单的状态调用支付接口的五个参数小程序这是你的微信小程序的唯一标识符每个小程序都有一个独特的时间戳一个从年月日至今的秒数即当前的时间戳随机字符串随机生成的字符串用于防止重放攻击数据包统一下单接口返回的参数值具体内容格式由微信支付定义签名类型签名算法目前支持和小程序和和端开发有什么不一样不一样的主要是交互方式上面因为小程序屏幕比较小很多电脑上的交互手机上都用不了小程序和有上拉刷新下拉加载的操作小程序和有左滑右滑的操作做一些收藏和删除的业务自己打开京东购物车去操作一遍小程序和有针对与那种刘海屏底部安全区域的单独设置等等具体的我忘记了说说你对版本管理的理解常用的版本管理工具有哪些版本管理是一种软件开发中重要的实践用于追踪管理和协调项目中的代码变更版本管理有助于团队协作追踪项目历史恢复先前的状态同时提供了一种备份和协同开发的机制分布式管理工具集中式管理工具说说你对的理解说说中这三个概念有什么区别概念是在代码托管平台如上的一个操作它创建了原始仓库的一个副本这个副本在你的个人账户下用途主要用于贡献代码或在独立的分支上进行实验性开发你可以在你自己的中进行修改然后通过请求将你的修改合并到原始仓库中概念是从一个现有的仓库中复制整个仓库到本地用途用于获取代码的完整副本以便在本地进行开发测试和修改操作创建了一个连接到原始仓库的本地副本概念是指在一个仓库中创建的一个独立的分支分支是仓库中的一个独立的开发路径用途用于在项目中并行开发多个功能或修复不同的每个分支都可以有不同的提交历史但它们可以在需要时合并在一起区别总结在代码托管平台上创建一个原始仓库的副本通常用于贡献代码和提出修改请求从一个现有的仓库中复制整个仓库到本地用于在本地进行开发和修改在一个仓库中创建的一个独立的开发路径用于并行开发多个功能或修复不同的说说常用的命令有哪些分支名新建新分支分支名切换到指定分支远程分支名远程仓库地址建立远程仓库关联分支名分支合并初始化仓库提交到暂存区提交日志提交到本地仓库本地仓库推送到远程仓库拉取远程仓库查看本地文件状态查看文件提交记录说说中工作树和索引之间的区别概念是指向当前所在分支的引用或者指向某个具体的提交作用在中用于标识当前工作目录所在的提交版本也可以用于切换分支查看历史提交等操作在所指向的提交上进行的修改将会成为新的提交工作树概念工作树是指包含项目实际文件的目录也就是你在本地计算机上的项目副本作用工作树中的文件可以进行编辑和修改这些修改会在提交时被保存到仓库工作树是开发者进行实际工作的地方也是代码的可视化部分索引概念索引是一个暂存区域用于存储将要提交到仓库的修改它是一个缓存区域记录了工作树中所有文件的状态信息作用在进行提交前可以通过将文件的修改添加到索引中形成一个预备提交的状态这样可以选择性地提交文件的部分修改而不是一次性提交所有修改区别总结表示当前所在分支的引用或者指向某个具体的提交标识了当前工作目录所在的版本工作树是包含实际项目文件的目录是开发者进行实际工作的地方可以编辑和修改文件索引是一个缓存区域记录了将要提交到仓库的修改可以选择性地添加和提交文件的部分修改说说对和的理解有什么区别作用是一条综合命令它包含了从远程仓库获取更新和合并两个步骤使用场景当你希望获取远程仓库的更新并将它们合并到本地分支时可以使用例如将从远程的仓库的分支获取更新并合并到当前本地分支作用用于从远程仓库获取更新但它并不会自动合并这些更新到当前分支使用场景当你只希望查看远程仓库的更新而不进行合并操作时可以使用它将远程仓库的变更下载到本地但并不自动修改你的工作目录或当前分支区别总结从远程仓库获取更新并尝试自动合并到当前分支是和的综合命令从远程仓库获取更新但不会自动合并到当前分支这使得你可以预览远程仓库的变更然后决定是否进行合并使用的一个常见场景是查看远程仓库的变更情况然后再决定是否执行或将变更合并到本地分支这样可以避免意外的合并给予开发者更大的控制权说说你对的理解应用场景是一个用于保存当前工作目录和暂存区状态的命令它允许开发者在切换分支或者处理其他任务之前将未提交的修改暂时存储起来以便后续恢复应用场景临时切换分支当你正在某个分支上工作但需要切换到其他分支进行紧急修复或测试时可以使用保存当前工作进度切换分支完成操作后再通过恢复保存当前工作进度切换到其他分支进行紧急修复或测试切回原来的分支恢复之前保存的工作进度保存未提交的修改当你在进行一些修改但突然需要切换到其他任务时可以使用将未提交的修改暂时存储以免影响其他操作保存未提交的修改进行其他任务恢复之前保存的修改避免合并冲突在合并分支之前如果当前分支有未提交的修改可以使用避免与合并引起的冲突保存当前分支的修改从远程拉取最新代码并合并恢复之前保存的修改注意事项不仅会保存工作目录中的修改还会保存暂存区的状态默认会保存所有未提交的修改包括新添加的文件和未追踪的文件可以使用添加一条描述信息以便在恢复时更容易理解每个的目的说说你对和的理解区别是将一个分支的修改合并到另一个分支的过程通过重新设置分支的基点使得提交历史更为线性避免了合并产生的额外的合并提交通常用于保持提交历史的整洁是将一个分支的修改合并到另一个分支的过程它会创建一个新的合并提交将两个分支的修改合并在一起这会在提交历史中产生一个新的合并节点区别提交历史的形状通过合并的提交历史更加线性没有合并节点看起来更加整洁通过合并的提交历史中会产生合并节点形成分叉的结构合并方式会将被合并分支的提交在目标分支的最新提交之后逐个应用形成一系列新的提交会创建一个新的合并提交将两个分支的修改合并在一起并在提交历史中生成一个合并节点历史清晰性通过可以保持提交历史的整洁和线性但可能会导致冲突通过可以保留原始分支的完整历史但会在提交历史中产生合并节点冲突处理如果在过程中发生冲突需要逐个解决每个冲突如果在过程中发生冲突需要解决一次合并冲突然后提交选择使用场景用于个人分支以保持整洁的提交历史不推荐对已经共享给其他开发者的分支进行用于合并多个开发者共享的分支以保留每个开发者的独立提交历史在进行合并时可以使用选项以保留合并提交说说发生冲突的场景如何解决说说你对和的理解区别用于将当前分支的指针移动到指定的提交并可选择是否更新工作目录和暂存区它可以用于撤销提交移动分支等操作用于创建新的提交以撤销先前的提交它不会移动分支而是在提交历史中添加一个新的提交该提交的变更是先前提交的逆操作区别影响提交历史通过可以修改提交历史将指针移动到指定的提交从而删除一些提交这会改变提交历史不建议对已共享的提交进行操作通过创建一个新的提交以保持提交历史的完整性它不修改已有的提交而是添加新的提交作为撤销操作的记录适用场景适用于本地仓库中的操作特别是在分支上进行实验性的提交但不建议在共享的分支上使用适用于已经共享的分支因为它不改变提交历史而是添加新的提交来撤销之前的更改风险因素使用可能会导致丢失提交因为它会直接移动指针使用通常比较安全因为它不会改变原有的提交历史而是创建新的提交来撤销变更使用场景用于本地分支上的实验性提交当需要撤销一些提交时小组内的协作中可以通过撤销尚未共享的提交撤销最后一次提交用于共享的分支上当需要撤销已经共享的提交时适用于已经推送到远程仓库的分支以免影响其他开发者撤销指定提交注意事项在使用时需要谨慎操作因为它会修改提交历史可能导致数据丢失在使用时需要处理可能发生的冲突因为它会创建新的提交分支规范主分支测试分支开发分支如何合并分支部分代码在中你可以使用命令来合并某个提交或一系列提交到当前分支这允许你选择性地合并分支中的部分代码而不是整个分支以下是使用的步骤查找提交首先使用命令查找要合并的提交的提交切换到目标分支切换到你想要将代码合并到的目标分支执行使用命令并提供要合并的提交如果要合并一系列连续的提交可以使用范围这里表示排除自身处理冲突如果有如果合并过程中发生冲突需要手动解决冲突然后使用和完成合并完成合并完成后可以继续进行其他操作或者提交合并结果请注意可能会引入冲突特别是当合并的提交依赖于目标分支的其他修改时在使用时确保理解合并的影响并在需要时手动解决冲突如何切换新分支且不产生新记录说说你对的理解与的区别是的类型的超集支持语法支持面向对象编程的概念如类接口继承泛型等超集不得不说另外一个概念子集怎么理解这两个呢举个例子如果一个集合里面的的所有元素集合里面都存在那么我们可以理解集合是集合的超集集合为集合的子集其是一种静态类型检查的语言提供了类型注解在代码编译阶段就可以检查出数据类型的错误同时扩展了的语法所以任何现有的程序可以不加改变的在下工作为了保证兼容性在编译阶段需要编译器编译成纯来运行是为大型应用之开发而设计的语言如下文件如下编译文件后二特性的特性主要有如下类型批注和编译时类型检查在编译时批注变量类型类型推断中没有批注变量类型会自动推断变量的类型类型擦除在编译过程中批注的内容和接口会在运行时利用工具擦除接口中用接口来定义对象类型枚举用于取值被限定在一定范围内的场景可以接受任意类型的值泛型编程写代码时使用一些以后才指定的类型名字空间名字只在该区域内有效其他区域可重复使用该名字而不冲突元组元组合并了不同类型的对象相当于一个可以装不同类型数据的数组类型批注通过类型批注提供在编译时启动类型检查的静态类型这是可选的而且可以忽略而使用常规的动态类型对于基本类型的批注是和而弱或动态类型的结构则是类型类型推断当类型没有给出时编译器利用类型推断来推断类型如下变量被推断为字符串类型这种推断发生在初始化变量和成员设置默认参数值和决定函数返回值时如果缺乏声明而不能推断出类型那么它的类型被视作默认的动态类型接口接口简单来说就是用来描述对象的类型数据的类型有等数据格式对象的类型就是用接口来描述的三区别是的超集扩展了的语法可处理已有的代码并只对其中的代码进行编译文件的后缀名文件是在编写的文件的时候就会自动编译成文件更多的区别如下图所示说说的数据类型有哪些的数据类型主要有如下布尔类型数字类型字符串类型数组类型元组类型枚举类型任意类型和类型类型类型对象类型布尔类型错误正确数字类型和一样的数值类型都是浮点数可支持二进制八进制十进制和十六进制错误正确进制表示十进制十六进制二进制八进制字符串类型和一样可以使用双引号或单引号表示字符串作为超集当然也可以使用模版字符串进行包裹通过嵌入变量数组类型跟一致通过进行包裹有两种写法方式一元素类型后面接上方式二使用数组泛型元素类型元祖类型允许表示一个已知元素数量和类型的数组各元素的类型不必相同赋值的类型位置个数需要和定义生明的类型位置个数一致类型是对标准数据类型的一个补充使用枚举类型可以为一组数值赋予友好的名字可以指定任何类型的值在编程阶段还不清楚类型的变量指定一个类型不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查这时候可以使用类型使用类型允许被赋值为任意类型甚至可以调用其属性方法定义存储各种类型数据的数组时示例代码如下和和在中表示什么都没有是一个只有一个值的特殊类型表示一个空对象引用而表示一个没有设置值的变量默认情况下和是所有类型的子类型就是说你可以把和赋值给类型的变量数值类型或者正确正确但是配置了标记和只能赋值给和它们各自用于标识方法返回值的类型表示该方法没有返回值是其他类型包括和的子类型可以赋值给任何类型代表从不会出现的值但是没有类型是的子类型这意味着声明的变量只能被类型所赋值类型一般用来指定那些总是会抛出异常无限循环错误的写法正确的写法错误返回的函数必须存在无法达到的终点对象类型非原始类型常见的形式通过进行包裹三总结和基本一致也分成基本类型引用类型在基础类型上增添了等原始类型说说你对中枚举类型的理解应用场景一是什么枚举是一个被命名的整型常数的集合用于声明一组命名的常数当一个变量有几种可能的取值时可以将它定义为枚举类型通俗来说枚举就是一个对象的所有可能取值的集合在日常生活中也很常见例如表示星期的就可以看成是一个枚举枚举的说明与结构和联合相似其形式为枚举名标识符整型常数标识符整型常数标识符整型常数枚举变量二使用枚举的使用是通过关键字进行定义形式如下声明关键字为枚举类型的方式如下声明为枚举类型类型可以分成数字枚举字符串枚举异构枚举数字枚举当我们声明一个枚举类型是虽然没有给它们赋值但是它们的值其实是默认的数字类型而且默认从开始依次累加值默认为值默认为值默认为值默认为如果我们将第一个值进行赋值后后面的值也会根据前一个值进行累加字符串枚举枚举类型的值其实也可以是字符串类型如果设定了一个变量为字符串之后后续的字段也需要赋值字符串否则报错异构枚举即将数字枚举和字符串枚举结合起来混合起来使用如下通常情况下我们很少会使用异构枚举本质现在一个枚举的案例如下通过编译后如下上述代码可以看到可以分成所以定义枚举类型后可以通过正反映射拿到对应的值如下并且多处定义的枚举是可以进行合并操作如下编译后代码如下可以看到对象属性回叠加三应用场景就拿回生活的例子后端返回的字段使用标记对应的日期这时候就可以使用枚举可提高代码可读性如下包括后端日常返回等等状态的时候我们都可以通过枚举去定义这样可以提高代码的可读性便于后续的维护说说你对中接口的理解应用场景一是什么接口是一系列抽象方法的声明是一些方法特征的集合这些方法都应该是抽象的需要由具体的类去实现然后第三方就可以通过这组抽象方法调用让具体的类执行具体的方法简单来讲一个接口所描述的是一个对象相关的属性和方法但并不提供具体创建此对象实例的方法的核心功能之一就是对类型做检测虽然这种检测方式是鸭式辨型法而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定二使用方式接口定义如下例如有一个函数这个函数接受一个对象然后返回这个对象的属性可以看到参数需要有一个的属性可以通过接口描述参数的结构这些属性并不一定全部实现上述传入的对象必须拥有和属性否则在编译阶段会报错如下图如果不想要属性的话这时候可以采用可选属性如下表示这时候属性则可以是类型或者类型有些时候我们想要一个属性变成只读属性在只需要使用声明如下当我们修改属性的时候就会出现警告如下所示这是属性中有一个函数可以如下表示如果传递的对象不仅仅是上述的属性这时候可以使用类型推断给接口添加字符串索引签名接口还能实现继承如下图也可以继承多个父类通过逗号隔开如下三应用场景例如在中定义一个函数用来获取用户的姓名和年龄如果多人开发的都需要用到这个函数的时候如果没有注释则可能出现各种运行时的错误这时候就可以使用接口定义参数变量先定义一个接口正确的调用包括后面讲到类的时候也会应用到接口说说你对中类的理解应用场景一是什么类是面向对象程序设计实现信息封装的基础类是一种用户定义的引用数据类型也称类类型传统的面向对象语言基本都是基于类的基于原型的方式让开发者多了很多理解成本在之后拥有了关键字虽然本质依然是构造函数但是使用起来已经方便了许多但是的依然有一些特性还没有加入比如修饰符和抽象类的支持面向对象的所有特性比如类接口等二使用方式定义类的关键字为后面紧跟类名类可以包含以下几个模块类的数据成员字段字段是类里面声明的变量字段表示对象的有关数据构造函数类实例化时调用可以为类的对象分配内存方法方法为对象要执行的操作如下例子字段构造函数方法发动机为继承类的继承使用过的关键字是一个派生类它派生自基类派生类通常被称作子类基类通常被称作超类类继承了类因此实例也能够使用类方法同样类继承后子类可以对父类的方法重新定义这个过程称之为方法的重写通过关键字是对父类的直接引用该关键字可以引用父类的属性和方法如下父类的方法调用父类的函数子类的方法修饰符可以看到上述的形式跟十分的相似在此基础上添加了三种修饰符公共可以自由的访问类程序里定义的成员私有只能够在该类的内部进行访问受保护除了在该类的内部可以访问还可以在子类中仍然可以访问私有修饰符只能够在该类的内部进行访问实例对象并不能够访问并且继承该类的子类并不能访问如下图所示受保护修饰符跟私有修饰符很相似实例对象同样不能访问受保护的属性如下有一点不同的是成员在子类中仍然可以访问除了上述修饰符之外还有只读修饰符只读修饰符通过关键字进行声明只读属性必须在声明时或构造函数里被初始化如下除了实例属性之外同样存在静态属性静态属性这些属性存在于类本身上面而不是类的实例上通过进行定义访问这些属性需要通过类型静态属性的这种形式访问如下所示上述的类都能发现一个特点就是都能够被实例化在中还存在一种抽象类抽象类抽象类做为其它派生类的基类使用它们一般不会直接被实例化不同于接口抽象类可以包含成员的实现细节关键字是用于定义抽象类和在抽象类内部定义抽象方法如下所示这种类并不能被实例化通常需要我们创建子类去继承如下三应用场景除了日常借助类的特性完成日常业务代码还可以将类也可以作为接口尤其在工程中是很常用的如下由于组件需要传入的类型同时有需要设置默认即这时候更加适合使用作为接口先声明一个类这个类包含组件所需的类型和初始值的类型当我们需要传入类型的时候直接将作为接口传入此时的作用就是接口而当需要我们设置初始值的时候我们只需要的实例就是的初始值这就是作为接口的实际应用我们用一个起到了接口和设置初始值两个作用方便统一管理减少了代码量说说你对中函数的理解与函数的区别一是什么函数是应用程序的基础帮助我们实现抽象层模拟类信息隐藏和模块在里虽然已经支持类命名空间和模块但函数仍然是主要定义行为的方式为函数添加了额外的功能丰富了更多的应用场景函数类型在类型系统中扮演着非常重要的角色它们是可组合系统的核心构建块二使用方式跟定义函数十分相似可以通过关键字箭头函数等形式去定义例如下面一个简单的加法函数上述只定义了函数的两个参数类型这个时候整个函数虽然没有被显式定义但是实际上编译器是能够通过类型推断到这个函数的类型如下图所示当鼠标放置在第三行函数名的时候会出现完整的函数定义类型通过的形式来定于参数类型通过连接参数和返回值类型当我们没有提供函数实现的情况下有两种声明函数类型的方式如下所示方式一方式二当存在函数重载时只能使用方式一的形式可选参数当函数的参数可能是不存在的只需要在参数后面加上代表参数可能不存在如下这时候参数可以是类型或者类型即可以传一个类型或者不传都可以剩余类型剩余参数与的语法类似需要用来表示剩余参数如果剩余参数是一个由类型组成的数组则如下表示函数重载允许创建数项名称相同但输入输出类型或个数不同的子程序它可以简单地称为一个单独功能可以执行多项任务的能力关于函数重载必须要把精确的定义放在前面最后函数实现时需要使用操作符或者操作符把所有可能的输入类型全部包含进去用于具体实现这里的函数重载也只是多个函数的声明具体的逻辑还需要自己去写并不会真的将你的多个重名的函数体进行合并例如我们有一个函数它可以接收类型的参数进行拼接也可以接收类型的参数进行相加如下上边是声明因为我们在下边有具体函数的实现所以这里并不需要添加关键字下边是实现在实现上我们要注意严格判断两个参数的类型是否相等而不能简单的写一个三区别从上面可以看到从定义的方式而言声明函数需要定义参数类型或者声明返回值类型在参数中添加可选参数供使用者选择增添函数重载功能使用者只需要通过查看函数声明的方式即可知道函数传递的参数个数以及类型说说你对中泛型的理解应用场景一是什么泛型程序设计是程序设计语言的一种风格或范式泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型在实例化时作为参数指明这些类型在中定义函数接口或者类的时候不预先定义好具体的类型而在使用的时候在指定类型的一种特性假设我们用一个函数它可接受一个参数并返回一个参数如下写法如果我们打算接受一个类型然后再返回类型则如下写法上述两种编写方式存在一个最明显的问题在于代码重复度比较高虽然可以使用类型去替代但这也并不是很好的方案因为我们的目的是接收什么类型的参数返回什么类型的参数即在运行时传入参数我们才能确定类型这种情况就可以使用泛型如下所示可以看到泛型给予开发者创造灵活可重用代码的能力二使用方式泛型通过的形式进行表述可以声明函数接口类函数声明声明函数的形式如下定义泛型的时候可以一次定义多个类型参数比如我们可以同时定义泛型和泛型接口声明声明接口的形式如下那么当我们想传入一个作为参数的时候就可以这样声明函数类声明使用泛型声明类的时候既可以作用于类本身也可以作用与类的成员函数下面简单实现一个元素同类型的栈结构如下所示使用方式如下如果上述只能传递和类型这时候就可以使用的方式猜实现约束泛型如下所示除了上述的形式泛型更高级的使用如下例如要设计一个函数这个函数接受两个参数一个参数为对象另一个参数为对象上的属性我们通过这两个参数返回这个属性的值这时候就设计到泛型的索引类型和约束类型共同实现索引类型约束类型索引类型把传入的对象的属性类型取出生成一个联合类型这里的泛型被约束在这个联合类型中如下所示上述为什么需要使用泛型约束而不是直接定义第一个参数为类型是因为默认情况指的是而我们接收的对象是各种各样的一个泛型来表示传入的对象类型比如使用如下图所示多类型约束例如如下需要实现两个接口的类型约束可以创建一个接口继承上述两个接口如下正确使用如下通过泛型约束就可以达到多类型约束的目的说说你对中高级类型的理解有哪些一是什么除了这种基础类型外在类型声明中还存在一些高级的类型应用这些高级类型是为了保证语言的灵活性所使用的一些语言特性这些特性有助于我们应对复杂多变的开发场景二有哪些常见的高级类型有如下交叉类型联合类型类型别名类型索引类型约束映射类型条件类型交叉类型通过将多个类型合并为一个类型包含了所需的所有类型的特性本质上是一种并的操作语法如下适用于对象合并场景如下将声明一个函数将两个对象合并成一个对象并返回联合类型联合类型的语法规则和逻辑或的符号一致表示其类型为连接的多个类型中的任意一个本质上是一个交的关系语法如下例如的类型只能是这三个的一种不能共存如下所示类型别名类型别名会给一个类型起个新名字类型别名有时和接口很像但是可以作用于原始值联合类型元组以及其它任何你需要手写的类型可以使用的语法来创建类型别名不能将类型分配给类型此外类型别名可以是泛型也可以使用类型别名来在属性里引用自己可以看到类型别名和接口使用十分相似都可以描述一个对象或者函数两者最大的区别在于只能用于定义对象类型而的声明方式除了对象之外还可以定义交叉联合原始类型等类型声明的方式适用范围显然更加广泛类型索引类似于用于获取一个接口中的联合类型等效于类型约束通过关键字进行约束不同于在后使用的继承作用泛型内使用的主要作用是对泛型加以约束这里表示的参数只能是字符串数字布尔这几种基础类型类型约束通常和类型索引一起使用例如我们有一个方法专门用来获取对象的值但是这个对象并不确定我们就可以使用和进行约束映射类型通过关键字做类型的映射遍历已有接口的或者是遍历联合类型如下例子上述的结构可以分成这些步骤通过类型索引的得到联合类型等同于相当于执行了一次的逻辑遍历所以最终的接口为下述条件类型条件类型的语法规则和三元表达式一致经常用于一些类型不确定的情况上面的意思就是如果是的子集就是类型否则为类型三总结可以看到如果只是掌握了的一些基础类型可能很难游刃有余的去使用需要了解一些的高阶用法并且在版本的迭代中新增了很多功能需要不断学习与掌握说说你对装饰器的理解应用场景一是什么装饰器是一种特殊类型的声明它能够被附加到类声明方法访问符属性或参数上是一种在不改变原类和使用继承的情况下动态地扩展对象功能同样的本质也不是什么高大上的结构就是一个普通的函数的形式其实是的语法糖求值后必须也是一个函数它会在运行时被调用被装饰的声明信息做为参数传入二使用方式由于是一个实验性特性若要使用需要在文件启动如下装饰器的使用和基本一致类的装饰器可以装饰类方法属性参数访问器类装饰例如声明一个函数去给的属性添加年龄上述代码实际等同于以下形式上述可以看到当装饰器作为修饰类的时候会把构造器传递进去就是在每一个实例化对象上面添加一个属性方法属性装饰同样装饰器可以用于修饰类的方法这时候装饰器函数接收的参数变成了对象的原型方法的名称方法的属性描述符可以看到这三个属性实际就是的三个参数如果是类的属性则没有传递第三个参数如下例子声明装饰器修饰方法属性修改实例方法输出如下图所示参数装饰接收个参数分别是当前对象的原型参数的名称参数数组中的位置输入如下图访问器装饰使用起来方式与方法装饰一致如下装饰器工厂如果想要传递参数使装饰器变成类似工厂函数只需要在装饰器函数内部再函数一个函数即可如下执行顺序当多个装饰器应用于一个声明上将由上至下依次对装饰器表达式求值求值的结果会被当作函数由下至上依次调用例如如下输出三应用场景可以看到使用装饰器存在两个显著的优点代码可读性变强了装饰器命名相当于一个注释在不改变原有代码情况下对原来功能进行扩展后面的使用场景中借助装饰器的特性除了提高可读性之后针对已经存在的类可以通过装饰器的特性在不改变原有代码情况下对原来功能进行扩展说说对中命名空间与模块的理解区别一模块与一样任何包含顶级或者的文件都被当成一个模块相反地如果一个文件不带有顶级的或者声明那么它的内容被视为全局可见的例如我们在在一个工程下建立一个文件声明一个变量如下然后在另一个文件同样声明一个变量这时候会出现错误信息提示重复声明变量但是所处的空间是全局的如果需要解决这个问题则通过或者引入模块系统即可如下在中关键字可以导出变量或者类型用法与模块一致如下通过引入模块如下二命名空间命名空间一个最明确的目的就是解决重名问题命名空间定义了标识符的可见范围一个标识符可在多个名字空间中定义它在不同名字空间中的含义是互不相干的这样在一个新的名字空间中可定义任何标识符它们不会与任何已有的标识符发生冲突因为已有的定义都处于其他名字空间中中命名空间使用来定义语法格式如下以上定义了一个命名空间如果我们需要在外部可以调用中的类和接口则需要在类和接口添加关键字使用方式如下命名空间本质上是一个对象作用是将一系列相关的全局变量组织到一个对象的属性如下编译成如下三区别命名空间是位于全局命名空间下的一个普通的带有名字的对象使用起来十分容易但就像其它的全局命名空间污染一样它很难去识别组件之间的依赖关系尤其是在大型的应用中像命名空间一样模块可以包含代码和声明不同的是模块可以声明它的依赖在正常的项目开发过程中并不建议用命名空间但通常在通过文件标记库类型的时候使用命名空间主要作用是给编译器编写代码的时候参考使用说说如何在项目中应用说说如何在项目中应用说说你对的理解优缺点应用场景说说有哪些全局对象说说对中的的理解有哪些常用方法说说对中的模块的理解有哪些常用方法说说对中的的理解应用场景说说对中的的理解应用场景说说中的如何实现一个说说对中的事件循环机制理解说说文件查找的优先级以及方法的文件查找策略说说对中间件概念的理解如何封装中间件如何实现鉴权机制说说你的思路如何实现文件上传说说你的思路如果让你来设计一个分页功能你会怎么设计前后端如何交互性能如何进行监控以及优化项目项目中有封装过吗主要是封装哪些方面有的主要就是随着项目规模的增大为了方便管理和维护我们的代码提高代码质量在项目中都会对进行一个二次封装在封装的同时需要和后端进行协商好请求参数状态码和请求的超时时间主要有以下的几个方面设置接口请求前缀利用环境变量来判断区分开发测试生产的不同环境在我们本地调试的时候如果后端没有开启跨域我们就需要在配置文件中进行配置代理转发从而实现跨域请求请求头在请求头里面有的一些业务必须要携带或者是其他的参数才可以请求就需要对请求的配置对象在请求数据时携带上这样就不用每次请求数据时还要去手动加上状态码根据接口返回的不同来执行不同的业务这块需要和后端约定好请求拦截器依据请求头的请求设定来决定哪些请求是可以访问的响应拦截器这块就是根据后端返回的状态码执行不同的业务封装请求方法先把实例引入进来在把不同的请求方法用一个函数保存起来最后对外暴露出去然后在需要使用该请求方法的页面导入直接调用即可可以把所有的有相同业务逻辑的请求方法写在一个文件夹里面就比如说要做权限的业务就可以把所有的请求方法放在一个的文件里面做薪资管理的就可以把所有的请求方法放在一个的文件里面方便后期的统一管理和维护项目中跨域问题的解决跨域本质是浏览器基于同源策略的一种安全手段同源策略是一种约定它是浏览器最核心也最基本的安全功能所谓同源即指在同一个域具有以下三个相同点协议相同主机相同端口相同反之非同源请求也就是协议端口主机其中一项不相同的时候这时候就会产生跨域一定要注意跨域是浏览器的限制你用抓包工具抓取接口数据是可以看到接口已经把数据返回回来了只是浏览器的限制你获取不到数据用请求接口能够请求到数据这些再次印证了跨域是浏览器的限制二如何解决解决跨域的方法有很多下面列举了三种而在项目中我们主要针对或这两种方案进行展开跨域资源共享是一个系统它由一系列传输的头组成这些头决定浏览器是否阻止前端代码获取跨域请求的响应实现起来非常方便只需要增加一些头让服务器能声明允许的访问来源只要后端实现了就实现了跨域代理也称网络代理是一种特殊的网络服务允许一个一般为客户端通过这个服务与另一个网络终端一般为服务器进行非直接的连接一些网关路由器等网络设备具备网络代理功能一般认为代理服务有利于保障网络终端的隐私或安全防止攻击方案一如果是通过脚手架工具搭建项目我们可以通过为我们起一个本地服务器作为请求的代理对象通过该服务器转发请求至目标服务器得到结果再转发给前端但是最终发布上线时如果应用和接口服务器不在一起仍会跨域在文件新增以下代码项目启动时自动打开浏览器是代理标识用于告诉前面是的就是使用代理的目标地址一般是指后台服务器地址是否跨域的作用是把实际中的用代替通过发送请求中配置请求的根路径方案二此外还可通过服务端实现代理请求转发以框架为例方案三通过配置实现代理本地开发完后部署到服务器后是什么原因当我们进入到子路由时刷新页面容器没有相对应的页面此时会出现所以我们只需要配置将任意页面都重定向到把路由交由前端处理对配置文件修改添加修改完配置文件后记得配置的更新这么做以后你的服务器就不再返回错误页面因为对于所有路径都会返回文件项目中的错误处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-09 00:46:33',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">DL Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>7</sup></a><a href="/tags/ajax/" style="font-size: 1.05rem;">ajax<sup>1</sup></a><a href="/tags/alist/" style="font-size: 1.05rem;">alist<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>2</sup></a><a href="/tags/css%E5%B8%83%E5%B1%80/" style="font-size: 1.05rem;">css布局<sup>1</sup></a><a href="/tags/git/" style="font-size: 1.05rem;">git<sup>2</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>1</sup></a><a href="/tags/http/" style="font-size: 1.05rem;">http<sup>1</sup></a><a href="/tags/react/" style="font-size: 1.05rem;">react<sup>1</sup></a><a href="/tags/vue/" style="font-size: 1.05rem;">vue<sup>3</sup></a><a href="/tags/web-api/" style="font-size: 1.05rem;">web api<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 1.05rem;">日常<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>1</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F-windows/" style="font-size: 1.05rem;">系统 windows<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" style="font-size: 1.05rem;">面试经验<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">七月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/05/"><span class="card-archive-list-date">五月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试经验</span></a></span></div></div><h1 class="post-title" itemprop="name headline">前端常见面试题合集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-01-13T16:00:00.000Z" title="发表于 2023-01-14 00:00:00">2023-01-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-08-08T16:46:33.235Z" title="更新于 2024-08-09 00:46:33">2024-08-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">57.9k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>200分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为信阳"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>信阳</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202311142355783.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/posts/7986f38c.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" tabindex="-1" itemprop="url">面试经验</a><h1 id="CrawlerTitle" itemprop="name headline">前端常见面试题合集</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">dleei</span><time itemprop="dateCreated datePublished" datetime="2023-01-13T16:00:00.000Z" title="发表于 2023-01-14 00:00:00">2023-01-14</time><time itemprop="dateCreated datePublished" datetime="2024-08-08T16:46:33.235Z" title="更新于 2024-08-09 00:46:33">2024-08-09</time></header><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="对vue的理解"><a href="#对vue的理解" class="headerlink" title="对vue的理解"></a>对vue的理解</h2><p>Vue.js（&#x2F;vjuː&#x2F;，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。Vue所关注的核心是MVC模式中的视图层,由数据驱动视图,把重点放在操作数据上</p>
<p>1.vue的核心特征就是主要有三点</p>
<p>数据驱动,所谓的数据驱动就是 mvvm (Model-View-ViewModel )</p>
<ul>
<li><p>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</p>
</li>
<li><p>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</p>
</li>
<li><p>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁</p>
<p><strong>2.组件化开发</strong></p>
<p>把一整个页面拆成各个不同的组件,然后再整合在一起,实现各个功能,布局的隔离,降低整个系统的耦合度</p>
<p>调试方便,因为不同的功能布局是分离的在出现问题的时候就可以通过错误快速的定位源头,方便快捷的查找排查错误</p>
<p>提高可维护性和复用性,每个组件的职责是单一的</p>
<p><strong>3.丰富的指令系统</strong></p>
<p>指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<p>常用的vue指令有:</p>
<p><code>v-model</code>,双向数据绑定</p>
<p><code>v-on(@)</code>,监听事件</p>
<p><code>v-bind(:)</code>,绑定属性</p>
<p><code>v-for</code>:列表循环渲染</p>
<p><code>v-if</code>:条件渲染</p>
</li>
</ul>
<h2 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h2><p>前端路由的核心就是,访问不同的地址,对应切换不同的组件显示不同的内容,而不是重新加载刷新页面</p>
<p>vue-router就是把组件一一对应的映射到路由地址上,然后渲染出来</p>
<p>主要有三种模式</p>
<p>history 在url地址的后面是以 &#x2F; 分隔的,但是需要和后端配合进行配置,不然用户访问的页面就是404</p>
<p>hash 在url的后面是以 # 分隔的,比较丑,不美观,这也是路由的默认模式,一般会在开发的时候使用,在上线的时候可以把模式改为history好看一点</p>
<p>abstract 通常用于非浏览器环境，例如在服务器端渲染 (SSR) 中。</p>
<h2 id="什么是mvvm-优缺点"><a href="#什么是mvvm-优缺点" class="headerlink" title="什么是mvvm?优缺点"></a>什么是mvvm?优缺点</h2><p>MVVM 表示的是 <code>Model-View-ViewModel</code></p>
<ul>
<li><p>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</p>
</li>
<li><p>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</p>
</li>
<li><p>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁, ViewModel 负责监听 Model 的变化并更新 View,实现数据和视图之间的双向数据绑定,就像前面介绍vue的时候说的一样用户只需要把重点放在操作数据上面,而不是去操作dom</p>
</li>
</ul>
<h2 id="工厂函数与构造函数的区别"><a href="#工厂函数与构造函数的区别" class="headerlink" title="工厂函数与构造函数的区别"></a>工厂函数与构造函数的区别</h2><ol>
<li>工厂函数没有共享原型</li>
<li>工厂函数需要手动<code>return</code> </li>
<li>构造函数是通过<code>new</code>关键字创建</li>
</ol>
<h2 id="在vue2中是如何监听数组的变化"><a href="#在vue2中是如何监听数组的变化" class="headerlink" title="在vue2中是如何监听数组的变化"></a>在vue2中是如何监听数组的变化</h2><p>在<code>Vue2</code>中，<code>Vue</code>提供了一种称为”&#x3D;&#x3D;数组变异方法&#x3D;&#x3D;”的机制，用于监听数组的变化。这些变异方法包括 </p>
<p>1.<code>push</code>、数组尾部添加，返回修改i后数组长度</p>
<p>2.<code>pop</code>、数组尾部删除，返回删除的数据</p>
<p>3.<code>shift</code>、数组头部删除，返回删除的元素</p>
<p>4.<code>unshift</code>、数组头部添加，返回新数组长度</p>
<p>5.<code>splice</code>、删除数组任意位置元素</p>
<p><code>splice</code>(删除元素对应位置的索引,删除的个数[不填默认从头部开始删除],新增的元素)  ，返回值:删除的元素数组</p>
<p>6.<code>sort</code>   数组排序  </p>
<p>7.<code>reverse</code>  数组翻转</p>
<p>当你使用这些方法修改数组时，<code>Vue</code>能够检测到变化并及时更新视图</p>
<p><code>Vue</code>的数组变异方法通过重写数组的原型方法来实现。当你调用这些方法时，<code>Vue</code>会在修改数组之前和之后执行一些特定的逻辑，以便通知相关的依赖（比如视图）</p>
<p>以下是一个简单的例子，演示了如何在<code>Vue2</code>中监听数组的变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Vue Array Mutation&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;addItem&quot;&gt;Add Item&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [1, 2, 3]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addItem: function() &#123;</span><br><span class="line">      this.items.push(this.items.length + 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，当点击按钮时，<code>addItem</code> 方法会使用数组变异方法 <code>push</code> 向 <code>items</code> 数组中添加一个新的元素。由于<code>Vue</code>监听了这个数组的变化，它会在数组被修改后自动更新相关的视图，使新的元素在页面上显示出来。</p>
<p>需要注意的是，<code>Vue</code>对数组变异的监听仅限于这些特定的数组变异方法，直接通过索引修改数组的元素或修改 <code>length</code> 属性的方式是无法被Vue检测到的。如果你需要监听这些非变异操作，可以使用 <code>Vue.set</code> 方法或 <code>vm.$set</code> 方法</p>
<h2 id="有没有了解虚拟列表"><a href="#有没有了解虚拟列表" class="headerlink" title="有没有了解虚拟列表"></a>有没有了解虚拟列表</h2><p>虚拟列表（Virtual List）是一种优化长列表渲染性能的技术。当需要展示大量数据时，传统的方式是将所有数据都渲染到DOM中，这可能导致页面加载缓慢、占用大量内存和性能下降。虚拟列表通过只渲染用户当前可见的部分数据，以及根据滚动位置动态加载和卸载列表项，来减轻这些问题。</p>
<p>基本思想是只渲染视口（可见区域）内的数据项，而不是整个数据集。这可以通过以下几个关键概念来实现：</p>
<ol>
<li><strong>可视区域（Viewport）：</strong> 用户当前看到的部分页面。在虚拟列表中，只有可视区域内的数据项会被真正渲染到DOM中。</li>
<li><strong>滚动监听：</strong> 监听滚动事件，以确定用户浏览的位置。当用户滚动时，虚拟列表会相应地更新可视区域的内容。</li>
<li><strong>动态加载和卸载：</strong> 根据滚动位置，动态加载进入可视区域的数据项，同时卸载离开可视区域的数据项，以保持DOM的轻量级。</li>
</ol>
<p>虚拟列表的优势在于减少了初始加载时的渲染压力，提高了页面的响应速度。这对于处理大型数据集的情况非常有用，比如在前端框架 （如Vue、React等）中使用虚拟列表来渲染大量的列表数据。</p>
<p>实现虚拟列表的方式可以有多种，具体的实现可能依赖于所用的前端框架或库。许多现代前端框架都提供了虚拟列表的支持或者有相关的第三方库。</p>
<h2 id="vue2中element-ui的自动按需导入"><a href="#vue2中element-ui的自动按需导入" class="headerlink" title="vue2中element-ui的自动按需导入"></a>vue2中element-ui的自动按需导入</h2><h3 id="1-安装-babel-plugin-import-插件"><a href="#1-安装-babel-plugin-import-插件" class="headerlink" title="1. 安装 babel-plugin-import 插件"></a>1. 安装 babel-plugin-import 插件</h3><p>在项目中安装 <code>babel-plugin-import</code> 插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-import -D</span><br></pre></td></tr></table></figure>

<h3 id="2-配置-babelrc-文件"><a href="#2-配置-babelrc-文件" class="headerlink" title="2. 配置 .babelrc 文件"></a>2. 配置 <code>.babelrc</code> 文件</h3><p>在项目根目录下创建 <code>.babelrc</code> 文件，配置插件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;import&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;element-ui&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-在-main-js-中引入-Element-UI-样式"><a href="#3-在-main-js-中引入-Element-UI-样式" class="headerlink" title="3. 在 main.js 中引入 Element UI 样式"></a>3. 在 main.js 中引入 Element UI 样式</h3><p>在你的 <code>main.js</code> 文件中引入 Element UI 的样式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="libraryName-配置"><a href="#libraryName-配置" class="headerlink" title="libraryName 配置"></a>libraryName 配置</h3><p><code>libraryName</code> 选项通常用于指定按需加载的组件库的名称。对于 <code>babel-plugin-import</code> 插件，它的配置对象中还有一些其他可用的选项，可以根据需要进行配置。以下是一些常见的选项：</p>
<ol>
<li><strong>libraryName (字符串，必需)</strong>: 用于指定要按需加载的组件库的名称，即插件将按照这个名称来寻找组件并进行按需加载。</li>
<li><strong>libraryDirectory (字符串，默认为 “lib”)</strong>: 用于指定组件库源代码的目录，通常是包含组件定义的目录。这是相对于组件库的主目录的路径。</li>
<li><strong>style (布尔值或函数，默认为 true)</strong>: 是否同时导入样式文件。如果设置为 <code>true</code>，插件将尝试导入样式文件；如果设置为 <code>false</code>，则只导入 JavaScript 文件。你还可以提供一个函数，根据需要返回样式文件路径。</li>
<li><strong>camel2DashComponentName (布尔值，默认为 true)</strong>: 是否将组件名从驼峰式转为短横线形式。例如，<code>MyComponent</code> 可以被转换为 <code>my-component</code>。</li>
</ol>
<p>这里是一个示例配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;element-ui&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;libraryDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;camel2DashComponentName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载实现"><a href="#图片懒加载实现" class="headerlink" title="图片懒加载实现"></a>图片懒加载实现</h2><ol>
<li><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用<code>HTML5</code> 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p>
<p>注意：<code>data-xxx</code> 中的xxx可以自定义，这里我们使用<code>data-src</code>来定义。</p>
<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>
<p>使用原生<code>JavaScript</code>实现懒加载：<br>知识点：<br>（1）<code>window.innerHeight</code> 是浏览器可视区的高度<br>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离<br>（3）<code>imgs.off</code>Set<code>Top</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）<br>（4）图片加载条件：<code>img.offSetTop &lt; window.innerHeight + document.body.scrollTop;</code></p>
</li>
</ol>
<h2 id="vue-cli基于webpack底层封装了mode-环境变量配置-开发或是生产环境-可以实现手动配置选项覆盖"><a href="#vue-cli基于webpack底层封装了mode-环境变量配置-开发或是生产环境-可以实现手动配置选项覆盖" class="headerlink" title="vue-cli基于webpack底层封装了mode,环境变量配置(开发或是生产环境),可以实现手动配置选项覆盖"></a>vue-cli基于webpack底层封装了mode,环境变量配置(开发或是生产环境),可以实现手动配置选项覆盖</h2><h2 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h2><ol>
<li>!important（在属性后面写上这条样式，会覆盖掉页面上任何位置定义的元素的样式。）</li>
<li>行内样式，在style属性里面写的样式。</li>
<li>id选择器</li>
<li>class选择器</li>
<li>标签选择器</li>
<li>通配符选择器</li>
<li>浏览器的自定义属性和继承</li>
</ol>
<h3 id="可继承的属性有哪些"><a href="#可继承的属性有哪些" class="headerlink" title="可继承的属性有哪些"></a>可继承的属性有哪些</h3><p>以下是一些常见的可继承属性：</p>
<ol>
<li><strong>文本属性（Text Properties）</strong>：<ul>
<li><code>color</code>：文本颜色</li>
<li><code>font</code>：字体系列、字体大小等</li>
<li><code>font-family</code>：字体系列</li>
<li><code>font-size</code>：字体大小</li>
<li><code>font-style</code>：字体样式（正常、斜体等）</li>
<li><code>font-weight</code>：字体粗细</li>
</ul>
</li>
<li><strong>行高属性（Line Height Properties）</strong>：<ul>
<li><code>line-height</code>：行高</li>
</ul>
</li>
<li><strong>列表属性（List Properties）</strong>：<ul>
<li><code>list-style</code>：列表样式类型、位置等</li>
<li><code>list-style-type</code>：列表项标志的类型</li>
<li><code>list-style-position</code>：列表项标志的位置</li>
<li><code>list-style-image</code>：用作列表项标志的图像</li>
</ul>
</li>
<li><strong>表格布局属性（Table Layout Properties）</strong>：<ul>
<li><code>border-collapse</code>：表格边框的折叠方式</li>
<li><code>border-spacing</code>：表格边框的间距</li>
</ul>
</li>
<li><strong>用户界面属性（User Interface Properties）</strong>：<ul>
<li><code>cursor</code>：鼠标指针样式</li>
</ul>
</li>
<li><strong>可见性属性（Visibility Properties）</strong>：<ul>
<li><code>visibility</code>：元素的可见性</li>
</ul>
</li>
<li><strong>生成内容属性（Generated Content Properties）</strong>：<ul>
<li><code>content</code>：用于 ::before 和 ::after 伪元素的生成内容</li>
</ul>
</li>
<li><strong>光标属性（Cursors Properties）</strong>：<ul>
<li><code>cursor</code>：光标类型</li>
</ul>
</li>
</ol>
<p>需要注意的是，并非所有的属性都是可继承的。例如，<code>width</code>、<code>height</code>等尺寸相关的属性就不是可继承的</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol>
<li><p><strong>使用clearfix（清除浮动的伪元素）</strong>：</p>
<p>这是一种常见的清除浮动的方法，通过在父元素上应用伪元素清除浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>; <span class="comment">/* 兼容IE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在父元素上添加 <code>clearfix</code> 类，这样就会在父元素最后插入一个空的块级元素，该元素通过 <code>clear: both;</code> 规则清除浮动。</p>
</li>
<li><p><strong>使用overflow属性</strong>：</p>
<p>将父元素的 <code>overflow</code> 属性设置为 <code>auto</code> 或 <code>hidden</code> 也可以触发 BFC（块级格式化上下文），从而清除浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 或 overflow: auto; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设置会创建一个新的 BFC，使得父元素包含浮动的子元素。</p>
</li>
</ol>
<h3 id="盒子居中方法"><a href="#盒子居中方法" class="headerlink" title="盒子居中方法"></a>盒子居中方法</h3><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><h4 id="2-脱标-利用margin自动实现居中"><a href="#2-脱标-利用margin自动实现居中" class="headerlink" title="2.脱标,利用margin自动实现居中"></a>2.脱标,利用margin自动实现居中</h4><h4 id="3-利用位移和定位"><a href="#3-利用位移和定位" class="headerlink" title="3.利用位移和定位"></a>3.利用位移和定位</h4><p><strong>定位移动的距离参考的父级的大小</strong></p>
<p><strong>位移移动参考的距离是自己自身的大小</strong></p>
<p>利用父相子绝,向右位移50%,向下位移50%,因为定位参考的大小是父级,这时就会超出了</p>
<p>向上反方向位移自身大小的50%这时子盒子就会居中显示</p>
<h2 id="自定义指令的生命周期"><a href="#自定义指令的生命周期" class="headerlink" title="自定义指令的生命周期"></a>自定义指令的生命周期</h2><ol>
<li><p><strong>bind:</strong></p>
<ul>
<li>当指令被第一次绑定到元素时触发。在这个阶段，你可以执行一次性的初始化设置。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">bind</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在绑定时执行一次性的初始化设置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>inserted:</strong></p>
<ul>
<li>当被绑定元素插入到 DOM 中时触发。通常用于执行初始化操作，比如获取焦点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在元素插入到 DOM 时执行初始化操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>update:</strong></p>
<ul>
<li>在包含组件的 VNode 更新时触发，但可能在其子 VNode 更新之前。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件的 VNode 更新时触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>componentUpdated:</strong></p>
<ul>
<li>在包含组件的 VNode 及其子 VNode 全部更新后触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">componentUpdated</span>(<span class="params">el, binding, vnode, oldVnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件的 VNode 及其子 VNode 全部更新后触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unbind:</strong></p>
<ul>
<li>在指令与元素解绑时触发。可以执行一些清理工作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;custom-directive&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">unbind</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="comment">// 在解绑时执行清理工作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>你在vue中给key添加一个属性,但是DOM没有刷新</p>
<ol>
<li><ul>
<li>如果你在对象或数组上新增属性或元素，Vue 也无法检测到变化。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">myArray</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">addElement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这样新增的元素不会触发响应式更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myArray</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong> 同样，使用 <code>Vue.set</code> 方法或者扩展运算符来确保变化被观察到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Vue.set</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="variable language_">this</span>.<span class="property">myArray</span>, <span class="variable language_">this</span>.<span class="property">myArray</span>.<span class="property">length</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用扩展运算符</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">myArray</span> = [...<span class="variable language_">this</span>.<span class="property">myArray</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol>
<li><p><strong>provide 选项：</strong></p>
<ul>
<li><code>provide</code> 选项允许你指定一个对象，其中包含你想要提供给后代组件的属性或方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParentComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello from parent!&#x27;</span>,</span><br><span class="line">    <span class="attr">showMessage</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>inject 选项：</strong></p>
<ul>
<li><code>inject</code> 选项用于接收祖先组件通过 <code>provide</code> 提供的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;showMessage&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">// &#x27;Hello from parent!&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showMessage</span>(); <span class="comment">// Alert: &#x27;Hello!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以使用对象语法来更详细地配置注入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: &#123; <span class="attr">default</span>: <span class="string">&#x27;Default message&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">showMessage</span>: &#123; <span class="attr">default</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>); <span class="comment">// &#x27;Hello from parent!&#x27; 或者 &#x27;Default message&#x27;（如果没有被提供）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showMessage</span>(); <span class="comment">// 执行提供的函数，或者是空函数（如果没有被提供）</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="前端路由两个形式"><a href="#前端路由两个形式" class="headerlink" title="前端路由两个形式"></a>前端路由两个形式</h2><p>hash</p>
<p>history</p>
<h2 id="给你一个数组实现去重"><a href="#给你一个数组实现去重" class="headerlink" title="给你一个数组实现去重"></a>给你一个数组实现去重</h2><ol>
<li><p><strong>使用 Set（ES6）:</strong></p>
<ul>
<li>Set 是一种集合类型，它只允许存储唯一的值，因此可以用来快速去重数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = [...<span class="keyword">new</span> <span class="title class_">Set</span>(array)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 filter 方法:</strong></p>
<ul>
<li>使用 <code>filter</code> 方法结合 <code>indexOf</code> 或 <code>includes</code> 方法来筛选出不重复的元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.<span class="title function_">indexOf</span>(value) === index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>includes</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.<span class="title function_">includes</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 reduce 方法:</strong></p>
<ul>
<li>使用 <code>reduce</code> 方法来构建一个新数组，只添加第一次出现的元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = array.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!accumulator.<span class="title function_">includes</span>(currentValue)) &#123;</span><br><span class="line">    accumulator.<span class="title function_">push</span>(currentValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Map 数据结构:</strong></p>
<ul>
<li>使用 Map 数据结构来存储数组中的唯一值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Map</span>(array.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> [item, item])).<span class="title function_">values</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(uniqueArray);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>computed计算属性具有&#x3D;&#x3D;缓存的特性&#x3D;&#x3D;,当我们初次访问的时候会把数据缓存起来,下次访问直接在缓存里面直接取,只有当依赖的数据发生变化时才会重新计算,它会返回一个经过&#x3D;&#x3D;计算之后的值&#x3D;&#x3D;,并且是只能&#x3D;&#x3D;执行同步任务&#x3D;&#x3D;</p>
<p>而watch起到的是一个观察的作用&#x3D;&#x3D;监听数据的变化&#x3D;&#x3D;,当监听的数据发生变化时就会,执行自定义的回调函数,它&#x3D;&#x3D;没有返回值&#x3D;&#x3D;,是可以&#x3D;&#x3D;执行异步任务&#x3D;&#x3D;,例如发起异步的ajax请求</p>
<h2 id="对SPA的理解"><a href="#对SPA的理解" class="headerlink" title="对SPA的理解"></a>对SPA的理解</h2><p>SPA（single-page application）翻译过来就是单页面应用程序,是一种网络应用程序或是网站的模型,它是通过动态的重写当前页面来实现与用户之间的交互,避免了页面之间的切换跳转打断用户的体验,所有页面上的资源和内容都是在用户点击访问的时候按需加载,在任何时候都不会重新加载页面</p>
<p>优点:</p>
<ul>
<li>有桌面应用端的快速访问的及时性和高效性</li>
<li>用户体验好,用户切换页面是不会重新加载整个页面</li>
<li>良好的前后端分离，分工更加明确</li>
</ul>
<p>缺点:</p>
<ul>
<li>首屏加载速度慢</li>
<li>只有一个html页面不利于seo搜索引擎抓取</li>
</ul>
<p>解决首屏加载慢问题</p>
<blockquote>
<p>1.减少入口文件的体积</p>
<p>2.静态资源本地缓存</p>
<p>3.ui框架的按需加载，不要使用全局导入</p>
<p>4.使用路由懒加载，只有在用户访问的时候才加载对应的页面内容</p>
<p>5.使用SSR,使用SSR可以在服务器端预先渲染页面，减少客户端渲染时间，提高页面加载速度和性能</p>
<p>6.组件重复打包,将SPA中重复使用的组件进行打包，避免重复加载相同的代码，减少服务器响应时间和带宽占用</p>
</blockquote>
<h2 id="v-show和v-if怎么理解"><a href="#v-show和v-if怎么理解" class="headerlink" title="v-show和v-if怎么理解"></a>v-show和v-if怎么理解</h2><p>都是依据条件来选择性的决定是否显示dom元素</p>
<p>v-show是通过动态的设置css的display: none&#x2F;block 来显示隐藏dom元素,dom元素还是在页面上的,占据位置</p>
<p>应用场景是页面的元素切换显示隐藏比较频繁,<strong>模态框的显示隐藏</strong></p>
<p>v-if是设置依据条件,创建或是销毁dom元素,销毁了后页面上是没有dom元素的,相较于v-show开销更加大</p>
<p>应用场景一般用在初始状态就是显示或是隐藏,在进入页面后**<font color="red">检查用户是否登录</font>**</p>
<h2 id="聊一聊vue的生命周期"><a href="#聊一聊vue的生命周期" class="headerlink" title="聊一聊vue的生命周期"></a>聊一聊vue的生命周期</h2><p>概念: vue实例从<font color="red">创建</font>到<font color="red">销毁</font>的整个过程就叫作生命周期</p>
<p>生命周期主要有四个阶段八个钩子函数分别是</p>
<table>
<thead>
<tr>
<th>生命周期钩子</th>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>创建前</td>
<td>组件实例还未创建,常用于插件开发的一些初始化任务</td>
</tr>
<tr>
<td>created</td>
<td>创建后</td>
<td>组件初始化完毕,可以获取数据使用,常用于发起ajax的异步数据请求</td>
</tr>
<tr>
<td>beforeMount</td>
<td>挂载前</td>
<td>dom已被初始化,但并未挂载和渲染</td>
</tr>
<tr>
<td>mounted</td>
<td>挂载后</td>
<td>dom已完成挂载和渲染,可用于访问数据和操作页面的dom元素</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>更新前</td>
<td>数据已被更新,但页面数据并未更新</td>
</tr>
<tr>
<td>updated</td>
<td>更新后</td>
<td>数据已更新完毕</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>销毁前</td>
<td>实例销毁前,实例目前实例仍然可用,常用于一些定时器的清除</td>
</tr>
<tr>
<td>destroyed</td>
<td>销毁后</td>
<td>实例已被销毁完毕</td>
</tr>
</tbody></table>
<h4 id="题外话-数据请求在created和mounted的区别"><a href="#题外话-数据请求在created和mounted的区别" class="headerlink" title="题外话:数据请求在created和mounted的区别"></a>题外话:数据请求在created和mounted的区别</h4><p><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成；<code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的。触发时机上<code>created</code>是比<code>mounted</code>要更早的</p>
<p>两者的相同点：都能拿到实例对象的属性和方法。</p>
<p>讨论这个问题本质就是触发的时机，放在<code>mounted</code>中的请求时间超时就会造成页面渲染阻塞或是造成白屏的状况（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中</p>
<h2 id="vue实例挂载的过程中发生了什么"><a href="#vue实例挂载的过程中发生了什么" class="headerlink" title="vue实例挂载的过程中发生了什么"></a>vue实例挂载的过程中发生了什么</h2><p>首先找到<code>vue</code>的构造函数</p>
<p>源码位置：<code>src</code>\core\instance\index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>options</code>是用户传递过来的配置项，如<code>data、methods</code>等常用的方法</p>
<p><code>vue</code>构建函数调用<code>_init</code>方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">initMixin</span>(<span class="title class_">Vue</span>);     <span class="comment">// 定义 _init</span></span><br><span class="line"><span class="title function_">stateMixin</span>(<span class="title class_">Vue</span>);    <span class="comment">// 定义 $`Set` $get $delete $watch 等</span></span><br><span class="line"><span class="title function_">eventsMixin</span>(<span class="title class_">Vue</span>);   <span class="comment">// 定义事件  $on  $once $off $emit</span></span><br><span class="line"><span class="title function_">lifecycleMixin</span>(<span class="title class_">Vue</span>);<span class="comment">// 定义 _update  $forceUpdate  $destroy</span></span><br><span class="line"><span class="title function_">renderMixin</span>(<span class="title class_">Vue</span>);   <span class="comment">// 定义 _render 返回虚拟dom</span></span><br></pre></td></tr></table></figure>

<p>首先可以看<code>initMixin</code>方法，发现该方法在<code>Vue</code>原型上定义了<code>_init</code>方法</p>
<p>源码位置：<code>src</code>\core\instance\init.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// a uid</span></span><br><span class="line">    vm.<span class="property">_uid</span> = uid++</span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="comment">// 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 合并vue属性</span></span><br><span class="line">      vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">        <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 初始化proxy拦截器</span></span><br><span class="line">      <span class="title function_">initProxy</span>(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm.<span class="property">_self</span> = vm</span><br><span class="line">    <span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">    <span class="comment">// 初始化组件事件侦听</span></span><br><span class="line">    <span class="title function_">initEvents</span>(vm)</span><br><span class="line">    <span class="comment">// 初始化渲染方法</span></span><br><span class="line">    <span class="title function_">initRender</span>(vm)</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    <span class="comment">// 初始化依赖注入内容，在初始化data、props之前</span></span><br><span class="line">    <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="comment">// 初始化props/data/method/watch/methods</span></span><br><span class="line">    <span class="title function_">initState</span>(vm)</span><br><span class="line">    <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">      vm.<span class="property">_name</span> = <span class="title function_">formatComponentName</span>(vm, <span class="literal">false</span>)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载元素</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">      vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读上面的代码，我们得到以下结论：</p>
<ul>
<li>在调用<code>beforeCreate</code>之前，数据初始化并未完成，像<code>data</code>、<code>props</code>这些属性无法访问到</li>
<li>到了<code>created</code>的时候，数据已经初始化完成，能够访问<code>data</code>、<code>props</code>这些属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li>
<li>挂载方法是调用<code>vm.$mount</code>方法</li>
</ul>
<p><code>initState</code>方法是完成<code>props/data/method/watch/methods</code>的初始化</p>
<p>源码位置：<code>src</code>\core\instance\state.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods方法</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们和这里主要看初始化<code>data</code>的方法为<code>initData</code>，它与<code>initState</code>在同一文件上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 获取到组件上的data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性名不能与方法名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性名不能与state名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 响应式监听data是数据的变化</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细阅读上面的代码，我们可以得到以下结论：</p>
<ul>
<li>初始化顺序：<code>props</code>、<code>methods</code>、<code>data</code></li>
<li><code>data</code>定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</li>
</ul>
<p>关于数据响应式在这就不展开详细说明</p>
<p>上文提到挂载方法是调用<code>vm.$mount</code>方法</p>
<p>源码位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 获取或查询元素</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// vue 不允许直接挂载到body或页面文档上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="variable language_">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 通过选择器获取元素内容</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  1.将temmplate解析ast tree</span></span><br><span class="line"><span class="comment">       *  2.将ast tree转换成render语法字符串</span></span><br><span class="line"><span class="comment">       *  3.生成render方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读上面代码，我们能得到以下结论：</p>
<ul>
<li>不要将根元素放到<code>body</code>或者<code>html</code>上</li>
<li>可以在对象中定义<code>template/render</code>或者直接使用<code>template</code>、<code>el</code>表示元素选择器</li>
<li>最终都会解析成<code>render</code>函数，调用<code>compileToFunctions</code>，会将<code>template</code>解析成<code>render</code>函数</li>
</ul>
<p>对<code>template</code>的解析步骤大致分为以下几步：</p>
<ul>
<li>将<code>html</code>文档片段解析成<code>ast</code>描述符</li>
<li>将<code>ast</code>描述符解析成字符串</li>
<li>生成<code>render</code>函数</li>
</ul>
<p>生成<code>render</code>函数，挂载到<code>vm</code>上后，会再次调用<code>mount</code>方法</p>
<p>源码位置：<code>src</code>\platforms\web\runtime\index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 渲染组件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用<code>mountComponent</code>渲染组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告</span></span><br><span class="line">  <span class="comment">// render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有获取到vue的模板文件</span></span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm.<span class="property">_name</span></span><br><span class="line">      <span class="keyword">const</span> id = vm.<span class="property">_uid</span></span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag)</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      <span class="title function_">mark</span>(endTag)</span><br><span class="line">      <span class="title function_">measure</span>(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// we `Set` this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="comment">// 监听当前组件状态，当有数据变化时，更新组件</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读上面代码，我们得到以下结论：</p>
<ul>
<li>会触发<code>beforeCreate</code>钩子</li>
<li>定义<code>updateComponent</code>渲染页面视图的方法</li>
<li>监听组件数据，一旦发生变化，触发<code>beforeUpdate</code>生命钩子</li>
</ul>
<p><code>updateComponent</code>方法主要执行在<code>vue</code>初始化时声明的<code>render</code>，<code>update</code>方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render`的作用主要是生成`vnode</span><br></pre></td></tr></table></figure>

<p>源码位置：<code>src</code>\core\instance\render.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义vue 原型上的render方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// render函数来自于组件的option</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">        vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">            _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">            vm.<span class="property">$slots</span>,</span><br><span class="line">            vm.<span class="property">$scopedSlots</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `Set` parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">        <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">        <span class="comment">// when parent component is patched.</span></span><br><span class="line">        currentRenderingInstance = vm</span><br><span class="line">        <span class="comment">// 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode</span></span><br><span class="line">        vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">        <span class="comment">// return error render result,</span></span><br><span class="line">        <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">        <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">                vnode = vm.<span class="property">_vnode</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vnode = vm.<span class="property">_vnode</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">                vm</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `Set` parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中</p>
<p>源码位置：<code>src</code>\core\instance\lifecycle.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">    <span class="comment">// 设置当前激活的作用域</span></span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = <span class="string">`Set`</span><span class="title class_">ActiveInstance</span>(vm)</span><br><span class="line">    vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      <span class="comment">// 执行具体的挂载逻辑</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">restoreActiveInstance</span>()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.<span class="property">__vue__</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">      vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">      vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h3><ul>
<li><code>new Vue</code>的时候调用会调用<code>_init</code>方法<ul>
<li>定义 <code>$</code>Set&#96;&#96;、<code>$get</code> 、<code>$delete</code>、<code>$watch</code> 等方法</li>
<li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off</code>等事件</li>
<li>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</li>
</ul>
</li>
<li>调用<code>$mount</code>进行页面的挂载</li>
<li>挂载的时候主要是通过<code>mountComponent</code>方法</li>
<li>定义<code>updateComponent</code>更新函数</li>
<li>执行<code>render</code>生成虚拟<code>DOM</code></li>
<li><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</li>
</ul>
<h2 id="为什么不建议v-for和v-if一起用"><a href="#为什么不建议v-for和v-if一起用" class="headerlink" title="为什么不建议v-for和v-if一起用"></a>为什么不建议v-for和v-if一起用</h2><p>v-if用于条件性的渲染页面dom元素</p>
<p>v-for遍历数组循环渲染列表数据</p>
<p>v-for的优先级比v-if要高,会先执行页面的循环渲染再依据v-if的条件选择性的渲染对应的元素,若是初次v-for循环渲染的时候有不符合条件的元素就会被渲染出来再依据v-if的条件来判断是否删除和创建元素,这样就会造成不必要的性能损耗</p>
<p>所以永远不要把v-if和v-show放在同一个元素上</p>
<p>如果必须要使用可以使用<strong>计算属性</strong>先把每个元素依据条件过滤一遍再执行渲染</p>
<h2 id="为什么data属性是一个函数而不是对象"><a href="#为什么data属性是一个函数而不是对象" class="headerlink" title="为什么data属性是一个函数而不是对象"></a>为什么data属性是一个函数而不是对象</h2><p>保持<strong>数据私有化</strong>,<strong>避免数据污染</strong>,如果data是一个普通的对象,当你创建多个相同的组件实例的时候,他们就会共享同一个数据对象,当你修改其中一个组件实例的数据是另外一个也会被修改,这样就会造成影响</p>
<p>如果是一个函数,当组件被创建的时候,函数被调用,返回的是一个新的数据对象,这样每一个组件的初始数据都是不一样的,保持数据的一个私有化,修改一个另外一个不会被影响到</p>
<h2 id="组件间的通信方式"><a href="#组件间的通信方式" class="headerlink" title="组件间的通信方式"></a>组件间的通信方式</h2><p>组件通讯可以分为<strong>组件</strong>和<strong>通讯</strong>两部分来理解</p>
<p><strong>组件</strong>:每一个<code>.vue</code>文件都可以理解为是一个组件</p>
<p><strong>通讯</strong>:是指以某种方式或是以某种手段来实现信息的传递或者是交互</p>
<p>每一个vue文件都有<strong>自己独立的作用域</strong>,组件之间的数据无法实现数据之间的共享,而我们在开发的时候有这种需求,组件通讯的目的就是实现<strong>组件之间数据的共享</strong>,把各个组件构成一个完整的有机的整体</p>
<p>组件之间的关系主要有<strong>父子关系</strong>和<strong>非父子</strong>关系</p>
<h3 id="父子组件之间的通讯"><a href="#父子组件之间的通讯" class="headerlink" title="父子组件之间的通讯"></a>父子组件之间的通讯</h3><h4 id="父向子传值"><a href="#父向子传值" class="headerlink" title="父向子传值"></a>父向子传值</h4><p>父向子传递父组件绑定一个自定义属性向子组件传递数据，子组件就可以使用props属性接收到传递过来的数据，进行页面渲染</p>
<h4 id="子向父传值"><a href="#子向父传值" class="headerlink" title="子向父传值"></a>子向父传值</h4><p>子向父传递数据使用$emit触发一个自定义事件，并传递数据，父组件监听到这个自定义事件就可以获取到这个数据，来操作获取到的数据</p>
<h3 id="非父子组件之间的传值"><a href="#非父子组件之间的传值" class="headerlink" title="非父子组件之间的传值"></a>非父子组件之间的传值</h3><h3 id="兄弟之间"><a href="#兄弟之间" class="headerlink" title="兄弟之间"></a>兄弟之间</h3><p>事件总线<code>eventbus</code>，一方传递数据<code>$emit</code>触发自定义事件并携带数据，另一方就可以使用<code>$on</code>监听到自定义事件和传递过来的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent</span><br></pre></td></tr></table></figure>

<h3 id="复杂组件"><a href="#复杂组件" class="headerlink" title="复杂组件"></a>复杂组件</h3><p>复杂的组件之间的通信推荐使用vuex,开发实际中使用的也是比较多的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">parent$emit</span>()</span><br></pre></td></tr></table></figure>

<h2 id="vue双向绑定的理解及原理"><a href="#vue双向绑定的理解及原理" class="headerlink" title="vue双向绑定的理解及原理"></a>vue双向绑定的理解及原理</h2><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数 据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>主要分为以下几 个步骤：</p>
<ol>
<li><p>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会 触发 setter，那么就能监听到了数据变化</p>
</li>
<li><p>compile 解析模板指令，将模板中的变量替换成数据，然后初始化 渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数 据的订阅者，一旦数据有变动，收到通知，更新视图 </p>
</li>
<li><p>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做 的事情是:</p>
</li>
</ol>
<p> ①在自身实例化时往属性订阅器(dep)里面添加自己 </p>
<p>② 自身必须有一个 update()方法 ③待属性变动 dep.notice()通知时， 能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</p>
<ol start="4">
<li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果</li>
</ol>
<h2 id="谈谈你对-nextTick-的理解"><a href="#谈谈你对-nextTick-的理解" class="headerlink" title="谈谈你对 $nextTick 的理解"></a>谈谈你对 $nextTick 的理解</h2><p>vue在更新dom的时候是异步的,当数据发生变化的时候就会开启一个<strong>异步更新队列</strong>,页面视图需要等待队列中所有的<strong>数据完成变化之后再统一进行更新</strong></p>
<p>如果没有<code>$nextTick</code>那么每次修改数据都会触发页面视图的更新,有了<code>$nextTick</code>机制就只需要更新一次,本质上也是对性能的一种优化策略</p>
<p>使用场景:在<strong>修改数据后想要立即得到修改后的dom元素</strong>,或者是<strong>一进入页面就要对搜索框获取到焦点</strong>,就可以使用</p>
<h2 id="slot的理解，应用场景"><a href="#slot的理解，应用场景" class="headerlink" title="slot的理解，应用场景"></a>slot的理解，应用场景</h2><p>slot艺名叫做插槽，花名“占坑”，可以对组件内容进行个性化的diy定制，当我们使用组件的时候不会所有的组件的内容都是符合我们业务的需求，这个时候我门就需要使用插槽来完成我们的开发需求</p>
<p>应用场景</p>
<p>当我们的父组件在使用一个复用组件的时候，仅仅只需要修改一小部分内容，那我们再去重写一个一样的显然是不明智的，通过slot插槽向不同的位置分发不同的内容，实现组件在不同场景下的应用</p>
<p>三种插槽</p>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>在子组件内使用slot标签来占位置，也可以在slot的标签内写入内容，这会作为标签的后备内容，如果父组件没有传递内容，就会显示设置的默认值，</p>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>顾名思义就是有名字的插槽</p>
<p>在子组件上使用name属性给插槽起一个名字（不填为默认插槽），父组件在分发内容的使用，v-slot&#x3D;属性名，来向子组件内分发指定的内容</p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽其实就时可以带数据的插槽,即可以携带参数的插槽</p>
<p>简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内容。</p>
<p><strong>基本使用步骤:</strong></p>
<ol>
<li>在子组件的 slot 标签上使用自定义属性,携带数据传递给父组件</li>
<li>父组件使用 template 配合 v-slot 获取传递过来的数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    &lt;td&gt;</span><br><span class="line">       &lt;!-- </span><br><span class="line">         注意: :item 相当于往插槽上加了一个自定义属性, 最终以对象包裹属性的形式传递过去</span><br><span class="line">         例如: 此处传过去的数据格式 &#123; item: item, index: index &#125;</span><br><span class="line">          --&gt;</span><br><span class="line">       &lt;slot :index=&quot;index&quot; :item=&quot;item&quot;&gt;&lt;/slot&gt;</span><br><span class="line">     &lt;/td&gt;</span><br><span class="line">&lt;MyTable :data=&quot;list&quot;&gt;</span><br><span class="line">   &lt;!-- </span><br><span class="line">     定义形参接收</span><br><span class="line">     插槽默认名字叫 default</span><br><span class="line">     可以简写为 #default=&quot;变量名&quot;,这个变量名保存的是由子组件传递过来的数据,</span><br><span class="line">     //一般通常情况下直接在这里对传递过来的对象进行解构操作,方便后面的使用</span><br><span class="line">     如果不用 # 也可以不指定名字, 直接写为 v-slot=&quot;变量名&quot;</span><br><span class="line">    --&gt;</span><br><span class="line">     完整写法: v-slot:default = &#x27;变量名&#x27;</span><br><span class="line">     简写形式: #default = &#x27;变量名&#x27;</span><br><span class="line">     不指定插槽名,接收数据:v-solt = &#x27;变量名&#x27; // 对象解构 v-solt = &#123; 属性名1,属性名2 , ...&#125;</span><br><span class="line">   &lt;template v-slot=&quot;scope&quot;&gt;</span><br><span class="line">     &lt;button @click=&quot;del(scope.item.id)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line"> &lt;/MyTable&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue-observable-你有了解过吗？"><a href="#vue-observable-你有了解过吗？" class="headerlink" title="vue.observable 你有了解过吗？"></a>vue.observable 你有了解过吗？</h2><h2 id="对vue中key的理解"><a href="#对vue中key的理解" class="headerlink" title="对vue中key的理解"></a>对vue中key的理解</h2><p>v-for数组循环列表给每一项添加一个唯一标识,主要是为了更加高效的更新dom元素,在没有key属性的时候,更新和改变数据的时候会将整个列表全部重新渲染,浪费性能</p>
<p>v-for默认采用的是就地复用的原则,当列表数据发生变化的时候,他会根据key属性去判断某一项到底是不是需要被修改,如果需要修改就直接渲染这一项否则就会复用之前的</p>
<h2 id="对keep-alive的理解，如何缓存当前组件、缓存后如何更新"><a href="#对keep-alive的理解，如何缓存当前组件、缓存后如何更新" class="headerlink" title="对keep-alive的理解，如何缓存当前组件、缓存后如何更新"></a>对keep-alive的理解，如何缓存当前组件、缓存后如何更新</h2><p>路由之间在切换的时候对应的组件就会被销毁和创建,这样就会导致状态丢失,keep-alive主要目的就是保持组件的状态,确保组件在销毁时不会丢失数据和状态而是把它缓存起来</p>
<p>使用:</p>
<p>使用<keep-alive>标签包裹需要缓存的组件即可</p>
<p>有三个属性:</p>
<ol>
<li>include:组件名数组,只有被匹配中的组件才会被缓存起来</li>
<li>exclude:组件名数组,任何被匹配中的组件都不会被缓存</li>
<li>max ,数字,最多缓存多少组件</li>
</ol>
<p>keep-alive会触发两个生命周期函数</p>
<ol>
<li>activated,在进入组件的时候触发</li>
<li>deactivated,在离开组件的时候触发</li>
</ol>
<p>组件在被缓存后就不会有created,beforemount,mounted 钩子函数了,只会有在进入页面的时候的那一次,所以提供了activated和deactivated钩子函数来帮我们实现业务需求</p>
<h3 id="keep-alive原理"><a href="#keep-alive原理" class="headerlink" title="keep alive原理"></a>keep alive原理</h3><h2 id="vue常用修饰符，应用场景"><a href="#vue常用修饰符，应用场景" class="headerlink" title="vue常用修饰符，应用场景"></a>vue常用修饰符，应用场景</h2><p>表单修饰符</p>
<p><code>.lazy</code></p>
<p><code>.trim</code> 去除表单首尾的空格</p>
<p><code>.number</code> 将用户输入的值转换为数字类型</p>
<p>事件修饰符</p>
<p><code>.stop</code>  阻止事件冒泡</p>
<p><code>.prevent</code>  阻止默认行为</p>
<p><code>.once</code>  绑定事件后只会触发一次</p>
<p>按键修饰符</p>
<p><code>.enter</code></p>
<p><code>.tab</code></p>
<p><code>.esc</code></p>
<p>….</p>
<p><code>v-bind</code>修饰符</p>
<p><code>.sync</code>   数据的双向绑定</p>
<h2 id="你有写过自定义指令吗？应用场景"><a href="#你有写过自定义指令吗？应用场景" class="headerlink" title="你有写过自定义指令吗？应用场景"></a>你有写过自定义指令吗？应用场景</h2><p><code>vue</code>的核心就是由数据驱动视图，为了方便的实现数据驱动视图，<code>vue</code>设计了一些内置的由v-开头的指令来实现不同的功能。像常用的有<code>v-model</code>的双向数据绑定，<code>v-bind</code>的数据绑定，<code>v-if</code>，<code>v-else</code>的数据的条件渲染等等</p>
<p>但是有的时候并不是所有的指令都满足我们的需求，<code>vue</code>也是支持我们自己自定义指令的，实现个性化的需求</p>
<p>组件的注册又分为全局注册和局部注册</p>
<p>全局注册</p>
<p>全局注册在<code>main.js</code>里面使用<code>Vue.directive</code>方法进行注册，该方法会接受两个参数，一个是要自定义的指令的名字，一个是指令的配置对象配置对象里面会有一个<code>insered</code>指令的钩子函数会在被插入到<code>dom</code>树上时自动执行，并把绑定了该指令的对象传递过来，我们就可以对该元素进行一些你自己想要的一些自定义需求</p>
<p>局部注册</p>
<p>局部注册在组件的<code>options</code>选项中设置<code>directives</code>属性，和全局注册差不多，里面有自定义的指令名，和配置对象，等绑定了自定义指令的元素被插入到<code>dom</code>树上面的时候对它进行你自己想要的自定义操作</p>
<p>应用场景</p>
<p>封装一个<code>v-focus</code>在初始一进入页面时就获取到<code>input</code>框的一个焦点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.directive(指令名,配置对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// inserted() 是指令的钩子函数,被指令绑定了的元素会在被插入到 DOM 树上时自动执行</span></span><br><span class="line"><span class="comment">//执行时会将绑定该指令的元素传过来,然后就可以对其进行操作了</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者是封装一个v-throttle的一个阻止表单重复提交的一个自定义指令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cbFun;</span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!cbFun) &#123; <span class="comment">// 第一次执行</span></span><br><span class="line">        cbFun = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          cbFun = <span class="literal">null</span>;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>权限校验自定义指令</p>
<h2 id="vue中的过滤器了解过吗？应用场景"><a href="#vue中的过滤器了解过吗？应用场景" class="headerlink" title="vue中的过滤器了解过吗？应用场景"></a>vue中的过滤器了解过吗？应用场景</h2><h2 id="什么是虚拟DOM？如何实现一个虚拟DOM"><a href="#什么是虚拟DOM？如何实现一个虚拟DOM" class="headerlink" title="什么是虚拟DOM？如何实现一个虚拟DOM"></a>什么是虚拟DOM？如何实现一个虚拟DOM</h2><p>虚拟 DOM 的解析过程：</p>
<p> 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将 其表示出来，比如一个元素对象，包含 TagName、props 和 Children 70 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段 插入到文档中</p>
<p>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候， 首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象 树和旧的对象树进行比较，记录下两棵树的的差异</p>
<p> 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了</p>
<h2 id="了解diff算法吗？"><a href="#了解diff算法吗？" class="headerlink" title="了解diff算法吗？"></a>了解diff算法吗？</h2><p>在新老虚拟 DOM 对比时：</p>
<p> 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换 如果为相同节点，进行 patchVnode，判断如何对该节点的子节点进行处理</p>
<p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除) </p>
<p>比较如果都有子节点，则进行 updateChildren，判断如何对这些新 老节点的子节点进行操作（diff 核心）</p>
<p> 匹配时，找到相同的子节点，递归比较子节点 在 diff 中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从 O(n 3)降低值 O(n)，也就是说，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较</p>
<h2 id="vue2及vue3的区别"><a href="#vue2及vue3的区别" class="headerlink" title="vue2及vue3的区别"></a>vue2及vue3的区别</h2><ol>
<li><strong>性能优化：</strong><ul>
<li>Vue 3引入了响应式系统的重大改进，通过Proxy实现了更高效的响应式数据追踪，从而提高了性能。</li>
<li>Vue 3的编译器生成的代码更小，运行时性能更好，使应用程序加载更快。</li>
</ul>
</li>
<li><strong>Composition API：组合API：</strong><ul>
<li>Vue 3引入了<code>Composition API</code>，这是一种新的API风格，使得组件的逻辑更易于组织和重用。<code>Composition API</code>允许开发者按照功能划分代码，而不是像Vue 2那样按照选项的顺序。</li>
</ul>
</li>
<li><strong>全局 API的修改：</strong><ul>
<li>在Vue 3中，全局API发生了一些变化，例如<code>Vue.component</code>变成了<code>app.component</code>，<code>Vue.directive</code>变成了<code>app.directive</code>等。这是为了更好地支持模块化的开发方式。</li>
</ul>
</li>
<li><strong>Teleport：传送：</strong><ul>
<li>Vue 3引入了Teleport组件，用于更灵活地在DOM中的不同位置渲染组件，这在处理模态框等场景时非常有用。</li>
</ul>
</li>
<li><strong>Fragment和多根节点：</strong><ul>
<li>Vue 3允许组件返回多个根节点，而Vue 2要求组件有且只有一个根节点。Vue 3还引入了Fragment语法，使得在模板中使用多个根节点更加方便。</li>
</ul>
</li>
<li><strong>动态属性：</strong><ul>
<li>在Vue 3中，可以使用<code>v-bind</code>绑定动态的属性名，而在Vue 2中需要使用<code>v-bind</code>和<code>v-on</code>的结合来实现。</li>
</ul>
</li>
</ol>
<h2 id="vue项目本地开发完成后部署到服务器后报404是什么原因呢？"><a href="#vue项目本地开发完成后部署到服务器后报404是什么原因呢？" class="headerlink" title="vue项目本地开发完成后部署到服务器后报404是什么原因呢？"></a>vue项目本地开发完成后部署到服务器后报404是什么原因呢？</h2><p>项目使用<code>history</code>需要后端搭配进行配置,当我们在地址栏输入 <code>www.xxx.com</code> 时，这时会打开我们 <code>dist</code> 目录下的 <code>index.html</code> 文件，然后我们在跳转路由进入到 <code>www.xxx.com/login</code></p>
<p>关键在这里，当我们在 <code>website.com/login</code> 页执行刷新操作，<code>nginx location</code> 是没有相关配置的，所以就会出现 404 的情况</p>
<p>修改规则无论我们访问任何页面都会重定向到<code>index.html</code></p>
<h2 id="你是怎么处理vue项目中的错误的？"><a href="#你是怎么处理vue项目中的错误的？" class="headerlink" title="你是怎么处理vue项目中的错误的？"></a>你是怎么处理vue项目中的错误的？</h2><h2 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h2><p>1.加载渲染过程</p>
<p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p>
<p>2.子组件更新过程</p>
<p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
<p>3.父组件更新过程</p>
<p>父beforeUpdate-&gt;父updated</p>
<p>4.销毁过程</p>
<p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
<h2 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h2><p>在Vue中，你可以使用”watch”特性来监听对象或数组中某个属性的变化。对于对象，你可以使用<code>$watch</code>方法，而对于数组，你可以使用<code>$watch</code>方法或者直接使用<code>Vue.Set</code>来确保数组变动也被观察到。以下是一些示例：</p>
<h3 id="对象属性的监听"><a href="#对象属性的监听" class="headerlink" title="对象属性的监听"></a>对象属性的监听</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;Change Name&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        name: &#x27;John&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeName() &#123;</span><br><span class="line">      this.user.name = &#x27;Doe&#x27;; // 这里修改了对象的属性</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#x27;user.name&#x27;: function(newVal, oldVal) &#123;</span><br><span class="line">      console.log(`Name changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，通过<code>watch</code>选项，我们监听了<code>user.name</code>的变化。</p>
<h3 id="数组元素的监听"><a href="#数组元素的监听" class="headerlink" title="数组元素的监听"></a>数组元素的监听</h3><h4 id="使用-watch"><a href="#使用-watch" class="headerlink" title="使用 $watch"></a>使用 <code>$watch</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;button @click=&quot;changeItem(index)&quot;&gt;Change Item&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Cherry&#x27;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeItem(index) &#123;</span><br><span class="line">      this.$`Set`(this.items, index, &#x27;New Value&#x27;); // 使用$`Set`确保变化被观察</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    items: function(newVal, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;Array changed&#x27;, newVal, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Vue-Set"><a href="#使用-Vue-Set" class="headerlink" title="使用 Vue.Set"></a>使用 Vue.Set</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;button @click=&quot;changeItem(index)&quot;&gt;Change Item&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Cherry&#x27;]</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeItem(index) &#123;</span><br><span class="line">      Vue.Set(this.items, index, &#x27;New Value&#x27;); // 直接使用Vue.Set</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    items: function(newVal, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;Array changed&#x27;, newVal, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在这两个数组的例子中，我们通过<code>watch</code>选项监听了整个数组的变化。如果你需要监听特定元素的变化，你可以使用更深层次的属性路径，就像在对象属性监听的例子中一样。</p>
<h2 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h2><p>相同点： assets 和 static 两个都是存放静态资源文件。项目中所 需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下 </p>
<p>不相同点：assets 中存放的静态资源文件在项目打包时，也就是运 行 npm run build 时会将 assets 中放置的静态资源文件进行打包 上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后 的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。</p>
<p>static 中放置的静态资源文件就不会要走打包 压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。 因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也 就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据 更大的空间。</p>
<p> 建议： </p>
<p>将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包这一流程。减少体积。</p>
<p>而项目中引入的第三方的 资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这 些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>
<h2 id="VueRouter是什么-有那些组件"><a href="#VueRouter是什么-有那些组件" class="headerlink" title="VueRouter是什么, 有那些组件"></a>VueRouter是什么, 有那些组件</h2><h2 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h2><p>route相当于正在跳转的路由对象，可以从route里面获取[hash]，name ，path，query，matched等属性方法</p>
<p>router 是VueRouter的实例，router是一个全局的路由对象，里面有很多的属性和方法 ，比如：router.push,route.options等等</p>
<h2 id="路由开发的优缺点"><a href="#路由开发的优缺点" class="headerlink" title="路由开发的优缺点"></a>路由开发的优缺点</h2><p>优点：</p>
<p>● 整体不刷新页面，用户体验更好<br>● 数据传递容易, 开发效率高 </p>
<p>缺点：</p>
<p>●开发成本高(需要学习专门知识)<br>●首次加载会比较慢一点。不利于seo</p>
<h2 id="VueRouter的使用方式"><a href="#VueRouter的使用方式" class="headerlink" title="VueRouter的使用方式"></a>VueRouter的使用方式</h2><p>1使用Vue.use( )将VueRouter插入<br>2创建路由规则<br>3创建路由对象<br>4将路由对象挂到 Vue 实例上<br>5设置路由挂载点</p>
<h2 id="路由跳转有那些方式"><a href="#路由跳转有那些方式" class="headerlink" title="路由跳转有那些方式"></a>路由跳转有那些方式</h2><ol>
<li><p><strong>通过 <code>this.$router.push</code> 方法：</strong></p>
<ul>
<li>在Vue组件中，你可以通过<code>this.$router.push</code>方法进行编程式的导航。可以传递一个路径或一个描述地址的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 字符串路径</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/path&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>该方法会导致路由的切换，类似于用户点击浏览器的前进或后退按钮。</p>
</li>
<li><p><strong>通过 <code>this.$router.replace</code> 方法：</strong></p>
<ul>
<li>与<code>push</code>方法类似，但是不会留下历史记录，不会在浏览器的历史堆栈中创建新的记录。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>this.$router.go</code> 方法：</strong></p>
<ul>
<li>用于在浏览器的历史记录中前进或后退指定步数。可以传递一个负数表示后退，正数表示前进。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// 后退一步</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="number">1</span>);  <span class="comment">// 前进一步</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="编程式导航使用的方法以及常用的方法"><a href="#编程式导航使用的方法以及常用的方法" class="headerlink" title="编程式导航使用的方法以及常用的方法"></a>编程式导航使用的方法以及常用的方法</h2><ol>
<li><p><strong>使用 <code>$router.push</code>：</strong></p>
<ul>
<li><code>$router.push</code> 方法用于向 history 栈添加一个新的记录，然后导航到该记录。它接受一个字符串路径或一个描述地址的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 字符串路径</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/path&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>$router.replace</code>：</strong></p>
<ul>
<li><code>$router.replace</code> 方法与 <code>$router.push</code> 类似，但是它不会留下历史记录，而是替换当前的记录。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/path&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>$router.go</code>：</strong></p>
<ul>
<li><code>$router.go</code> 方法用于在浏览器的历史记录中前进或后退指定步数。可以传递一个负数表示后退，正数表示前进。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// 后退一步</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="number">1</span>);  <span class="comment">// 前进一步</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>$router.back</code> 和 <code>$router.forward</code>：</strong></p>
<ul>
<li><code>$router.back</code> 方法相当于 <code>$router.go(-1)</code>，用于后退一步。<code>$router.forward</code> 方法相当于 <code>$router.go(1)</code>，用于前进一步。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>();    <span class="comment">// 后退一步</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>(); <span class="comment">// 前进一步</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由的传参方式"><a href="#路由的传参方式" class="headerlink" title="路由的传参方式"></a>路由的传参方式</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA.png"></p>
<h2 id="路由重定向和404"><a href="#路由重定向和404" class="headerlink" title="路由重定向和404"></a>路由重定向和404</h2><p>1 匹配path后, 强制切换到另一个目标path上<br>2 redirect 是设置要重定向到哪个路由路径<br>3 网页默认打开, 匹配路由”&#x2F;“, 强制切换到”&#x2F;find”上<br>4 redirect配置项, 值为要强制切换的路由路径<br>5 强制重定向后, 还会重新来数组里匹配一次规则</p>
<h2 id="路由配置项常用的属性及作用"><a href="#路由配置项常用的属性及作用" class="headerlink" title="路由配置项常用的属性及作用"></a>路由配置项常用的属性及作用</h2><p>路由配置参数：</p>
<p> path : 跳转路径  </p>
<p> component : 路径相对于的组件   </p>
<p>name:命名路由   </p>
<p>children:子路由的配置参数(路由嵌套)   </p>
<p>props:路由解耦   </p>
<p>redirect : 重定向路由</p>
<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol>
<li><p><strong>全局前置守卫 (<code>beforeEach</code>)：</strong></p>
<ul>
<li><code>beforeEach</code> 全局前置守卫会在路由切换开始前被调用。可以用来进行一些全局的权限校验或导航控制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // 在路由切换前执行一些逻辑</span><br><span class="line">  if (to.meta.requiresAuth &amp;&amp; !auth.loggedIn) &#123;</span><br><span class="line">    next(&#x27;/login&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局解析守卫 (<code>beforeResolve</code>)：</strong></p>
<ul>
<li><code>beforeResolve</code> 全局解析守卫会在导航被确认之前，解析异步组件。它类似于 <code>beforeEach</code>，但是在全局后置守卫之前调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">  // 在导航被确认之前执行一些逻辑</span><br><span class="line">  // ...</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局后置守卫 (<code>afterEach</code>)：</strong></p>
<ul>
<li><code>afterEach</code> 全局后置守卫会在路由切换完成后被调用。可以用来进行一些清理或日志记录等操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // 在路由切换后执行一些逻辑</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>路由独享守卫 (<code>beforeEnter</code>)：</strong></p>
<ul>
<li><code>beforeEnter</code> 路由独享守卫可以直接在路由配置中定义，仅对该路由生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> const route = &#123;</span><br><span class="line">  path: &#x27;/example&#x27;,</span><br><span class="line">  component: Example,</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    // 在进入路由前执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组件内守卫 (<code>beforeRouteEnter</code>, <code>beforeRouteUpdate</code>, <code>beforeRouteLeave</code>)：</strong></p>
<ul>
<li>这些守卫钩子是在组件内部定义的。<code>beforeRouteEnter</code> 在路由进入时调用，<code>beforeRouteUpdate</code> 在路由更新时调用，<code>beforeRouteLeave</code> 在路由离开时调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">  beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">    // 在路由进入时执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, from, next) &#123;</span><br><span class="line">    // 在路由更新时执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, from, next) &#123;</span><br><span class="line">    // 在路由离开时执行一些逻辑</span><br><span class="line">    // ...</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="说说你对vuex的理解"><a href="#说说你对vuex的理解" class="headerlink" title="说说你对vuex的理解"></a>说说你对vuex的理解</h2><ol>
<li><strong>状态 (State):</strong><ul>
<li>Vuex 的核心就是一个全局的状态存储，即存放所有组件共享的数据。这些数据被称为状态 (state)，通常以一个 JavaScript 对象的形式存在。</li>
</ul>
</li>
<li><strong>状态的改变 (Mutations):</strong><ul>
<li>状态的变更必须通过 mutations 进行。mutations 是包含一系列对状态进行操作的方法。每个 mutation 都有一个字符串的事件类型 (type) 和一个回调函数，负责实际修改状态。</li>
</ul>
</li>
<li><strong>动作 (Actions):</strong><ul>
<li>Actions 用于处理异步操作，通过提交 mutations 来修改状态。Actions 提供了一种将业务逻辑和异步操作从组件中抽离的方式，使得代码更容易维护和测试。</li>
</ul>
</li>
<li><strong>模块 (Modules):</strong><ul>
<li>为了应对大型应用中的状态管理问题，Vuex 允许将 store 分割成模块 (modules)。每个模块可以有自己的 state、mutations、actions、getters，使得代码组织更加灵活。</li>
</ul>
</li>
<li><strong>Getter:</strong><ul>
<li>Getters 允许你在访问状态时进行一些计算，类似于 Vue 中的计算属性。它们对 store 中的状态进行派生，返回新的值。</li>
</ul>
</li>
<li><strong>单一状态树 (Single State Tree):</strong><ul>
<li>Vuex 使用单一状态树来存储整个应用的状态。这使得状态的变化变得可追踪，方便调试和查看整个应用的状态。</li>
</ul>
</li>
<li><strong>严格模式 (Strict Mode):</strong><ul>
<li>Vuex 提供了严格模式，可以在开发环境中检测状态的修改是否是通过 mutations 进行的。这有助于捕获在组件外部直接修改状态的错误。</li>
</ul>
</li>
<li><strong>插件 (Plugins):</strong><ul>
<li>Vuex 允许通过插件的方式扩展其功能。你可以编写插件来添加额外的特性，例如日志、持久化存储等。</li>
</ul>
</li>
</ol>
<h2 id="数据不响应的情况有哪些-如何解决"><a href="#数据不响应的情况有哪些-如何解决" class="headerlink" title="数据不响应的情况有哪些,如何解决"></a>数据不响应的情况有哪些,如何解决</h2><ol>
<li><p><strong>直接赋值：</strong></p>
<ul>
<li>如果你直接使用<code>=</code>对一个对象或数组进行赋值，Vue 无法检测到变化。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    myObject: &#123; key: &#x27;value&#x27; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  updateObject() &#123;</span><br><span class="line">    // 这样的赋值不会触发响应式更新</span><br><span class="line">    this.myObject = &#123; newKey: &#x27;newValue&#x27; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong> 使用 <code>Vue.Set</code> 方法或者扩展运算符 (…) 来确保对象的属性或数组的元素被观察到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 使用 Vue.`Set`</span><br><span class="line">Vue.`Set`(this.myObject, &#x27;newKey&#x27;, &#x27;newValue&#x27;);</span><br><span class="line"></span><br><span class="line">// 或者使用扩展运算符</span><br><span class="line">this.myObject = &#123; ...this.myObject, newKey: &#x27;newValue&#x27; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新增属性或元素：</strong></p>
<ul>
<li>如果你在对象或数组上新增属性或元素，Vue 也无法检测到变化。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    myArray: [1, 2, 3]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  addElement() &#123;</span><br><span class="line">    // 这样新增的元素不会触发响应式更新</span><br><span class="line">    this.myArray.push(4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong> 同样，使用 <code>Vue.Set</code> 方法或者扩展运算符来确保变化被观察到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 使用 Vue.`Set`</span><br><span class="line">Vue.set(this.myArray, this.myArray.length, 4);</span><br><span class="line"></span><br><span class="line">// 或者使用扩展运算符</span><br><span class="line">this.myArray = [...this.myArray, 4];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步更新问题：</strong></p>
<ul>
<li>当在一个异步操作中修改数据时，Vue 也可能无法立即检测到变化。例如，在回调函数中修改数据：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    message: &#x27;Hello&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  asyncUpdate() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      // 这样的修改可能无法触发响应式更新</span><br><span class="line">      this.message = &#x27;Updated Message&#x27;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong> 使用 <code>this.$nextTick</code> 来确保在下一次 DOM 更新循环中修改数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> asyncUpdate() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    this.$nextTick(() =&gt; &#123;</span><br><span class="line">      this.message = &#x27;Updated Message&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vue-use的原理"><a href="#vue-use的原理" class="headerlink" title="vue.use的原理"></a>vue.use的原理</h2><p><code>Vue.use</code> 是用来注册 Vue.js 插件的方法。当你使用 <code>Vue.use</code> 注册一个插件时，实际上它调用了插件的 <code>install</code> 方法。这个方法可以用来添加全局级别的功能，如全局组件、指令、过滤器，或者向Vue的原型中添加方法。</p>
<p>具体来说，<code>Vue.use</code> 的原理主要包括以下步骤：</p>
<ol>
<li><p><strong>检查插件是否已经被安装：</strong></p>
<ul>
<li><code>Vue.use</code> 方法内部会检查插件是否已经被安装，避免重复注册。</li>
</ul>
</li>
<li><p><strong>调用插件的 <code>install</code> 方法：</strong></p>
<ul>
<li>如果插件尚未安装，<code>Vue.use</code> 会调用插件的 <code>install</code> 方法。这个方法通常在插件的主文件中定义。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span>(<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 在这里添加全局功能</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>install</code> 方法的第一个参数是 Vue 构造函数，第二个参数是插件的选项。你可以在这个方法中添加全局组件、指令、过滤器，或者向Vue的原型中添加方法。</p>
</li>
<li><p><strong>标记插件已安装：</strong></p>
<ul>
<li>一旦插件的 <code>install</code> 方法被调用，<code>Vue.use</code> 会标记插件已经被安装，避免重复注册。</li>
</ul>
</li>
<li><p><strong>全局注册组件、指令、过滤器：</strong></p>
<ul>
<li>在 <code>install</code> 方法中，你可以利用 Vue 的 API 全局注册组件、指令、过滤器。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span>(<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, <span class="title class_">MyComponent</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册指令</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, <span class="title class_">MyDirective</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册过滤器</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;my-filter&#x27;</span>, <span class="title class_">MyFilter</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总的来说，<code>Vue.use</code> 的实现非常简单，它主要是通过调用插件的 <code>install</code> 方法来完成插件的注册和安装工作。这样做的好处是可以让插件的使用变得简单而一致，通过一行代码就能完成插件的注册。</p>
<h2 id="mixin的作用-和组件冲突的优先级"><a href="#mixin的作用-和组件冲突的优先级" class="headerlink" title="mixin的作用,和组件冲突的优先级"></a>mixin的作用,和组件冲突的优先级</h2><p><code>mixin</code> 是 Vue 中一种重用组件选项的方式。它允许你在多个组件之间共享组件选项，从而实现代码的复用。<code>mixin</code> 对象可以包含组件选项，如 <code>data</code>、<code>methods</code>、<code>computed</code> 等，以及生命周期钩子。</p>
<h3 id="mixin-的作用："><a href="#mixin-的作用：" class="headerlink" title="mixin 的作用："></a><code>mixin</code> 的作用：</h3><ol>
<li><strong>代码复用：</strong><ul>
<li>通过使用 <code>mixin</code>，你可以将一些组件选项提取出来，使其可以在多个组件中重复使用。这在一些具有相似功能或行为的组件中特别有用。</li>
</ul>
</li>
<li><strong>逻辑分离：</strong><ul>
<li>将一些通用的逻辑从组件中抽离，通过 <code>mixin</code> 进行管理，有助于使组件更加清晰、易于维护。</li>
</ul>
</li>
<li><strong>动态混入：</strong><ul>
<li><code>mixin</code> 可以动态地混入到组件中，实现更灵活的组合方式。</li>
</ul>
</li>
</ol>
<h3 id="组件和-mixin-冲突的优先级："><a href="#组件和-mixin-冲突的优先级：" class="headerlink" title="组件和 mixin 冲突的优先级："></a>组件和 <code>mixin</code> 冲突的优先级：</h3><p>当一个组件和一个或多个 <code>mixin</code> 都定义了相同的选项时，它们之间的优先级是有规则的。以下是优先级的规则：</p>
<ol>
<li><strong>全局 <code>mixin</code>：</strong><ul>
<li>如果有全局 <code>mixin</code>，它将首先被应用，其选项将被混入到每个组件中。</li>
</ul>
</li>
<li><strong>局部 <code>mixin</code>：</strong><ul>
<li>接下来，如果在组件中使用了局部 <code>mixin</code>，那么局部 <code>mixin</code> 的选项将覆盖全局 <code>mixin</code> 的选项。</li>
</ul>
</li>
<li><strong>组件本身：</strong><ul>
<li>最后，组件本身的选项将覆盖全局 <code>mixin</code> 和局部 <code>mixin</code> 的选项。</li>
</ul>
</li>
</ol>
<p>这意味着，如果组件和 <code>mixin</code> 定义了相同的选项，组件的定义将具有最高的优先级，其选项将覆盖 <code>mixin</code> 中相同选项的值。</p>
<h2 id="如何强制更新vue组件"><a href="#如何强制更新vue组件" class="headerlink" title="如何强制更新vue组件"></a>如何强制更新vue组件</h2><h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1><h2 id="vue3-0的设计目标是什么？做了哪些优化"><a href="#vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="vue3.0的设计目标是什么？做了哪些优化"></a>vue3.0的设计目标是什么？做了哪些优化</h2><p>（1）监测机制的改变 3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的 反应性跟踪。 </p>
<p>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的 很多限制： </p>
<p>（2）只能监测属性，不能监测对象 检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、<code>Set</code>、WeakMap 和 Weak<code>Set</code>。</p>
<p> （3）模板 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染， 而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重 新渲染，提升了渲染的性能。 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方 便习惯直接使用 api 来生成 vdom 。</p>
<p> （4）对象式的组件声明方式 vue2.x 中 的 组 件 是 通 过 声 明 的 方 式 传 入 一 系 列 option， 和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功 能，但是比较麻烦。 68 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易 </p>
<p>（5）其它方面的更改 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</p>
<p> 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组件内容）组件，针对一些特殊的场景做了处理。</p>
<p> 基于 tree shaking 优化，提供了更多的内置功能。</p>
<h2 id="vue3-0性能的提升主要通过那几个方面体现的"><a href="#vue3-0性能的提升主要通过那几个方面体现的" class="headerlink" title="vue3.0性能的提升主要通过那几个方面体现的"></a>vue3.0性能的提升主要通过那几个方面体现的</h2><h2 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 Set 、get 和 deleteProperty 等 处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截， 有以下特点∶ </p>
<p>不需用使用 Vue.$set 或 Vue.$delete 触发响应式。 </p>
<p>全方位的数组变化检测，消除了 Vue2 无效的边界情况。</p>
<p> 支持 Map，Set，WeakMap 和 Weakset。 </p>
<p>Proxy 实现的响应式原理与 Vue2 的实现原理相同，实现方式大同小 异∶</p>
<p>get 收集依赖 </p>
<p>Set、delete 等触发依赖 对于集合类型，就是对集合对象的方法做一层包装：</p>
<p>原方法执行后执 行依赖相关的收集或触发逻辑。</p>
<h2 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h2><h3 id="1-组织代码的方式："><a href="#1-组织代码的方式：" class="headerlink" title="1. 组织代码的方式："></a>1. <strong>组织代码的方式：</strong></h3><ul>
<li><p><strong>Options API：</strong></p>
<ul>
<li>Options API 使用选项对象（options object）的方式组织代码。在一个组件中，数据、计算属性、方法、生命周期钩子等都被放在一个对象中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello, Vue!&#x27;,</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    doubleCount() &#123;</span><br><span class="line">      return this.count * 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Composition API：</strong></p>
<ul>
<li>Composition API 允许开发者按照功能划分代码，将相关的代码逻辑组织在一起，而不是按照选项的形式组织。每个功能可以通过 &#96;&#96;Set<code>up</code> 函数中的返回值来进行导出和重用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  Setup() &#123;</span><br><span class="line">    const message = ref(&#x27;Hello, Vue!&#x27;);</span><br><span class="line">    const count = ref(0);</span><br><span class="line"></span><br><span class="line">    const doubleCount = computed(() =&gt; count.value * 2);</span><br><span class="line"></span><br><span class="line">    const increment = () =&gt; &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      message,</span><br><span class="line">      count,</span><br><span class="line">      doubleCount,</span><br><span class="line">      increment</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-响应式数据的声明："><a href="#2-响应式数据的声明：" class="headerlink" title="2. 响应式数据的声明："></a>2. <strong>响应式数据的声明：</strong></h3><ul>
<li><p><strong>Options API：</strong></p>
<ul>
<li>在 Options API 中，响应式数据通常通过 <code>data</code> 方法返回的对象进行声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    message: &#x27;Hello, Vue!&#x27;,</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Composition API：</strong></p>
<ul>
<li>在 Composition API 中，可以使用 <code>ref</code>、<code>reactive</code> 等函数来声明响应式数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const message = ref(&#x27;Hello, Vue!&#x27;);</span><br><span class="line">const count = ref(0);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-生命周期钩子："><a href="#3-生命周期钩子：" class="headerlink" title="3. 生命周期钩子："></a>3. <strong>生命周期钩子：</strong></h3><ul>
<li><p><strong>Options API：</strong></p>
<ul>
<li>在 Options API 中，生命周期钩子直接作为对象的属性进行声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> export default &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#x27;Component created&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUnmount() &#123;</span><br><span class="line">    console.log(&#x27;Component will be unmounted&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Composition API：</strong></p>
<ul>
<li>在 Composition API 中，生命周期钩子使用 <code>onXXX</code> 的形式进行声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; onMounted, onBeforeUnmount &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Component mounted&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">onBeforeUnmount(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;Component will be unmounted&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-代码重用："><a href="#4-代码重用：" class="headerlink" title="4. 代码重用："></a>4. <strong>代码重用：</strong></h3><ul>
<li><strong>Options API：</strong><ul>
<li>在 Options API 中，代码重用通常通过混入（mixins）来实现，但有时可能会导致命名冲突或复杂性。</li>
</ul>
</li>
<li><strong>Composition API：</strong><ul>
<li>Composition API 明确支持逻辑的提取和重用，通过将相关逻辑放在一个函数内，并在 <code>Setup</code> 中导入和调用。</li>
</ul>
</li>
</ul>
<h3 id="5-Typescript-支持："><a href="#5-Typescript-支持：" class="headerlink" title="5. Typescript 支持："></a>5. <strong>Typescript 支持：</strong></h3><ul>
<li><strong>Options API：</strong><ul>
<li>Options API 中的 TypeScript 支持通常需要在组件的选项对象上进行类型声明，有时可能不够直观。</li>
</ul>
</li>
<li><strong>Composition API：</strong><ul>
<li>Composition API 在 TypeScript 下更直观，通过函数参数的类型推断可以更好地支持类型检查。</li>
</ul>
</li>
</ul>
<h2 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h2><p>Vue 3.0 中引入了 Tree-shaking 特性，这是一项优化技术，用于在构建时剔除未使用的代码，从而减小最终打包文件的体积。Tree-shaking 主要依赖于静态分析，通过分析模块的依赖关系，识别和去除未使用的部分。</p>
<p>在 Vue 3.0 中，Tree-shaking 特性主要表现在以下方面：</p>
<ol>
<li><strong>模块的标记：</strong><ul>
<li>Vue 3.0 的模块系统使用了 ESM（ECMAScript 模块）规范，这使得 JavaScript 引擎能够更好地理解和优化模块的导入和导出。这种标准的模块系统有助于静态分析，提高了 Tree-shaking 的效果。</li>
</ul>
</li>
<li><strong>编译时标记：</strong><ul>
<li>Vue 3.0 的编译器在编译阶段会标记出哪些代码是可以被 Tree-shaking 的。这种标记是基于编译时的静态分析，可以准确地识别不会被使用的部分。</li>
</ul>
</li>
</ol>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><p>考虑以下简单的 Vue 3.0 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String,</span><br><span class="line">    content: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    someUnusedMethod() &#123;</span><br><span class="line">      // 未被使用的方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在这个组件中，有一个未被使用的方法 <code>someUnusedMethod</code>。由于 Vue 3.0 的 Tree-shaking 特性，如果这个方法没有在组件内被使用，那么在构建时它将被剔除，不会出现在最终打包的代码中。</p>
<p>这样，即使你在组件内定义了一些方法或变量，只要它们在实际渲染的过程中没有被使用，它们就不会被包含在最终的打包文件中。这对于减小应用的体积非常有帮助，特别是在大型应用中，很多时候我们可能引入了一些库或组件，但只使用了其中的一部分功能。通过 Tree-shaking，未使用的部分将被自动去除，减小了不必要的资源加载。</p>
<h2 id="用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？"><a href="#用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？" class="headerlink" title="用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？"></a>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="你了解axios原理吗？有看过源码吗？"><a href="#你了解axios原理吗？有看过源码吗？" class="headerlink" title="你了解axios原理吗？有看过源码吗？"></a>你了解axios原理吗？有看过源码吗？</h2><h2 id="SSR解决了什么问题？有做过吗？如何做的"><a href="#SSR解决了什么问题？有做过吗？如何做的" class="headerlink" title="SSR解决了什么问题？有做过吗？如何做的"></a>SSR解决了什么问题？有做过吗？如何做的</h2><h2 id="说说vue项目目录结构，若是大型项目如何划分组件及结构"><a href="#说说vue项目目录结构，若是大型项目如何划分组件及结构" class="headerlink" title="说说vue项目目录结构，若是大型项目如何划分组件及结构"></a>说说vue项目目录结构，若是大型项目如何划分组件及结构</h2><h2 id="权限管理如何做？控制到按钮级别的权限如何做？"><a href="#权限管理如何做？控制到按钮级别的权限如何做？" class="headerlink" title="权限管理如何做？控制到按钮级别的权限如何做？"></a>权限管理如何做？控制到按钮级别的权限如何做？</h2><p>封装自定义权限指令实现按钮级别的权限控制</p>
<p>在<code>main.js</code>全局注册自定义指令，（第一个参数是自定义指令名，第二个参数是<code>inserted</code>回调函数,绑定了该指令的元素被插入到<code>dom</code>上时就会自动执行）通过第二个参数获取其对应的权限点的<code>value</code>属性，然后在<code>vuex</code>中的用户信息里进行筛选看用户是否具有该权限，使用<code>v-if</code>来决定是否显示对应的元素</p>
<h2 id="浏览器底层原理"><a href="#浏览器底层原理" class="headerlink" title="浏览器底层原理"></a>浏览器底层原理</h2><h2 id="浏览器是如何解析css选择器的"><a href="#浏览器是如何解析css选择器的" class="headerlink" title="浏览器是如何解析css选择器的"></a>浏览器是如何解析css选择器的</h2><h2 id="浏览器是如何进行界面渲染的"><a href="#浏览器是如何进行界面渲染的" class="headerlink" title="浏览器是如何进行界面渲染的"></a>浏览器是如何进行界面渲染的</h2><p>浏览器进行界面渲染的过程可以分为以下几个关键步骤：</p>
<ol>
<li><strong>构建 DOM 树：</strong><ul>
<li>当浏览器接收到 HTML 文件时，它会解析 HTML，并构建 DOM（文档对象模型）树。DOM 树是一个由节点（元素、文本等）构成的层次结构，表示了页面的结构。</li>
</ul>
</li>
<li><strong>构建 CSSOM 树：</strong><ul>
<li>浏览器解析样式表（CSS 文件或内嵌样式），并构建 CSSOM（CSS 对象模型）树。CSSOM 树表示了页面中各个元素的样式信息，包括它们的样式属性和如何相互影响。</li>
</ul>
</li>
<li><strong>构建 Render 树：</strong><ul>
<li>DOM 树和 CSSOM 树结合起来构建 Render 树。Render 树是由浏览器用于渲染的树结构，它只包含需要显示的节点和这些节点的样式信息。一些不可见的元素（例如<code>display: none</code>的元素）不会包含在 Render 树中。</li>
</ul>
</li>
<li><strong>布局（Layout）：</strong><ul>
<li>在构建 Render 树后，浏览器进行布局过程，确定每个节点在屏幕上的确切位置和大小。这个过程也称为回流（reflow）。浏览器需要考虑各种因素，如盒模型、文档流、浮动等，来计算元素的准确位置。</li>
</ul>
</li>
<li><strong>绘制（Painting）：</strong><ul>
<li>在布局完成后，浏览器进行绘制过程，将页面的内容绘制到屏幕上。这个过程也称为重绘（repaint）。绘制阶段使用绘图引擎将每个元素绘制成像素，考虑元素的颜色、边框、阴影等样式属性。</li>
</ul>
</li>
<li><strong>合成（Composite）：</strong><ul>
<li>浏览器将不同层的绘制结果合成在一起，形成最终的页面。现代浏览器通常使用图层来提高页面的性能。图层是一个独立的绘制表面，可以单独绘制和合成，这样在页面更新时只需要重新绘制和合成发生变化的图层，而不是整个页面。</li>
</ul>
</li>
<li><strong>渲染刷新：</strong><ul>
<li>当页面内容发生变化、用户触发交互或浏览器窗口大小改变时，浏览器会重新执行上述渲染流程，以确保页面保持最新。</li>
</ul>
</li>
</ol>
<p>这个整个渲染过程是一个逐步的、增量的过程。浏览器采用这种方式，以提高页面渲染的性能和用户体验。</p>
<h2 id="前端如何实现实时通讯"><a href="#前端如何实现实时通讯" class="headerlink" title="前端如何实现实时通讯?"></a>前端如何实现实时通讯?</h2><p>WebSocket（通常缩写为 WS）是一种在单个 TCP 连接上进行全双工通信的协议。与传统的 HTTP 请求-响应模型不同，WebSocket 允许在同一连接上同时进行双向数据传输，实现实时通信。WebSocket 协议最初由 IETF 标准化，目前的标准版本是 RFC 6455。</p>
<p>以下是 WebSocket 的一些重要特性和工作原理：</p>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ol>
<li><strong>全双工通信：</strong> WebSocket 允许客户端和服务器之间建立持久的连接，实现双向实时通信，而不是像 HTTP 请求-响应那样需要不断地发起新的请求。</li>
<li><strong>低延迟：</strong> 由于使用了单个 TCP 连接，WebSocket 可以减少因为建立和关闭连接而引入的延迟。</li>
<li><strong>轻量级：</strong> WebSocket 的协议头较小，通信过程较简单，相对于传统的 HTTP 协议，WebSocket 的开销较小。</li>
<li><strong>跨域支持：</strong> WebSocket 支持跨域通信，允许在浏览器中进行跨域实时通信。</li>
</ol>
<h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ol>
<li><strong>握手阶段：</strong> WebSocket 连接的建立始于一个 HTTP 请求，通常称为握手阶段。客户端发起一个 HTTP 请求，请求头中包含协议升级的信息，服务器接受后会响应一个包含握手成功信息的 HTTP 响应。之后，连接协议升级为 WebSocket。</li>
<li><strong>数据帧传输：</strong> 握手成功后，客户端和服务器之间的通信就进入了数据帧传输阶段。WebSocket 通信使用帧（frame）的概念，每个帧可以携带文本、二进制数据等信息。帧的传输是双向的，客户端和服务器可以同时发送和接收帧。</li>
<li><strong>帧格式：</strong> WebSocket 帧的格式相对简单，通常包含一个头部和一个数据部分。头部包含帧的类型、长度等信息，数据部分则是实际的传输数据。</li>
<li><strong>关闭连接：</strong> 当需要关闭连接时，客户端或服务器可以发送一个关闭帧，通知对方关闭连接。收到关闭帧的一方也会发送一个关闭帧，双方最终关闭连接。</li>
</ol>
<h3 id="JavaScript-中的使用："><a href="#JavaScript-中的使用：" class="headerlink" title="JavaScript 中的使用："></a>JavaScript 中的使用：</h3><p>在浏览器中，可以使用 JavaScript 的 <code>WebSocket</code> API 来创建 WebSocket 连接。以下是一个简单的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建 WebSocket 连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://example.com/socket&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开事件</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection opened:&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收到消息事件</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection closed:&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&#x27;Hello, WebSocket!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>onopen</code>、<code>onmessage</code>、<code>onclose</code> 等是 <code>WebSocket</code> 对象的事件处理函数，用于处理连接打开、接收消息、连接关闭等事件。<code>send</code> 方法用于向服务器发送消息。</p>
<h2 id="什么是浏览器同源策略"><a href="#什么是浏览器同源策略" class="headerlink" title="什么是浏览器同源策略?"></a>什么是浏览器同源策略?</h2><p>同源策略（Same-Origin Policy）是浏览器的一种安全策略，用于限制一个网页文档或脚本如何能够与其他源的资源进行交互。同源策略的核心思想是：不同源的客户端脚本在没有明确授权的情况下，不能读取对方的资源。</p>
<p>同源是指协议（如 http 和 https）、域名和端口号都相同。如果有任何一个不同，就被视为不同源。</p>
<p>同源策略的主要目的是防止恶意网站通过脚本等方式窃取数据，保护用户的隐私和安全。</p>
<h2 id="如何实现跨域获取数据"><a href="#如何实现跨域获取数据" class="headerlink" title="如何实现跨域获取数据"></a>如何实现跨域获取数据</h2><p>后端配置cors</p>
<p>前端使用代理转发</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="说说JavaScript中的数据类型？存储上的差别？"><a href="#说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="说说JavaScript中的数据类型？存储上的差别？"></a>说说JavaScript中的数据类型？存储上的差别？</h2><p><code>js</code>的数据类型主要分为&#x3D;&#x3D;基本数据类型&#x3D;&#x3D;和&#x3D;&#x3D;引用数据类型&#x3D;&#x3D;</p>
<h5 id="基本数据类型-7种"><a href="#基本数据类型-7种" class="headerlink" title="基本数据类型:7种"></a>基本数据类型:7种</h5><p>1.<code>string</code></p>
<p>字符串可以使用双引号<code>&quot; &quot;</code>、单引号<code>&#39; &#39;</code>或反引号  &#96;  标示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&#x27;Jacob&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">`Jingleheimerschmidt`</span></span><br></pre></td></tr></table></figure>

<p>2.<code>number</code></p>
<p>3.<code>null</code></p>
<p><code>null</code>表示有值但是值为空,可以理解为就是一个毛坯房里面什么东西都没有,通常用来占据位置,未来要往里面赋值</p>
<p>4.<code>undefind</code></p>
<p>使用<code>let</code>或是<code>var</code>声明了变量但是没有初始化,那么这个变量的值就是<code>undefined</code></p>
<p>5.<code>boolean</code></p>
<p>只有两个<code>true</code>和<code>false</code></p>
<p>6.<code>bigInt</code>(es11新增)</p>
<p>表示任意大的整数类型</p>
<p>普通的整数类型（<code>number</code>）只能安全地存储和运算 -2^53^ -1 到 2^53^-1 这个范围之间的整数，而<code>bigint</code>则没有这个限制。</p>
<p>7.<code>symbol</code>(es6新增)</p>
<p><code>symbol</code>是一种唯一的、不可变的数据类型，经常用于作为对象属性的键。它的主要特点是每次创建都会生成一个唯一的值，即使使用相同的字符串也无法创建出相同的<code>symbol</code>。</p>
<h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>1.<code>function</code></p>
<p>是一种特殊类型的对象，可以执行代码块。</p>
<p>2.<code>array</code></p>
<p>是一种特殊类型的对象，用于按顺序存储多个值。</p>
<p>3.<code>object</code></p>
<p>用于存储复杂的数据结构，可以包含属性和方法。</p>
<h4 id="js数据类型的检测"><a href="#js数据类型的检测" class="headerlink" title="js数据类型的检测"></a>js数据类型的检测</h4><p>1.typeof</p>
<ul>
<li><code>typeof</code> 操作符用于确定变量或表达式的数据类型，返回一个表示数据类型的字符串。例如：<code>typeof variableName</code>。返回的结果可以是以下字符串之一：<code>&quot;string&quot;</code>、<code>&quot;number&quot;</code>、<code>&quot;boolean&quot;</code>、<code>&quot;undefined&quot;</code>、<code>&quot;object&quot;</code>、<code>&quot;function&quot;</code>、<code>&quot;symbol&quot;</code> 或 <code>&quot;bigint&quot;</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;Hello&quot;</span> <span class="comment">// 返回 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> <span class="comment">// 返回 &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 返回 &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 返回 &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 返回 &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 返回 &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.instanceof</p>
<ul>
<li><code>instanceof</code> 操作符用于检查一个对象是否是某个构造函数的实例。它通常用于检测自定义的对象类型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<p>3.constructor 属性</p>
<ul>
<li>可以使用对象的 <code>constructor</code> 属性来检测其构造函数。这通常用于检测自定义对象类型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;obj 是一个对象&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.<strong>Object.prototype.toString.call() 方法</strong>：</p>
<ul>
<li>这是一种通用的方法，可以用于检测任何数据类型，包括原始数据类型和引用数据类型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// 返回 &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>) <span class="comment">// 返回 &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// 返回 &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]) <span class="comment">// 返回 &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p>5.Array.isArray() 方法：</p>
<ul>
<li>用于检测一个值是否是数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]) <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<p>6.isNaN() 函数：</p>
<p>用于检测一个值是否为 NaN（非数字值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;Hello&quot;</span>) <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的常用方法有哪些？"><a href="#数组的常用方法有哪些？" class="headerlink" title="数组的常用方法有哪些？"></a>数组的常用方法有哪些？</h2><p>操作方法</p>
<p>增</p>
<p><code>push()</code>方法接收任意数量的参数，并将它们添加到<strong>数组末尾</strong>，返回数组的最新长度</p>
<p><code>unshift()</code>在数组开头<strong>添加任意多个值</strong>，然后返回新的数组长度</p>
<p><code>splice()</code> 传入三个参数，分别是开始位置、要删除的元素数量、增加的元素，返回一个空数组</p>
<p>删</p>
<p><font color="red"><strong>修改原数组</strong></font></p>
<p><code>pop()</code> 方法用于删除数组的<strong>最后一项</strong>，同时减少数组的<code>length</code> 值，返回被删除的项</p>
<p><code>shift()</code>方法用于删除数组的<strong>第一项</strong>，同时减少数组的<code>length</code> 值，返回被删除的项</p>
<p><code>splice()</code>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p>
<p>改</p>
<p>查</p>
<p><code>indexof()</code>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>
<p><code>includes()</code>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>
<p> <code>find()</code>返回第一个匹配的元素</p>
<p>排序方法</p>
<p>数组翻转<code>reverse()</code></p>
<p>数组排序<code>sort()</code>方法接受一个比较函数，用于判断哪个值应该排在前面</p>
<p>转换方法</p>
<p><code>join()</code> 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>
<p>迭代方法</p>
<p><code>some()</code>对数组每一项都运行传入的测试函数，如果至少有1个元素返回 true ，则这个方法返回 true</p>
<p><code>every()</code>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>
<p><code>forEach()</code>对数组每一项都运行传入的函数，没有返回值</p>
<p><code>filter()</code>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>
<p><code>map()</code>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>
<h2 id="JavaScript字符串的常用方法有哪些？"><a href="#JavaScript字符串的常用方法有哪些？" class="headerlink" title="JavaScript字符串的常用方法有哪些？"></a>JavaScript字符串的常用方法有哪些？</h2><p><code>trim()</code>删除前、后或前后所有空格符，再返回新的字符串</p>
<p><code>aplit()</code>把字符串按照指定的分割符，拆分成数组中的每一项</p>
<h2 id="和-区别，分别在什么情况使用"><a href="#和-区别，分别在什么情况使用" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用</h2><h3 id="（相等操作符）："><a href="#（相等操作符）：" class="headerlink" title="==（相等操作符）："></a><code>==</code>（相等操作符）：</h3><ul>
<li><p><strong>比较过程：</strong> <code>==</code> 进行比较时，会进行类型转换，尝试将比较的两个值转换为相同的类型，然后再进行比较。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;5&#x27;</span> == <span class="number">5</span>; <span class="comment">// true，因为字符串 &#x27;5&#x27; 会被转换为数字 5</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>; <span class="comment">// true，因为布尔值 false 会被转换为数字 0</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true，它们被视为相等</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（严格相等操作符）："><a href="#（严格相等操作符）：" class="headerlink" title="===（严格相等操作符）："></a><code>===</code>（严格相等操作符）：</h3><ul>
<li><p><strong>比较过程：</strong> <code>===</code> 进行比较时，不会进行类型转换。只有在两个值的类型和值都相等的情况下，<code>===</code> 才会返回 <code>true</code>。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&#x27;5&#x27;</span> === <span class="number">5</span>; <span class="comment">// false，因为它们的类型不同</span></span><br><span class="line"><span class="number">0</span> === <span class="literal">false</span>; <span class="comment">// false，因为它们的类型不同</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>; <span class="comment">// false，它们的类型相同，但值不同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何选择使用："><a href="#如何选择使用：" class="headerlink" title="如何选择使用："></a>如何选择使用：</h3><ul>
<li>推荐使用 <code>===</code>，因为它避免了类型转换带来的一些意外行为，更加严格和可靠。</li>
<li>在特定情况下，如果你明确需要进行类型转换，或者想要利用 JavaScript 的隐式类型转换规则，可以使用 <code>==</code>。但需要小心因为类型转换可能导致不直观的结果。</li>
<li>一般来说，为了代码的清晰和可读性，最好养成使用 <code>===</code> 的习惯，以避免因为隐式类型转换而引起的错误。</li>
</ul>
<h2 id="深拷贝浅拷贝的区别？如何实现一个深拷贝？"><a href="#深拷贝浅拷贝的区别？如何实现一个深拷贝？" class="headerlink" title="深拷贝浅拷贝的区别？如何实现一个深拷贝？"></a>深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2><h2 id="说说你对闭包的理解？闭包使用场景"><a href="#说说你对闭包的理解？闭包使用场景" class="headerlink" title="说说你对闭包的理解？闭包使用场景"></a>说说你对闭包的理解？闭包使用场景</h2><p>闭包简单来说就是一个嵌套的函数内层函数能够访问外层函数的局部变量,这个时候就发生了闭包</p>
<p>优点:</p>
<ul>
<li>变量私有化,延长变量的生命周期</li>
</ul>
<p>缺点</p>
<ul>
<li>变量没有被及时的释放会造成内存泄漏,需要手动进行释放</li>
</ul>
<p>使用场景</p>
<h2 id="说说你对作用域链的理解"><a href="#说说你对作用域链的理解" class="headerlink" title="说说你对作用域链的理解"></a>说说你对作用域链的理解</h2><p>说作用域之前先说一说这个作用域,作用域一般分为三种分别是</p>
<p>块级作用域</p>
<p>在ES6中引入的<code>let</code>和<code>const</code>变量的声明方式具有块级作用域,即在<code>&#123; &#125;</code>包裹的范围之内都可以被访问到,<code>&#123; &#125;</code>之外不可以</p>
<p>函数作用域</p>
<p>函数作用域只有在函数内部可以被访问到,外部无法访问</p>
<p>全局作用域</p>
<p>全局作用域下声明的变量是在任何位置都是可以被访问到的</p>
<p>作用域链: </p>
<p>当JavaScript在执行代码访问变量的时候会优先在自身当前作用域查找看有没有,如果没有就会到父级作用域依次逐级向上查找,直到全局作用域,这时如果还是没有找到在非严格模式下会隐式的声明该变量,或者是直接报错</p>
<h2 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h2><p>原型:</p>
<p>每一个构造函数和通过构造函数创建出来的实例对象都有一个共同的原型对象</p>
<p>构造函数是通过<code>prototype</code>属性来访问,实例对象通过<code>__proto__</code>属性来访问原型对象</p>
<p>原型链:</p>
<p>简单来说它可以实现对象之间属性和方法的继承和共享</p>
<p>当一个对象访问其身上的属性和方法的时候,它会优先在自身查找如果没有就会到原型对象身上去查找,如果还没有就会逐级向上到<code>object</code>的原型对象身上查找,直到找到或是到达原型链的末端<code>Object.prototype</code>,这时如果还没有找到就会返回<code>null</code>,这样一个链式查找的过程就叫作原型链</p>
<h2 id="Javascript如何实现继承？"><a href="#Javascript如何实现继承？" class="headerlink" title="Javascript如何实现继承？"></a>Javascript如何实现继承？</h2><p>在父类的原型上添加共有的属性或者是方法,使用<code>father.prototype = Object.create(son.prototype)</code>创建了一个新的对象建立起关联</p>
<p>比如说我们创建一个人类person的构造函数,给它添加了一个sayHello的方法</p>
<p>然后我们又创建了一个学生Student的构造函数,给它添加了一个study方法</p>
<p>使用student.prototype &#x3D; object.create(person.prototype)建立起关联,使其原型链指向person.prototype</p>
<p>这样当我们既可以使用使用学生自身的study方法,也可以使用它原型对象身上的sayHello方法,因为学生自己身上是没有sayHello方法的,就会去原型对象身上去查找,这样就实现了原型的继承</p>
<h2 id="cookie-、localstorage-、-sessionstrorage-之间有什么区别？"><a href="#cookie-、localstorage-、-sessionstrorage-之间有什么区别？" class="headerlink" title="cookie 、localstorage 、 sessionstrorage 之间有什么区别？"></a>cookie 、localstorage 、 sessionstrorage 之间有什么区别？</h2><p>大小</p>
<p>cookie,大小大概为4kb左右</p>
<p>而localstorage和sessionstroage的存储空间比cookie要大,大概5m左右</p>
<p>到期时间</p>
<p>cookie可以设置到期时间,在到期时间没过之前一直有效</p>
<p>localstroage将数据永久存储到本地,页面和浏览器关闭后不会丢失</p>
<p>sessionstroage 当浏览器或是页面关闭后存储的数据就会丢失</p>
<h2 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a>谈谈this对象的理解</h2><p>this的指向在不同的函数里面this的指向是不一样的</p>
<p>全局:this指向全局对象也就是window</p>
<p>普通函数:普通函数被当做方法调用的时候指向事件源</p>
<p>箭头函数: 箭头函数的this指向是固定的它会继续沿用上一层作用域中的this指向</p>
<p>构造函数: 构造函数的this指向新创建的实例对象</p>
<p>this指向也是也可以通过 call bind 和apply方法来进行修改的</p>
<h2 id="JavaScript中执行上下文和执行栈是什么？"><a href="#JavaScript中执行上下文和执行栈是什么？" class="headerlink" title="JavaScript中执行上下文和执行栈是什么？"></a>JavaScript中执行上下文和执行栈是什么？</h2><h2 id="说说JavaScript中的事件模型"><a href="#说说JavaScript中的事件模型" class="headerlink" title="说说JavaScript中的事件模型"></a>说说JavaScript中的事件模型</h2><h2 id="typeof-与-instanceof-区别"><a href="#typeof-与-instanceof-区别" class="headerlink" title="typeof 与 instanceof 区别"></a>typeof 与 instanceof 区别</h2><p>typeof 检测基本数据类型</p>
<p>instanceof 检测引用数据类型</p>
<p>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p>
<h2 id="解释下什么是事件代理？应用场景？"><a href="#解释下什么是事件代理？应用场景？" class="headerlink" title="解释下什么是事件代理？应用场景？"></a>解释下什么是事件代理？应用场景？</h2><h2 id="说说new操作符具体干了什么？"><a href="#说说new操作符具体干了什么？" class="headerlink" title="说说new操作符具体干了什么？"></a>说说new操作符具体干了什么？</h2><ol>
<li>创建一个空的 <code>JavaScript</code> 对象。<ul>
<li>一个新的空对象被创建，这个对象被称为构造函数的实例对象。</li>
</ul>
</li>
<li>将新对象的 <code>__proto__</code> 属性指向构造函数的原型对象。<ul>
<li>每个 JavaScript 函数都有一个特殊的属性称为 <code>prototype</code>，这个属性是一个指向对象的引用。<code>new</code>操作符会将新对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code> 属性，这样新对象就可以访问构造函数原型对象上的属性和方法。</li>
</ul>
</li>
<li>执行构造函数，将新对象绑定到 <code>this</code>。<ul>
<li>构造函数内部的代码被执行，<code>this</code> 关键字指向新创建的对象。这允许构造函数将属性和方法添加到新对象上。</li>
</ul>
</li>
<li>如果构造函数没有显式返回一个对象，那么 <code>new</code> 操作符会返回新创建的对象。<ul>
<li>如果构造函数没有使用 <code>return</code> 关键字返回一个对象，则<code>new</code>操作符会返回新创建的对象。如果构造函数返回一个对象（不管是显式返回的还是通过构造函数中的代码生成的），则<code>new</code>操作符会返回该对象，而不是新创建的对象。</li>
</ul>
</li>
</ol>
<h2 id="ajax原理是什么？如何实现？"><a href="#ajax原理是什么？如何实现？" class="headerlink" title="ajax原理是什么？如何实现？"></a>ajax原理是什么？如何实现？</h2><h2 id="bind、call、apply-区别？如何实现一个bind"><a href="#bind、call、apply-区别？如何实现一个bind" class="headerlink" title="bind、call、apply 区别？如何实现一个bind?"></a>bind、call、apply 区别？如何实现一个bind?</h2><p>call bind apply都是用来改变this的指向</p>
<p>主要有三个方面的修改this指向的时长不一样</p>
<p>call 和 apply 只会改变一次this的指向,并且立即执行</p>
<p>bind,不会立即执行,是返回一个改变this指向之后的一个新的函数</p>
<p>传参方式不一样</p>
<p>call apply是数组列表传参</p>
<p>bind 是 伪数组传参可以分为多传入</p>
<h2 id="说说你对正则表达式的理解？应用场景？"><a href="#说说你对正则表达式的理解？应用场景？" class="headerlink" title="说说你对正则表达式的理解？应用场景？"></a>说说你对正则表达式的理解？应用场景？</h2><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><p>js是一门单线程语言,这就意味这在同一时间只能执行一件任务,遇到异步任务就会造成代码的阻塞</p>
<p>所以js里面所有的任务被分为同步任务和异步任务</p>
<p>代码从上到下执行,会先进入到调用栈执行,遇到异步任务就会交给宿主环境(node.js,浏览器)去执行,执行完成之后放到任务队列中进行排队,接着执行同步任务</p>
<p>等待所有的异步任务执行完毕之后,就会到任务队列中去读取执行,输出结果</p>
<p>异步任务里面又有微任务和宏任务,微任务的优先级比微任务要高,会在任务队列之前插队执行</p>
<p>如此不断循环往复的流程就是事件循环</p>
<h2 id="DOM常见的操作有哪些？"><a href="#DOM常见的操作有哪些？" class="headerlink" title="DOM常见的操作有哪些？"></a>DOM常见的操作有哪些？</h2><h2 id="说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>说说你对BOM的理解，常见的BOM对象你了解哪些？</h2><h2 id="举例说明你对尾递归的理解，有哪些应用场景"><a href="#举例说明你对尾递归的理解，有哪些应用场景" class="headerlink" title="举例说明你对尾递归的理解，有哪些应用场景"></a>举例说明你对尾递归的理解，有哪些应用场景</h2><h2 id="说说-JavaScript-中内存泄漏的几种情况？"><a href="#说说-JavaScript-中内存泄漏的几种情况？" class="headerlink" title="说说 JavaScript 中内存泄漏的几种情况？"></a>说说 JavaScript 中内存泄漏的几种情况？</h2><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><h2 id="说说你对函数式编程的理解？优缺点？"><a href="#说说你对函数式编程的理解？优缺点？" class="headerlink" title="说说你对函数式编程的理解？优缺点？"></a>说说你对函数式编程的理解？优缺点？</h2><h2 id="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"><a href="#Javascript中如何实现函数缓存？函数缓存有哪些应用场景？" class="headerlink" title="Javascript中如何实现函数缓存？函数缓存有哪些应用场景？"></a>Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</h2><h2 id="说说-Javascript-数字精度丢失的问题，如何解决？"><a href="#说说-Javascript-数字精度丢失的问题，如何解决？" class="headerlink" title="说说 Javascript 数字精度丢失的问题，如何解决？"></a>说说 Javascript 数字精度丢失的问题，如何解决？</h2><p><code>tofixed()</code></p>
<h2 id="什么是防抖和节流？有什么区别？如何实现？"><a href="#什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？"></a>什么是防抖和节流？有什么区别？如何实现？</h2><p>一种性能优化手段</p>
<p>防抖:在单位时间内一个事件被多次触发只会执行最后一次</p>
<p>节流:早单位时间内一个事件被多次触发只会执行一次,第二次触发就会重新开始计时,当限制时间过了之后才会执行第二次</p>
<p>实现原理:</p>
<p>防抖</p>
<p>利用settimeout函数开启一个来实现当事件被点击了之后就清除掉原来的定时器重新开启一个新的定时器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用场景: 手机号,邮箱的验证,窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染</p>
<p>节流</p>
<p>在执行settimeout函数之前给他设置一个默认的开关或者是阀门为true,当事件被点击了之后立马把这个变量设置为false,只有在等延时时间过了之后就再次把开关设置为true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用场景: html页面滚动的电梯导航,搜索框，搜索联想功能</p>
<h2 id="如何判断一个元素是否在可视区域中？"><a href="#如何判断一个元素是否在可视区域中？" class="headerlink" title="如何判断一个元素是否在可视区域中？"></a>如何判断一个元素是否在可视区域中？</h2><h2 id="大文件上传如何做断点续传？"><a href="#大文件上传如何做断点续传？" class="headerlink" title="大文件上传如何做断点续传？"></a>大文件上传如何做断点续传？</h2><h3 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h3><p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p>
<p>文件上传简单，文件变大就复杂</p>
<p>上传大文件时，以下几个变量会影响我们的用户体验</p>
<ul>
<li>服务器处理数据的能力</li>
<li>请求超时</li>
<li>网络波动</li>
</ul>
<p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p>
<p>为了解决上述问题，我们需要对大文件上传单独处理</p>
<p>这里涉及到分片上传及断点续传两个概念</p>
<h3 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h3><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p>
<p>如下图</p>
<p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p>
<p>大致流程如下：</p>
<ol>
<li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li>
<li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li>
<li>按照一定的策略（串行或并行）发送各个分片数据块；</li>
<li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li>
</ol>
<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p>
<p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p>
<p>一般实现方式有两种：</p>
<ul>
<li>服务器端返回，告知从哪开始</li>
<li>浏览器端自行处理</li>
</ul>
<p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p>
<p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p>
<h2 id="如何实现上拉加载，下拉刷新？"><a href="#如何实现上拉加载，下拉刷新？" class="headerlink" title="如何实现上拉加载，下拉刷新？"></a>如何实现上拉加载，下拉刷新？</h2><h2 id="什么是单点登录？如何实现？"><a href="#什么是单点登录？如何实现？" class="headerlink" title="什么是单点登录？如何实现？"></a>什么是单点登录？如何实现？</h2><h2 id="web常见的攻击方式有哪些？如何防御？"><a href="#web常见的攻击方式有哪些？如何防御？" class="headerlink" title="web常见的攻击方式有哪些？如何防御？"></a>web常见的攻击方式有哪些？如何防御？</h2><h2 id="解释下什么是变量声明提升"><a href="#解释下什么是变量声明提升" class="headerlink" title="解释下什么是变量声明提升"></a>解释下什么是变量声明提升</h2><p>变量声明提升是JavaScript中的一种行为，它使得在代码执行前，变量和函数的声明被提升到当前作用域的顶部。这意味着可以在声明之前访问这些变量或函数。</p>
<p>在JavaScript中，有两种声明方式：<code>var</code>关键字和<code>function</code>关键字。对于<code>var</code>声明的变量和使用<code>function</code>声明的函数，它们的声明会被提升。</p>
<p>下面是一个简单的例子，演示了变量声明提升：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，虽然<code>console.log(x)</code>在<code>var x = 5</code>之前被调用，但由于变量声明提升，<code>x</code>在该语句执行时已经被声明，只是尚未被赋值，因此输出<code>undefined</code>。而在后续的赋值语句之后，<code>console.log(x)</code>输出了<code>5</code>。</p>
<p>注意，只有声明会被提升，赋值不会。如果一个变量在声明之前被访问，它的值会是<code>undefined</code>。</p>
<p>函数声明也会被提升，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_">foo</span>(); <span class="comment">// 输出: &quot;Hello, World!&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>foo()</code>在函数声明之前被调用，但由于函数声明提升，程序会正常输出”Hello, World!”。</p>
<p>需要注意的是，使用<code>let</code>和<code>const</code>关键字声明的变量也有提升，但与<code>var</code>不同，它们在提升阶段不会被初始化，访问时会报错。这被称为”暂时性死区”（Temporal Dead Zone，简称TDZ）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 报错：Cannot access &#x27;x&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>总的来说，变量声明提升是<code>JavaScript</code>语言中的一种特性，了解它有助于避免在代码中出现一些意外的行为。在编写代码时，建议将变量和函数的声明放在当前作用域的顶部，以提高代码的可读性和可维护性。</p>
<h2 id="js的参数是以什么方式进行传递的"><a href="#js的参数是以什么方式进行传递的" class="headerlink" title="js的参数是以什么方式进行传递的"></a>js的参数是以什么方式进行传递的</h2><h2 id="js的垃圾回收机制是怎么做的"><a href="#js的垃圾回收机制是怎么做的" class="headerlink" title="js的垃圾回收机制是怎么做的"></a>js的垃圾回收机制是怎么做的</h2><h2 id="谈谈你平时都用了哪些方法进行性能优化？"><a href="#谈谈你平时都用了哪些方法进行性能优化？" class="headerlink" title="谈谈你平时都用了哪些方法进行性能优化？"></a>谈谈你平时都用了哪些方法进行性能优化？</h2><p>减少http请求次数、打包压缩上线代码、使用懒加载、使用雪碧图、动态渲染组件、CDN加载包。</p>
<h2 id="谈谈你对继承的理解"><a href="#谈谈你对继承的理解" class="headerlink" title="谈谈你对继承的理解"></a>谈谈你对继承的理解</h2><p>继承是面向对象编程（OOP）中的一个重要概念，它允许一个对象（子类&#x2F;派生类）获得另一个对象（父类&#x2F;基类）的属性和方法。继承是为了实现代码的重用和扩展，使得代码更加模块化、可维护和可扩展。</p>
<h3 id="继承的主要类型："><a href="#继承的主要类型：" class="headerlink" title="继承的主要类型："></a>继承的主要类型：</h3><ol>
<li><strong>单一继承：</strong><ul>
<li>一个子类只能继承自一个父类。这是一种简单的继承关系，存在较低的复杂性，但有时可能会限制灵活性。</li>
</ul>
</li>
<li><strong>多重继承：</strong><ul>
<li>一个子类可以同时继承自多个父类。这样可以更灵活地组合不同的功能，但也可能导致复杂性增加，引发一些设计上的问题。</li>
</ul>
</li>
<li><strong>多层继承：</strong><ul>
<li>类型之间形成一个层次结构，子类可以继承自父类，父类又可以继承自更上层的父类。这样的继承关系可以形成一个层次结构。</li>
</ul>
</li>
</ol>
<h3 id="继承的实现方式："><a href="#继承的实现方式：" class="headerlink" title="继承的实现方式："></a>继承的实现方式：</h3><ol>
<li>原型链继承：<ul>
<li>通过将子类的原型设置为父类的实例，从而让子类共享父类的属性和方法。但存在共享引用类型属性的问题，且无法传递参数给父类构造函数。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>构造函数继承（借用构造函数）：<ul>
<li>在子类的构造函数中调用父类的构造函数，通过 <code>call</code> 或 <code>apply</code> 方法来实现。解决了原型链继承的引用类型问题，但无法实现原型链上方法的复用。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 借用构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>组合继承：<ul>
<li>结合原型链继承和构造函数继承，既可以共享原型链上的方法，又可以解决构造函数继承的问题。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 借用构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(); <span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>原型式继承：<ul>
<li>利用一个简单的函数创建一个临时构造函数，然后将该构造函数的实例作为子类的原型。ES5 中可以使用 <code>Object.create</code> 方法实现。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Animal&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="title class_">Object</span>.<span class="title function_">create</span>(animal);</span><br><span class="line">dog.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>ES6 中的类继承：<ul>
<li>使用 <code>class</code> 关键字定义类，通过 <code>extends</code> 关键字实现继承。ES6 的类继承更接近传统的面向对象语言的实现方式，语法更简洁。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">bark</span> = <span class="string">&#x27;Woof&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myDog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myDog.<span class="property">name</span>); <span class="comment">// &#x27;Animal&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="继承的优缺点："><a href="#继承的优缺点：" class="headerlink" title="继承的优缺点："></a>继承的优缺点：</h3><p><strong>优点：</strong></p>
<ul>
<li><strong>代码复用：</strong> 继承允许子类重用父类的属性和方法，减少代码冗余。</li>
<li><strong>扩展性：</strong> 可以通过继承来扩展或修改现有类的行为。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>耦合性增加：</strong> 高度耦合的继承关系可能导致一个类的改变影响到其他相关的类。</li>
<li><strong>可读性下降：</strong> 复杂的继承关系可能使代码难以理解和维护。</li>
<li><strong>创建对象时的灵活性受限：</strong> 子类通常依赖于父类的实现，而不能灵活地改变或替换父类的实现。</li>
</ul>
<h2 id="如何判断是否为数组"><a href="#如何判断是否为数组" class="headerlink" title="如何判断是否为数组"></a>如何判断是否为数组</h2><ol>
<li><p><strong>Array.isArray() 方法：</strong></p>
<ul>
<li><code>Array.isArray()</code> 是最推荐的方法，它是ES5引入的，用于确定传递的值是否是一个数组。返回一个布尔值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(myArray)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>instanceof 操作符：</strong></p>
<ul>
<li><code>instanceof</code> 操作符用于检测构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myArray <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>instanceof</code> 可能在涉及多个全局执行上下文的情况下失效，因此在跨框架或跨窗口的环境中不是很可靠。</p>
</li>
<li><p><strong>使用 Object.prototype.toString.call() 方法：</strong></p>
<ul>
<li><code>Object.prototype.toString.call()</code> 方法可以返回一个表示对象的字符串，其中包含了对象的类型信息。对于数组，返回的字符串应该是 <code>&quot;[object Array]&quot;</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> myArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(myArray) === <span class="string">&#x27;[object Array]&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这三种方法中，推荐使用 <code>Array.isArray()</code>，因为它是专门用于检查是否为数组的方法，且更直观。在兼容性较好的环境中，这是最佳选择。如果需要更通用的方法，<code>Object.prototype.toString.call()</code> 也是一种可靠的选择。</p>
<h2 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h2><p>调用resolve 结果带到实例方法.then成功的回调里面</p>
<p>reject   结果带到实例方法.catch 失败的回调</p>
<p>race 优先输出第一个异步任务的结果</p>
<p>all 等待所有的异步任务执行完毕之后执行的回调</p>
<h2 id="微任务-宏任务是什么"><a href="#微任务-宏任务是什么" class="headerlink" title="微任务&#x2F;宏任务是什么?"></a>微任务&#x2F;宏任务是什么?</h2><h2 id="async-await是什么-相较于Promise有什么优势"><a href="#async-await是什么-相较于Promise有什么优势" class="headerlink" title="async&#x2F;await是什么?相较于Promise有什么优势"></a>async&#x2F;await是什么?相较于Promise有什么优势</h2><p>promise的语法糖</p>
<p>解决promise函数调用的回调地狱</p>
<p>async关键字是asynchronous(异步)的简写,用来声明一个函数是异步函数,写在函数的最前面,他会返回一个<code>promise</code>对象</p>
<p><code>await</code>可以理解为asynchronous wait(等待异步),他会等待一个异步任务返回的结果</p>
<p>下面这两种方法是等效的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await</p>
<p>正常情况下，<code>await</code>命令后面是一个 <code>Promise </code>对象，返回该对象的结果。如果不是 <code>Promise </code>对象，就直接返回对应的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1 fn2 3 2 </span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async </code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>
<h2 id="请写出至少两种常见的数组排序的方法（原生js）"><a href="#请写出至少两种常见的数组排序的方法（原生js）" class="headerlink" title="请写出至少两种常见的数组排序的方法（原生js）"></a>请写出至少两种常见的数组排序的方法（原生js）</h2><h2 id="请写至少三种数组去重的方法？（原生js）"><a href="#请写至少三种数组去重的方法？（原生js）" class="headerlink" title="请写至少三种数组去重的方法？（原生js）"></a>请写至少三种数组去重的方法？（原生js）</h2><h2 id="知道lodash吗？它有哪些常见的API-？"><a href="#知道lodash吗？它有哪些常见的API-？" class="headerlink" title="知道lodash吗？它有哪些常见的API  ？"></a>知道lodash吗？它有哪些常见的API  ？</h2><p>clone()浅拷贝</p>
<p>clonedeep() 深拷贝</p>
<h2 id="平时都是用那些工具进行打包的？babel是什么？"><a href="#平时都是用那些工具进行打包的？babel是什么？" class="headerlink" title="平时都是用那些工具进行打包的？babel是什么？"></a>平时都是用那些工具进行打包的？babel是什么？</h2><p>webpack</p>
<p>对代码进行语法降级,解决兼容性</p>
<h2 id="谈谈Set-、-map-是什么？"><a href="#谈谈Set-、-map-是什么？" class="headerlink" title="谈谈Set 、 map 是什么？"></a>谈谈Set 、 map 是什么？</h2><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a><code>Set</code>（集合）</h3><ul>
<li><strong>定义：</strong> <code>Set</code> 是一种值的有序列表，其中的值必须是唯一的，不允许重复。</li>
<li><strong>特点：</strong><ul>
<li>不允许重复的值。</li>
<li><code>Set</code> 中的元素是有序的，插入顺序即为遍历顺序。</li>
<li>可以包含任意数据类型，包括基本类型和对象引用。</li>
</ul>
</li>
<li><strong>常用操作：</strong><ul>
<li><code>add(value)</code>: 向集合中添加一个新元素。</li>
<li><code>delete(value)</code>: 从集合中删除一个元素。</li>
<li><code>has(value)</code>: 判断集合中是否包含某个元素。</li>
<li><code>size</code>: 获取集合中元素的个数。</li>
<li><code>clear()</code>: 清空集合中的所有元素。</li>
</ul>
</li>
</ul>
<h3 id="Map（映射）"><a href="#Map（映射）" class="headerlink" title="Map（映射）"></a>Map（映射）</h3><ul>
<li><strong>定义：</strong> <code>Map</code> 是一种键值对的集合，每个键对应一个值。</li>
<li><strong>特点：</strong><ul>
<li>键和值可以是任意数据类型。</li>
<li>与对象不同，<code>Map</code> 保留了键的插入顺序。</li>
<li><code>Map</code> 的键是唯一的，每个键只能对应一个值。</li>
</ul>
</li>
<li><strong>常用操作：</strong><ul>
<li>&#96;&#96;Set<code>(key, value)</code>: 设置键值对。</li>
<li><code>get(key)</code>: 获取键对应的值。</li>
<li><code>delete(key)</code>: 删除键值对。</li>
<li><code>has(key)</code>: 判断是否包含某个键。</li>
<li><code>size</code>: 获取 Map 中键值对的个数。</li>
<li><code>clear()</code>: 清空 Map 中的所有键值对。</li>
</ul>
</li>
</ul>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul>
<li><code>Set</code> 的使用场景：<ul>
<li>去重：利用 <code>Set</code> 的唯一性可以轻松实现数组去重。</li>
<li>判断值是否存在。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uniqueArray = [...<span class="keyword">new</span> <span class="string">`Set`</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>])]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Map 的使用场景：<ul>
<li>存储和查找键值对数据。</li>
<li>保持键的顺序。</li>
<li>与对象相比，键可以是任意数据类型，不仅限于字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">myMap.<span class="string">`Set`</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line">myMap.<span class="string">`Set`</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// &#x27;John&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap.<span class="property">size</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载是怎么实现的？"><a href="#图片懒加载是怎么实现的？" class="headerlink" title="图片懒加载是怎么实现的？"></a>图片懒加载是怎么实现的？</h2><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用<code>HTML5</code> 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p>
<p>注意：<code>data-xxx</code> 中的xxx可以自定义，这里我们使用<code>data-src</code>来定义。</p>
<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>
<p>使用原生<code>JavaScript</code>实现懒加载：<br>知识点：<br>（1）<code>window.innerHeight</code> 是浏览器可视区的高度<br>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离<br>（3）<code>imgs.off</code>Set<code>Top</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）<br>（4）图片加载条件：<code>img.offSetTop &lt; window.innerHeight + document.body.scrollTop;</code><br>图示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0" style="zoom:50%;" />



<h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a>for in 和 for of 的区别</h2><p><code>for in</code>遍历对象的键也就是属性名,返回的是对应的索引下标</p>
<p><code>for of</code> 遍历的是可迭代对象的元素也就是值</p>
<h2 id="slice和aplice的区别"><a href="#slice和aplice的区别" class="headerlink" title="slice和aplice的区别"></a>slice和aplice的区别</h2><h3 id="slice-方法："><a href="#slice-方法：" class="headerlink" title="slice 方法："></a><code>slice</code> 方法：</h3><ol>
<li><p><strong>作用</strong>：</p>
<ul>
<li><code>slice</code> 方法用于创建一个新的数组，其中包含从原始数组中选择的元素。</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">array.<span class="title function_">slice</span>(start, end)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>start</code>：开始提取元素的位置（包含该位置的元素）。</li>
<li><code>end</code>：提取元素的结束位置（不包含该位置的元素）。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>不修改原始数组，而是返回一个新的数组。</li>
<li>如果省略 <code>end</code> 参数，<code>slice</code> 方法会提取从 <code>start</code> 位置到数组末尾的所有元素。</li>
<li>参数可以是负数，表示从数组末尾开始计数的位置。</li>
</ul>
</li>
</ol>
<h3 id="splice-方法："><a href="#splice-方法：" class="headerlink" title="splice 方法："></a><code>splice</code> 方法：</h3><ol>
<li><p><strong>作用</strong>：</p>
<ul>
<li><code>splice</code> 方法用于在数组中添加或删除元素，可以修改原始数组。</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">array.<span class="title function_">splice</span>(start, deleteCount, item1, item2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>start</code>：开始改变数组的位置。</li>
<li><code>deleteCount</code>：要移除的元素个数（可选，如果设置为 0，则不会删除元素）。</li>
<li><code>item1, item2, ...</code>：要添加到数组的新元素（可选）。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>修改原始数组，返回被删除的元素组成的数组。</li>
<li>如果 <code>deleteCount</code> 为 0，<code>splice</code> 可以用于插入新元素。</li>
<li>参数可以是负数，表示从数组末尾开始计数的位置。</li>
</ul>
</li>
</ol>
<h3 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><code>slice</code> 不会改变原始数组，而是返回一个新的数组。</li>
<li><code>splice</code> 会改变原始数组，返回被删除的元素组成的数组。</li>
<li><code>slice</code> 用于提取数组的一部分，而不影响原数组。</li>
<li><code>splice</code> 用于添加、删除或替换数组的元素，并且会直接修改原数组。</li>
<li><code>slice</code> 的第二个参数是结束位置（不包含该位置的元素），而 <code>splice</code> 的第二个参数是要删除的元素个数。</li>
<li><code>splice</code> 还可以接受多个参数，用于在指定位置插入新的元素。</li>
</ul>
<h2 id="substr和substring的区别"><a href="#substr和substring的区别" class="headerlink" title="substr和substring的区别"></a>substr和substring的区别</h2><h3 id="substr-方法："><a href="#substr-方法：" class="headerlink" title="substr 方法："></a><code>substr</code> 方法：</h3><ol>
<li><p><strong>作用</strong>：</p>
<ul>
<li><code>substr</code> 方法用于返回字符串中从指定位置开始的指定长度的子字符串。</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.<span class="title function_">substr</span>(start, length)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>start</code>：开始提取字符的位置，可以是正整数或负整数。如果是负数，表示从字符串末尾开始计算。</li>
<li><code>length</code>：可选，要提取的字符数。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>如果省略 <code>length</code> 参数，<code>substr</code> 会一直提取到字符串的末尾。</li>
<li>如果 <code>start</code> 是负数，它将被视为从字符串末尾开始的位置。</li>
<li>如果 <code>length</code> 是负数或零，它会被视为零。</li>
</ul>
</li>
</ol>
<h3 id="substring-方法："><a href="#substring-方法：" class="headerlink" title="substring 方法："></a><code>substring</code> 方法：</h3><ol>
<li><p><strong>作用</strong>：</p>
<ul>
<li><code>substring</code> 方法用于返回字符串中在两个指定下标之间的子字符串。</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">string.<span class="title function_">substring</span>(start, end)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>start</code>：必须是非负整数，指定子字符串的开始位置。</li>
<li><code>end</code>：可选，必须是非负整数，指定子字符串的结束位置（不包含该位置的字符）。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>如果省略 <code>end</code> 参数，<code>substring</code> 会一直提取到字符串的末尾。</li>
<li><code>substring</code> 不接受负数参数，如果出现负数，会被视为零。</li>
<li>如果 <code>start</code> 大于 <code>end</code>，<code>substring</code> 会自动交换这两个参数。</li>
</ul>
</li>
</ol>
<h3 id="区别总结：-1"><a href="#区别总结：-1" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><code>substr</code> 的第二个参数是要提取的字符数，而 <code>substring</code> 的第二个参数是子字符串的结束位置。</li>
<li><code>substr</code> 允许使用负数作为起始位置，而 <code>substring</code> 不接受负数参数。</li>
<li>如果省略第二个参数，<code>substr</code> 会一直提取到字符串的末尾，而 <code>substring</code> 也会一直提取到末尾，直到字符串的长度。</li>
<li>如果 <code>start</code> 大于 <code>end</code>，<code>substring</code> 会自动交换这两个参数；而对于 <code>substr</code>，如果 <code>start</code> 大于字符串的长度，返回空字符串。</li>
</ul>
<h2 id="能修改原数组的方法有哪些"><a href="#能修改原数组的方法有哪些" class="headerlink" title="能修改原数组的方法有哪些?"></a>能修改原数组的方法有哪些?</h2><ol>
<li><p><strong>push</strong>：</p>
<ul>
<li>在数组末尾添加一个或多个元素，并返回修改后数组的长度。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// arr 现在为 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pop</strong>：</p>
<ul>
<li>移除数组末尾的元素，并返回被移除的元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> removedElement = arr.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// arr 现在为 [1, 2, 3, 4]，removedElement 为 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>shift</strong>：</p>
<ul>
<li>移除数组的第一个元素，并返回被移除的元素。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> removedElement = arr.<span class="title function_">shift</span>();</span><br><span class="line"><span class="comment">// arr 现在为 [2, 3, 4, 5]，removedElement 为 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unshift</strong>：</p>
<ul>
<li>在数组的开头添加一个或多个元素，并返回修改后数组的长度。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// arr 现在为 [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>splice</strong>：</p>
<ul>
<li>通过删除或替换现有元素或者添加新元素来修改数组。该方法返回被删除的元素组成的数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> removedElements = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// arr 现在为 [1, 6, 7, 4, 5]，removedElements 为 [2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reverse</strong>：</p>
<ul>
<li>颠倒数组中元素的顺序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="comment">// arr 现在为 [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>sort</strong>：</p>
<ul>
<li>对数组元素进行排序，可以接受一个比较函数作为参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">// arr 现在为 [1, 2, 4, 5, 8]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="说一下你对事件委托的理解"><a href="#说一下你对事件委托的理解" class="headerlink" title="说一下你对事件委托的理解"></a>说一下你对事件委托的理解</h2><h2 id="说一说事件的执行过程"><a href="#说一说事件的执行过程" class="headerlink" title="说一说事件的执行过程"></a>说一说事件的执行过程</h2><h2 id="中断循环的方式-如何中断forEach"><a href="#中断循环的方式-如何中断forEach" class="headerlink" title="中断循环的方式,如何中断forEach"></a>中断循环的方式,如何中断forEach</h2><h2 id="如何判断后台返回的数据是一个空对象"><a href="#如何判断后台返回的数据是一个空对象" class="headerlink" title="如何判断后台返回的数据是一个空对象"></a>如何判断后台返回的数据是一个空对象</h2><h2 id="数组、对象解构如何实现"><a href="#数组、对象解构如何实现" class="headerlink" title="数组、对象解构如何实现"></a>数组、对象解构如何实现</h2><h2 id="如何二次封装axios"><a href="#如何二次封装axios" class="headerlink" title="如何二次封装axios"></a>如何二次封装axios</h2><h2 id="如何进行接口联调"><a href="#如何进行接口联调" class="headerlink" title="如何进行接口联调"></a>如何进行接口联调</h2><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a><strong>promise</strong></h2><h4 id="promise-是什么"><a href="#promise-是什么" class="headerlink" title="promise 是什么?"></a>promise 是什么?</h4><p>概念：**<code>Promise</code>** 对象表示异步操作最终的完成（或失败）以及其结果值</p>
<p>这是引用MDN上面的概念，十分的晦涩难懂,简单来说，所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，它可以获取异步操作的消息</p>
<p>它是ES6新增的语法,主要是为了解决异步函数的层层调用带来的回调地狱问题</p>
<h4 id="promise-的API"><a href="#promise-的API" class="headerlink" title="promise 的API"></a>promise 的API</h4><p>静态方法</p>
<p>&#x3D;&#x3D;resolve&#x3D;&#x3D;</p>
<p>在异步任务执行成功时会执行,并最终会把结果作为参数带到外面的<code>promise</code>对象实例的<code>.then</code>方法里</p>
<p>&#x3D;&#x3D;reject&#x3D;&#x3D;</p>
<p>在异步任务执行失败时会执行,并最终会把结果作为参数带到外面的<code>promise</code>对象实例的<code>.catch</code>方法里*</p>
<p>&#x3D;&#x3D;all&#x3D;&#x3D;</p>
<p>并行执行多个异步任务,并且会在所有的异步任务执行完毕之后执行回调,他会接收一个数组异步函数作为参数,它也是会进行异步执行的等上一个任务执行完毕之后才会执行第二个异步任务函数,最终会等数组里面所有的异步任务函数执行完毕后返回一个结果</p>
<p>&#x3D;&#x3D;race&#x3D;&#x3D;</p>
<p><code>.all</code>方法是以谁跑的慢以谁为执行标准,它会等待所有的异步任务执行完毕后,再执行实例对象的<code>.then</code>方法输出结果</p>
<p>而<code>.race</code>方法和<code>.all</code>方法相反,它会看哪一个任务执行完毕了之后,就直接执行了实例对象的<code>.then</code>方法输出结果</p>
<p>实例方法</p>
<p>&#x3D;&#x3D;then&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;catch&#x3D;&#x3D;</p>
<h2 id="如何改变-promise-的状态"><a href="#如何改变-promise-的状态" class="headerlink" title="如何改变 promise 的状态"></a>如何改变 promise 的状态</h2><p>前面说过<code>promise</code>是一个对象,他会接收一个回调函数作为参数,并且会立即执行</p>
<p>里面的回调函数有两个参数:（由 <code>JavaScript</code> 引擎提供，不用自己部署）</p>
<p>参数1: <code>resolve</code> 函数,将<code>Promise</code> 表示从发送请求时的<code>pending</code>状态变为<code>fullfiled</code>，会在异步操作成功时调用，并将结果作为参数传递出去</p>
<p>参数2: <code>reject</code> 函数, 将<code>Promise</code> 表示从发送请求时的<code>pending</code>状态变为<code>reject</code>，会在异步操作失败时调用，并将结果作为参数传递出去</p>
<h2 id="链式调用-promises-A-规范"><a href="#链式调用-promises-A-规范" class="headerlink" title="链式调用: promises&#x2F;A+规范"></a>链式调用: promises&#x2F;A+规范</h2><h1 id="手写系列"><a href="#手写系列" class="headerlink" title="手写系列"></a>手写系列</h1><h2 id="手写-promise"><a href="#手写-promise" class="headerlink" title="手写 promise"></a>手写 promise</h2><h2 id="手写闭包"><a href="#手写闭包" class="headerlink" title="手写闭包"></a>手写闭包</h2><h2 id="手写递归"><a href="#手写递归" class="headerlink" title="手写递归"></a>手写递归</h2><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="说说var、let、const之间的区别"><a href="#说说var、let、const之间的区别" class="headerlink" title="说说var、let、const之间的区别"></a>说说var、let、const之间的区别</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var声明的变量是全局变量,也就是顶级对象</p>
<p>var声明的变量会进行变量提升,在对代码进行编译的时候会把变量的声明提升到代码最前面,</p>
<p>可以对变量重新赋值,后面的变量会覆盖前面的</p>
<p>函数内声明的变量是局部变量,如果不使用var那么变量就是全局的</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let声明的变量有块级作用域</p>
<p>无法重复赋值会报错</p>
<p>变量声声明前都是不可用的,也就是暂时性死区</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>只读的一个常量,一旦声明不可以被改变</p>
<p>const声明的变量必须要进行初始化</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><p><strong>1.变量提升</strong></p>
<p>var会进行变量提升,可以在变量在声明之前被调用,值为undefind</p>
<p>let,const不会</p>
<p><strong>2.暂时性死区</strong></p>
<p>var没有暂时性死区</p>
<p>let和const存在暂时性死区,也就是只会在代码执行到变量声明的那一行才可以获取到值</p>
<p><strong>3.块级作用域</strong></p>
<p>var没有块级作用域</p>
<p>let和cost有块级作用域</p>
<p><strong>4.重复声明</strong></p>
<p>var可以重复声明</p>
<p>let和const在同一作用域下不能重复声明</p>
<p><strong>5.变量声明的修改</strong></p>
<p>let和var可以修改声明的变量</p>
<p>const声明的是一个常量,一旦声明不可以被修改,修改会报错</p>
<h2 id="ES6中数组新增了哪些扩展"><a href="#ES6中数组新增了哪些扩展" class="headerlink" title="ES6中数组新增了哪些扩展?"></a>ES6中数组新增了哪些扩展?</h2><h2 id="ES6中对象新增了哪些扩展"><a href="#ES6中对象新增了哪些扩展" class="headerlink" title="ES6中对象新增了哪些扩展?"></a>ES6中对象新增了哪些扩展?</h2><h2 id="ES6中函数新增了哪些扩展"><a href="#ES6中函数新增了哪些扩展" class="headerlink" title="ES6中函数新增了哪些扩展?"></a>ES6中函数新增了哪些扩展?</h2><h2 id="ES6中新增的Set、Map两种数据结构怎么理解"><a href="#ES6中新增的Set、Map两种数据结构怎么理解" class="headerlink" title="ES6中新增的Set、Map两种数据结构怎么理解?"></a>ES6中新增的<code>Set</code>、Map两种数据结构怎么理解?</h2><h2 id="你是怎么理解ES6中-Promise的？使用场景？"><a href="#你是怎么理解ES6中-Promise的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Promise的？使用场景？"></a>你是怎么理解ES6中 Promise的？使用场景？</h2><h2 id="怎么理解ES6中-Generator的？使用场景？"><a href="#怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="怎么理解ES6中 Generator的？使用场景？"></a>怎么理解ES6中 Generator的？使用场景？</h2><h2 id="你是怎么理解ES6中Proxy的？使用场景"><a href="#你是怎么理解ES6中Proxy的？使用场景" class="headerlink" title="你是怎么理解ES6中Proxy的？使用场景?"></a>你是怎么理解ES6中Proxy的？使用场景?</h2><h2 id="你是怎么理解ES6中Module的？使用场景？"><a href="#你是怎么理解ES6中Module的？使用场景？" class="headerlink" title="你是怎么理解ES6中Module的？使用场景？"></a>你是怎么理解ES6中Module的？使用场景？</h2><h2 id="你是怎么理解ES6中-Decorator-的？使用场景？"><a href="#你是怎么理解ES6中-Decorator-的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Decorator 的？使用场景？"></a>你是怎么理解ES6中 Decorator 的？使用场景？</h2><h2 id="ES6有哪些新特性？"><a href="#ES6有哪些新特性？" class="headerlink" title="ES6有哪些新特性？"></a>ES6有哪些新特性？</h2><ol>
<li><p><strong>箭头函数</strong>：</p>
<ul>
<li>箭头函数提供了更简洁的函数定义语法，并且绑定了词法作用域的 this。</li>
</ul>
</li>
<li><p><strong>let 和 const</strong>：</p>
<ul>
<li><code>let</code> 和 <code>const</code> 替代了 <code>var</code>，<code>let</code> 声明的变量具有块级作用域，<code>const</code> 声明常量，其值不可修改。</li>
</ul>
</li>
<li><p><strong>模板字符串</strong>：</p>
<ul>
<li>使用反引号 (&#96;&#96;) 定义字符串模板，可以跨行书写，支持变量插值和表达式。</li>
</ul>
</li>
<li><p><strong>解构赋值</strong>：</p>
<ul>
<li>方便地从数组或对象中提取数据，赋值给变量。</li>
</ul>
</li>
<li><p><strong>默认参数</strong>：</p>
<ul>
<li>函数参数可以设置默认值，简化函数的调用。</li>
</ul>
</li>
<li><p><strong>展开运算符（Spread Operator）</strong>：</p>
<ul>
<li><p>可以在数组、对象等可迭代对象中展开元素，简化数组拼接和对象合并等操作。</p>
<p>…</p>
</li>
</ul>
</li>
</ol>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="说说你对盒子模型的理解"><a href="#说说你对盒子模型的理解" class="headerlink" title="说说你对盒子模型的理解?"></a>说说你对盒子模型的理解?</h2><h2 id="css选择器有哪些？优先级？哪些属性可以继承？"><a href="#css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="css选择器有哪些？优先级？哪些属性可以继承？"></a>css选择器有哪些？优先级？哪些属性可以继承？</h2><p>CSS选择器用于选择要样式化的HTML元素。以下是一些常见的CSS选择器：</p>
<ol>
<li><p><strong>元素选择器：</strong></p>
<ul>
<li>通过元素名称选择元素。例如，<code>p</code> 选择所有段落元素。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类选择器：</strong></p>
<ul>
<li>通过类名选择元素。以点（<code>.</code>）开头，例如，<code>.my-class</code> 选择所有具有 <code>my-class</code> 类的元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.my-class &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ID 选择器：</strong></p>
<ul>
<li>通过元素的ID选择元素。以井号（<code>#</code>）开头，例如 <code>#my-id</code> 选择具有 <code>my-id</code> ID 的元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#my-id &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性选择器：</strong></p>
<ul>
<li>通过元素的属性选择元素。例如，<code>[type=&quot;text&quot;]</code> 选择所有 <code>type</code> 属性为 <code>text</code> 的元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[type=&quot;text&quot;] &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>后代选择器：</strong></p>
<ul>
<li>选择元素的后代。例如，<code>ul li</code> 选择所有 <code>ul</code> 元素下的 <code>li</code> 元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>伪类选择器：</strong></p>
<ul>
<li>选择元素的特定状态。例如，<code>:hover</code> 选择鼠标悬停在元素上的状态。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:hover &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>伪元素选择器：</strong></p>
<ul>
<li>选择元素的特定部分。例如，<code>::before</code> 在元素前添加内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p::before &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>CSS规定了不同选择器的优先级。优先级决定了当多个规则应用到同一元素时，哪个规则的样式将被应用。优先级从高到低依次是：</p>
<ol>
<li><p><strong>!important：</strong></p>
<ul>
<li>通过在样式规则中使用 <code>!important</code> 标志，可以将其优先级提升到最高。尽量少使用，因为它会增加维护难度。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    color: red !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内联样式：</strong></p>
<ul>
<li>使用 <code>style</code> 属性直接在元素上定义的样式。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style=&quot;color: blue;&quot;&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ID 选择器：</strong></p>
<ul>
<li>通过ID选择器定义的样式。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#my-id &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类选择器、属性选择器、伪类选择器：</strong></p>
<ul>
<li>类、属性、伪类选择器的优先级相同，按照出现的顺序来决定。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.my-class &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[type=&quot;text&quot;] &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元素选择器、伪元素选择器：</strong></p>
<ul>
<li>元素选择器和伪元素选择器的优先级相同，按照出现的顺序来决定。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p::before &#123;</span><br><span class="line">    /* styles */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h2><p>一些CSS属性可以被子元素继承。这意味着如果父元素具有特定样式，子元素将继承这些样式，除非子元素有自己的样式规则。常见的可继承属性包括：</p>
<ol>
<li><strong>字体相关属性：</strong><ul>
<li><code>font-family</code>、<code>font-size</code>、<code>font-weight</code>等。</li>
</ul>
</li>
<li><strong>文本相关属性：</strong><ul>
<li><code>color</code>、<code>line-height</code>、<code>text-align</code>等。</li>
</ul>
</li>
<li><strong>列表相关属性：</strong><ul>
<li><code>list-style-type</code>、<code>list-style-image</code>等。</li>
</ul>
</li>
<li><strong>表格相关属性：</strong><ul>
<li><code>border-collapse</code>、<code>border-spacing</code>等。</li>
</ul>
</li>
<li><strong>链接相关属性：</strong><ul>
<li><code>text-decoration</code>、<code>color</code>（在<code>a</code>标签中）等。</li>
</ul>
</li>
<li><strong>生成内容属性：</strong><ul>
<li><code>content</code>（在伪元素中）。</li>
</ul>
</li>
</ol>
<h2 id="说说em-px-rem-vh-vw区别"><a href="#说说em-px-rem-vh-vw区别" class="headerlink" title="说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?"></a>说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?</h2><h3 id="em："><a href="#em：" class="headerlink" title="em："></a>em：</h3><ul>
<li><p><strong>相对单位：</strong> <code>em</code> 是相对于其父元素的字体大小的单位。</p>
</li>
<li><p><strong>继承性：</strong> <code>em</code> 具有继承性，如果一个元素的字体大小是 <code>1.5em</code>，那么它将是父元素字体大小的1.5倍。</p>
</li>
<li><p><strong>用途：</strong> 常用于设置字体大小。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>; <span class="comment">/* 1.2 * 16px = 19.2px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="px："><a href="#px：" class="headerlink" title="px："></a>px：</h3><ul>
<li><p><strong>绝对单位：</strong> <code>px</code> 是绝对单位，表示像素。</p>
</li>
<li><p><strong>固定大小：</strong> <code>px</code> 的大小在不同设备上是固定的。</p>
</li>
<li><p><strong>用途：</strong> 常用于设置固定大小的元素，如边框、内外边距等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="rem："><a href="#rem：" class="headerlink" title="rem："></a>rem：</h3><ul>
<li><p><strong>相对根元素：</strong> <code>rem</code> 是相对于根元素（<code>html</code>）的字体大小的单位。</p>
</li>
<li><p><strong>相对一致：</strong> <code>rem</code> 的大小相对于根元素，使得在整个页面中保持一致。</p>
</li>
<li><p><strong>用途：</strong> 用于实现响应式布局，特别是对于整个页面的缩放。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>; <span class="comment">/* 1 * 16px = 16px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vh（视窗高度单位）："><a href="#vh（视窗高度单位）：" class="headerlink" title="vh（视窗高度单位）："></a>vh（视窗高度单位）：</h3><ul>
<li><p><strong>相对视窗高度：</strong> <code>vh</code> 表示相对于视窗高度的百分比。</p>
</li>
<li><p><strong>相对一致：</strong> 1vh 等于视窗高度的1%。</p>
</li>
<li><p><strong>用途：</strong> 常用于制作具有视窗高度相关布局的元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50vh</span>; <span class="comment">/* 视窗高度的50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vw（视窗宽度单位）："><a href="#vw（视窗宽度单位）：" class="headerlink" title="vw（视窗宽度单位）："></a>vw（视窗宽度单位）：</h3><ul>
<li><p><strong>相对视窗宽度：</strong> <code>vw</code> 表示相对于视窗宽度的百分比。</p>
</li>
<li><p><strong>相对一致：</strong> 1vw 等于视窗宽度的1%。</p>
</li>
<li><p><strong>用途：</strong> 常用于制作具有视窗宽度相关布局的元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25vw</span>; <span class="comment">/* 视窗宽度的25% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区别总结：-2"><a href="#区别总结：-2" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><strong>em：</strong> 相对于父元素的字体大小。</li>
<li><strong>px：</strong> 绝对单位，固定大小。</li>
<li><strong>rem：</strong> 相对于根元素的字体大小，用于实现整体页面的缩放。</li>
<li><strong>vh：</strong> 相对于视窗高度的百分比，用于视窗高度相关布局。</li>
<li><strong>vw：</strong> 相对于视窗宽度的百分比，用于视窗宽度相关布局。</li>
</ul>
<h2 id="说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#说说设备像素、css像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？"></a>说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？</h2><h2 id="谈谈你对BFC的理解？"><a href="#谈谈你对BFC的理解？" class="headerlink" title="谈谈你对BFC的理解？"></a>谈谈你对BFC的理解？</h2><p>BFC，即块级格式化上下文（Block Formatting Context），是CSS中一个重要的概念。BFC是页面上的一个独立的渲染区域，规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。</p>
<h3 id="BFC的特性："><a href="#BFC的特性：" class="headerlink" title="BFC的特性："></a>BFC的特性：</h3><ol>
<li><strong>块级盒子：</strong> BFC内部的所有元素都是块级盒子，这意味着它们按照块级盒子的标准布局。</li>
<li><strong>上下文独立：</strong> BFC内部的元素不会影响到外部元素，反之亦然。这意味着BFC内外的布局互不影响，使得页面布局更加灵活。</li>
<li><strong>阻止外边距重叠：</strong> 在同一个BFC中，相邻块级元素的外边距不会发生重叠。</li>
<li><strong>包含浮动：</strong> BFC会包含其内部的浮动元素，使得父元素可以自适应其内部浮动元素的高度。</li>
<li><strong>阻止文字环绕：</strong> BFC可以阻止文字环绕浮动元素，使得文字不会环绕在浮动元素的周围。</li>
</ol>
<h3 id="创建BFC的条件："><a href="#创建BFC的条件：" class="headerlink" title="创建BFC的条件："></a>创建BFC的条件：</h3><ol>
<li><strong>根元素：</strong> 页面的根元素（<code>&lt;html&gt;</code>）即为一个BFC。</li>
<li><strong>浮动元素：</strong> 元素的 <code>float</code> 属性不为 <code>none</code>。</li>
<li><strong>绝对定位元素：</strong> 元素的 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>。</li>
<li><strong>行内块元素：</strong> 元素的 <code>display</code> 属性为 <code>inline-block</code>。</li>
<li><strong>表格单元格元素：</strong> 元素的 <code>display</code> 属性为 <code>table-cell</code>。</li>
<li><strong>弹性盒子（Flex container）：</strong> 元素的 <code>display</code> 属性为 <code>flex</code> 或 <code>inline-flex</code>。</li>
<li><strong>网格布局容器（Grid container）：</strong> 元素的 <code>display</code> 属性为 <code>grid</code> 或 <code>inline-grid</code>。</li>
</ol>
<h3 id="BFC的应用场景："><a href="#BFC的应用场景：" class="headerlink" title="BFC的应用场景："></a>BFC的应用场景：</h3><ol>
<li><p><strong>清除浮动：</strong> 使用BFC可以清除浮动，避免父元素塌陷。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>防止外边距重叠：</strong> 在需要阻止外边距重叠的情况下，可以使用BFC。</p>
</li>
<li><p><strong>自适应两栏布局：</strong> 通过将父元素设为BFC，可以包含内部浮动元素，实现自适应两栏布局。</p>
</li>
<li><p><strong>阻止文字环绕：</strong> 在需要阻止文字环绕浮动元素的情况下，可以使用BFC。</p>
</li>
</ol>
<h2 id="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h2><h3 id="元素水平垂直居中的方法："><a href="#元素水平垂直居中的方法：" class="headerlink" title="元素水平垂直居中的方法："></a>元素水平垂直居中的方法：</h3><ol>
<li><p><strong>使用Flexbox：</strong></p>
<ul>
<li>对于容器，设置 <code>display: flex;</code> 和 <code>justify-content: center; align-items: center;</code>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用Grid布局：</strong></p>
<ul>
<li>对于容器，设置 <code>display: grid;</code> 和 <code>place-items: center;</code>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    place-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用绝对定位和负边距：</strong></p>
<ul>
<li>对于需要居中的元素，设置 <code>position: absolute;</code>，然后通过负边距和 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code> 组合实现居中。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用表格布局：</strong></p>
<ul>
<li>对于容器，设置 <code>display: table;</code>，然后对子元素设置 <code>display: table-cell; vertical-align: middle; text-align: center;</code>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="元素不定宽高的水平垂直居中："><a href="#元素不定宽高的水平垂直居中：" class="headerlink" title="元素不定宽高的水平垂直居中："></a>元素不定宽高的水平垂直居中：</h3><ol>
<li><p><strong>使用Flexbox和margin: auto：</strong></p>
<ul>
<li>对于容器，设置 <code>display: flex;</code> 和 <code>justify-content: center; align-items: center;</code>，然后对子元素设置 <code>margin: auto;</code>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用绝对定位和transform：</strong></p>
<ul>
<li>对于需要居中的元素，设置 <code>position: absolute;</code> 和 <code>transform: translate(-50%, -50%);</code>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用Flexbox和百分比定位：</strong></p>
<ul>
<li>对于容器，设置 <code>display: flex;</code> 和 <code>justify-content: center; align-items: center;</code>，然后对子元素设置 <code>position: relative;</code> 和 <code>top: 50%; left: 50%; transform: translate(-50%, -50%);</code>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.centered</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"><a href="#如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？" class="headerlink" title="如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"></a>如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</h2><h3 id="两栏布局，右侧自适应："><a href="#两栏布局，右侧自适应：" class="headerlink" title="两栏布局，右侧自适应："></a>两栏布局，右侧自适应：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">char</span>`<span class="attr">Set</span>`=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 固定宽度左侧栏 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 右侧自适应 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Two Column Layout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Main Content (Right Sidebar)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="三栏布局，中间自适应："><a href="#三栏布局，中间自适应：" class="headerlink" title="三栏布局，中间自适应："></a>三栏布局，中间自适应：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">char</span>`<span class="attr">Set</span>`=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 固定宽度左右栏 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 中间自适应 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Three Column Layout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>Main Content (Center)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Right Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="说说flexbox（弹性盒布局模型）-以及适用场景？"><a href="#说说flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="说说flexbox（弹性盒布局模型）,以及适用场景？"></a>说说flexbox（弹性盒布局模型）,以及适用场景？</h2><h2 id="介绍一下grid网格布局"><a href="#介绍一下grid网格布局" class="headerlink" title="介绍一下grid网格布局"></a>介绍一下grid网格布局</h2><h2 id="CSS3新增了哪些新特性？"><a href="#CSS3新增了哪些新特性？" class="headerlink" title="CSS3新增了哪些新特性？"></a>CSS3新增了哪些新特性？</h2><p>1.颜色:rgba和hsla模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-<span class="attr">color</span>: <span class="title function_">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.5</span>) <span class="comment">//白色半透明</span></span><br></pre></td></tr></table></figure>

<p>HSL和HSLA颜色：HSL代表色相、饱和度和亮度，而HSLA添加了Alpha通道。这种颜色表示方法更直观，允许你在颜色的基础上进行更精确的调整。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-<span class="attr">color</span>: <span class="title function_">hsl</span>(<span class="number">120</span>, <span class="number">100</span>%, <span class="number">50</span>%); <span class="comment">/* 设置绿色背景 */</span></span><br></pre></td></tr></table></figure>

<p>2.文字阴影<code>text-shadow</code></p>
<p>3.边框圆角<code>border-radius</code>,盒子阴影<code>box-shadow</code></p>
<p>4.盒子模型 <code>box-sizing</code></p>
<p>5.字体图标 <code>iconfont</code></p>
<p>6.弹性布局 <code>flex</code></p>
<h2 id="css3动画有哪些？"><a href="#css3动画有哪些？" class="headerlink" title="css3动画有哪些？"></a>css3动画有哪些？</h2><h2 id="怎么理解回流跟重绘？什么场景下会触发？"><a href="#怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="怎么理解回流跟重绘？什么场景下会触发？"></a>怎么理解回流跟重绘？什么场景下会触发？</h2><h3 id="回流（Reflow）："><a href="#回流（Reflow）：" class="headerlink" title="回流（Reflow）："></a>回流（Reflow）：</h3><ul>
<li><strong>定义：</strong> 回流是浏览器为了重新渲染部分或全部页面而重新计算元素的位置和几何结构的过程。</li>
<li><strong>触发场景：</strong> 回流会在以下情况下触发：<ol>
<li>添加或删除可见的DOM元素。</li>
<li>元素位置发生变化。</li>
<li>元素的尺寸发生变化（包括边距、填充、边框、宽度和高度变化）。</li>
<li>浏览器窗口尺寸发生变化。</li>
</ol>
</li>
<li><strong>影响：</strong> 回流是一种代价高昂的操作，会触发布局的重新计算，影响整个页面的渲染性能。</li>
</ul>
<h3 id="重绘（Repaint）："><a href="#重绘（Repaint）：" class="headerlink" title="重绘（Repaint）："></a>重绘（Repaint）：</h3><ul>
<li><strong>定义：</strong> 重绘是当元素样式发生改变，但不影响其布局时，浏览器将之前绘制的内容重新绘制的过程。</li>
<li><strong>触发场景：</strong> 重绘会在以下情况下触发：<ol>
<li>修改元素的颜色。</li>
<li>修改元素的背景。</li>
<li>修改元素的可见性。</li>
<li>修改元素的轮廓（边框）。</li>
</ol>
</li>
<li><strong>影响：</strong> 重绘的性能开销相对较小，因为它不会影响元素的布局，只需重新绘制颜色等样式信息。</li>
</ul>
<h3 id="优化建议："><a href="#优化建议：" class="headerlink" title="优化建议："></a>优化建议：</h3><ol>
<li><strong>避免直接操作样式：</strong> 使用<code>classList</code>等方法修改类名，一次性更改样式，减少回流和重绘的次数。</li>
<li><strong>使用文档片段：</strong> 对多次 DOM 操作，可以使用文档片段（DocumentFragment）来减少回流。</li>
<li><strong>离线操作：</strong> 在对 DOM 进行复杂操作时，可以将元素脱离文档流，完成操作后再放回文档流。</li>
<li><strong>使用定时器：</strong> 对于某些频繁触发的操作，可以使用定时器将其延迟执行，合并多次操作。</li>
<li><strong>优化动画：</strong> 对于频繁发生的动画，使用<code>transform</code>和<code>opacity</code>等属性进行优化，避免影响布局。</li>
</ol>
<h2 id="什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何做？</h2><h2 id="如果要做优化，CSS提高性能的方法有哪些？"><a href="#如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="如果要做优化，CSS提高性能的方法有哪些？"></a>如果要做优化，CSS提高性能的方法有哪些？</h2><h2 id="如何实现单行／多行文本溢出的省略样式？"><a href="#如何实现单行／多行文本溢出的省略样式？" class="headerlink" title="如何实现单行／多行文本溢出的省略样式？"></a>如何实现单行／多行文本溢出的省略样式？</h2><h2 id="如何使用css完成视差滚动效果"><a href="#如何使用css完成视差滚动效果" class="headerlink" title="如何使用css完成视差滚动效果?"></a>如何使用css完成视差滚动效果?</h2><h2 id="CSS如何画一个三角形？原理是什么？"><a href="#CSS如何画一个三角形？原理是什么？" class="headerlink" title="CSS如何画一个三角形？原理是什么？"></a>CSS如何画一个三角形？原理是什么？</h2><h2 id="让Chrome支持小于12px-的文字方式有哪些？区别？"><a href="#让Chrome支持小于12px-的文字方式有哪些？区别？" class="headerlink" title="让Chrome支持小于12px 的文字方式有哪些？区别？"></a>让Chrome支持小于12px 的文字方式有哪些？区别？</h2><h2 id="说说对Css预编语言的理解？有哪些区别"><a href="#说说对Css预编语言的理解？有哪些区别" class="headerlink" title="说说对Css预编语言的理解？有哪些区别?"></a>说说对Css预编语言的理解？有哪些区别?</h2><h2 id="在css中有哪些定位方式"><a href="#在css中有哪些定位方式" class="headerlink" title="在css中有哪些定位方式"></a>在css中有哪些定位方式</h2><ol>
<li><strong>Static（静态定位）：</strong><ul>
<li><code>position: static;</code></li>
<li>默认值，元素在正常文档流中定位，不受 top, right, bottom, left 属性的影响。</li>
</ul>
</li>
<li><strong>Relative（相对定位）：</strong><ul>
<li><code>position: relative;</code></li>
<li>相对于元素在正常文档流中的位置进行定位。通过设置 top, right, bottom, left 属性可以使元素相对于其正常位置进行移动。</li>
</ul>
</li>
<li><strong>Absolute（绝对定位）：</strong><ul>
<li><code>position: absolute;</code></li>
<li>相对于最近的已定位祖先元素（不包括 static 定位的元素），如果没有已定位的祖先元素，则相对于最初的包含块（通常是 <code>&lt;html&gt;</code> 元素）进行定位。</li>
</ul>
</li>
<li><strong>Fixed（固定定位）：</strong><ul>
<li><code>position: fixed;</code></li>
<li>相对于浏览器窗口进行定位，即使页面滚动，元素位置也不会改变。</li>
</ul>
</li>
<li><strong>Sticky（粘性定位）：</strong><ul>
<li><code>position: sticky;</code></li>
<li>相对于用户滚动的容器（滚动时相对于视窗，不滚动时相对于最近的块级祖先）进行定位。在容器滚动到某个阈值之前，元素为相对定位；之后，元素为固定定位。</li>
</ul>
</li>
</ol>
<h2 id="如何理解z-index"><a href="#如何理解z-index" class="headerlink" title="如何理解z-index?"></a>如何理解z-index?</h2><h2 id="如何画一个0-5像素的线"><a href="#如何画一个0-5像素的线" class="headerlink" title="如何画一个0.5像素的线"></a>如何画一个0.5像素的线</h2><h3 id="1-使用半透明颜色："><a href="#1-使用半透明颜色：" class="headerlink" title="1. 使用半透明颜色："></a>1. 使用半透明颜色：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 半透明黑色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，线条看起来会比较淡，模拟出0.5像素的效果。</p>
<h3 id="2-使用box-shadow："><a href="#2-使用box-shadow：" class="headerlink" title="2. 使用box-shadow："></a>2. 使用box-shadow：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.line</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.5px</span> <span class="number">0</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">/* 垂直偏移0.5像素的阴影，颜色为黑色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式利用 <code>box-shadow</code> 的模糊效果来实现，同样也可以模拟出较细的线条。</p>
<h2 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动?"></a>如何清除浮动?</h2><h2 id="你对媒体查询的理解"><a href="#你对媒体查询的理解" class="headerlink" title="你对媒体查询的理解"></a>你对媒体查询的理解</h2><h2 id="标准盒模型和怪异盒模型有哪些区别"><a href="#标准盒模型和怪异盒模型有哪些区别" class="headerlink" title="标准盒模型和怪异盒模型有哪些区别?"></a>标准盒模型和怪异盒模型有哪些区别?</h2><h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><h2 id="什么是HTTP-HTTP-和-HTTPS-的区别"><a href="#什么是HTTP-HTTP-和-HTTPS-的区别" class="headerlink" title="什么是HTTP? HTTP 和 HTTPS 的区别?"></a>什么是HTTP? HTTP 和 HTTPS 的区别?</h2><p>在回答这个问题时，你可以提供以下基本信息：</p>
<ol>
<li><strong>HTTP（Hypertext Transfer Protocol）：HTTP（超文本传输协议）：</strong><ul>
<li>HTTP是一种用于在Web上进行数据传输的协议。</li>
<li>它基于客户端-服务器模型，客户端发送请求，服务器返回响应。</li>
</ul>
</li>
<li><strong>HTTPS（Hypertext Transfer Protocol Secure）：HTTPS（安全超文本传输协议）：</strong><ul>
<li>HTTPS是HTTP的安全版本，通过加密通信内容来提高安全性。</li>
<li>它使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议来保护数据传输的安全性。</li>
</ul>
</li>
<li><strong>区别：</strong><ul>
<li><strong>安全性：</strong> HTTP是明文传输的，数据不加密，容易被中间人攻击。而HTTPS通过加密通信内容，确保数据的保密性和完整性，防止窃听和篡改。</li>
<li><strong>协议：</strong> HTTP使用标准的HTTP协议，而HTTPS在HTTP的基础上加入了SSL或TLS协议，通过这两种协议进行数据加密。</li>
<li><strong>端口：</strong> HTTP默认使用端口80，而HTTPS默认使用端口443。</li>
<li><strong>证书：</strong> 在使用HTTPS时，服务器需要获得一个数字证书，由可信任的证书颁发机构（CA）签发，用于验证服务器身份。而HTTP通信过程中无法验证服务器的真实性。</li>
</ul>
</li>
</ol>
<h2 id="为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？"><a href="#为什么说HTTPS比HTTP安全-HTTPS是如何保证安全的？" class="headerlink" title="为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？"></a>为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</h2><ol>
<li><strong>加密传输：</strong> HTTPS使用SSL（Secure Sockets Layer）或TLS（Transport Layer Security）协议对数据进行加密。这意味着在数据传输过程中，即使被截获，也难以被解读，因为只有具备解密密钥的接收方才能还原原始数据。这有助于防止窃听和数据篡改攻击。</li>
<li><strong>身份验证：</strong> 使用HTTPS的服务器需要获得数字证书，由可信任的证书颁发机构（CA）签发。这个证书用于验证服务器的身份。这种机制有助于防止中间人攻击，确保用户与服务器之间的通信是与正确的服务器建立的连接。</li>
<li><strong>数据完整性：</strong> 在HTTPS通信中，数据的完整性得到了保护，因为SSL&#x2F;TLS协议使用哈希函数对传输的数据进行摘要，确保数据在传输过程中没有被篡改或损坏。</li>
<li><strong>防范混合内容攻击：</strong> HTTPS可以防止混合内容攻击，即阻止非安全来源（HTTP）的内容与安全来源（HTTPS）的内容混合在同一个页面上，提高了整体安全性。</li>
</ol>
<h2 id="如何理解UDP-和-TCP-区别-应用场景"><a href="#如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="如何理解UDP 和 TCP? 区别? 应用场景?"></a>如何理解UDP 和 TCP? 区别? 应用场景?</h2><ol>
<li><strong>理解 UDP 和 TCP：</strong><ul>
<li><strong>UDP（User Datagram Protocol）：UDP（用户数据报协议）：</strong><ul>
<li>UDP是一种无连接的协议，它不提供像TCP那样的可靠性和顺序传输。</li>
<li>UDP通过数据包（Datagram）的方式发送数据，每个数据包都是一个独立的实体，相互之间没有关联。</li>
<li>UDP不保证数据的可靠性和顺序性，但由于其简单性和低开销，适用于一些实时性要求较高的应用场景。</li>
</ul>
</li>
<li><strong>TCP（Transmission Control Protocol）：TCP（传输控制协议）：</strong><ul>
<li>TCP是一种面向连接的协议，提供可靠的、有序的数据传输服务。</li>
<li>TCP通过建立连接、数据传输和断开连接的三个阶段来确保数据的完整性和有序性。</li>
<li>TCP使用流（Stream）的方式传输数据，数据被划分为小的数据块，并确保它们按照顺序传送到目标。</li>
</ul>
</li>
</ul>
</li>
<li><strong>区别：</strong><ul>
<li><strong>可靠性：</strong><ul>
<li>UDP是不可靠的，不保证数据的可靠性和顺序性。</li>
<li>TCP是可靠的，通过确认机制和重传机制确保数据的可靠传输。</li>
</ul>
</li>
<li><strong>连接性：</strong><ul>
<li>UDP是无连接的，每个数据包独立处理，相互之间没有关联。</li>
<li>TCP是面向连接的，通过建立连接来确保数据传输的完整性。</li>
</ul>
</li>
<li><strong>开销：</strong><ul>
<li>UDP的开销相对较低，适用于对实时性要求较高的场景。</li>
<li>TCP的开销较大，但能够提供可靠的、有序的数据传输。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li><strong>UDP：</strong><ul>
<li>适用于实时性要求较高、可以容忍少量数据丢失的场景，如音频和视频流的传输、在线游戏等。</li>
<li>由于UDP的简单性和低开销，也常用于广播和多播通信。</li>
</ul>
</li>
<li><strong>TCP：传输控制协议：</strong><ul>
<li>适用于对数据完整性和有序性要求较高的场景，如文件传输、Web页面加载、电子邮件等。</li>
<li>在需要确保每个数据包都能被正确接收的情况下，使用TCP更为合适。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="如何理解OSI七层模型"><a href="#如何理解OSI七层模型" class="headerlink" title="如何理解OSI七层模型?"></a>如何理解OSI七层模型?</h2><ol>
<li><strong>OSI 七层模型概述：</strong><ul>
<li>OSI七层模型是国际标准化组织（ISO）定义的网络体系结构模型，用于指导不同厂商的网络设备和协议的开发。</li>
<li>它将网络通信划分为七个逻辑层次，每个层次负责特定的功能，每个层次的功能都建立在下一层提供的服务之上。</li>
</ul>
</li>
<li><strong>七个层次及其功能：</strong><ol>
<li><strong>物理层（Physical Layer）：</strong><ul>
<li>主要关注数据的物理传输，例如电缆、光纤、物理连接等。</li>
<li>定义了数据的传输速率、电压等物理特性。</li>
</ul>
</li>
<li><strong>数据链路层（Data Link Layer）：</strong><ul>
<li>提供了可靠的点对点和点对多点通信。</li>
<li>通过帧（Frame）定义数据的格式，进行错误检测和纠正。</li>
</ul>
</li>
<li><strong>网络层（Network Layer）：</strong><ul>
<li>负责数据的路由和寻址，实现不同网络之间的通信。</li>
<li>使用IP地址标识网络上的设备，进行数据包的转发。</li>
</ul>
</li>
<li><strong>传输层（Transport Layer）：</strong><ul>
<li>提供端到端的通信服务，确保数据的可靠传输。</li>
<li>通过TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）实现数据的流控制和错误处理。</li>
</ul>
</li>
<li><strong>会话层（Session Layer）：</strong><ul>
<li>管理不同设备之间的通信会话，确保数据的有序传输。</li>
<li>提供建立、维护和关闭会话的功能。</li>
</ul>
</li>
<li><strong>表示层（Presentation Layer）：</strong><ul>
<li>负责数据的格式转换、加密和解密，确保数据的格式一致性。</li>
<li>处理数据的语法和语义问题。</li>
</ul>
</li>
<li><strong>应用层（Application Layer）：</strong><ul>
<li>提供网络服务和应用程序之间的接口。</li>
<li>包括用户界面、网络协议和各种应用。</li>
</ul>
</li>
</ol>
</li>
<li><strong>理解七层模型的好处：</strong><ul>
<li><strong>模块化设计：</strong> 每个层次都有特定的功能，使得网络设计更具模块化和可扩展性。</li>
<li><strong>标准化：</strong> 每个层次的功能都有明确定义的标准，促使了不同厂商设备和协议的互操作性。</li>
<li><strong>问题定位：</strong> 当网络出现问题时，七层模型有助于迅速定位问题所在的层次。</li>
</ul>
</li>
</ol>
<h2 id="如何理解TCP-IP协议"><a href="#如何理解TCP-IP协议" class="headerlink" title="如何理解TCP&#x2F;IP协议?"></a>如何理解TCP&#x2F;IP协议?</h2><ol>
<li><strong>TCP&#x2F;IP协议概述：</strong><ul>
<li>TCP&#x2F;IP是一组用于互联网通信的协议，包括Transmission Control Protocol (TCP) 和 Internet Protocol (IP)。</li>
<li>它是互联网的基础通信协议，被用于在网络中传输数据。</li>
</ul>
</li>
<li><strong>TCP 和 IP 的角色：</strong><ul>
<li><strong>TCP（Transmission Control Protocol）：TCP（传输控制协议）：</strong><ul>
<li>提供可靠的、面向连接的通信服务。</li>
<li>确保数据的可靠性、有序性和完整性，通过确认机制和重传机制实现。</li>
</ul>
</li>
<li><strong>IP（Internet Protocol）：IP（互联网协议）：</strong><ul>
<li>负责数据包的寻址和路由。</li>
<li>定义了数据包在网络中的传输方式，通过IP地址标识设备和网络。</li>
</ul>
</li>
</ul>
</li>
<li><strong>TCP&#x2F;IP协议族：</strong><ul>
<li>TCP&#x2F;IP协议族包含多个协议，不仅限于TCP和IP，还包括一系列支持网络通信的协议，如UDP、ICMP、ARP等。</li>
</ul>
</li>
<li><strong>分层结构：</strong><ul>
<li>TCP&#x2F;IP协议以分层结构组织，分为四个层次，分别是应用层、传输层、网络层和数据链路层。</li>
<li>这种分层结构有助于实现模块化设计和互操作性。</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li>TCP&#x2F;IP协议被广泛应用于互联网，支持各种应用，包括Web浏览、电子邮件、文件传输等。</li>
<li>它也是局域网（LAN）和广域网（WAN）中常用的协议。</li>
</ul>
</li>
<li><strong>开放标准：</strong><ul>
<li>TCP&#x2F;IP是一个开放标准，使得不同厂商的设备和软件可以互相通信，促进了互联网的发展和扩展。</li>
</ul>
</li>
</ol>
<h2 id="DNS协议-是什么？说说DNS-完整的查询过程"><a href="#DNS协议-是什么？说说DNS-完整的查询过程" class="headerlink" title="DNS协议 是什么？说说DNS 完整的查询过程?"></a>DNS协议 是什么？说说DNS 完整的查询过程?</h2><p>DNS（Domain Name System）是一种用于将域名（例如<a target="_blank" rel="noopener" href="http://www.example.com)转换为对应ip地址的分布式命名系统.它是互联网中用于解析域名的一种关键服务./">www.example.com）转换为对应IP地址的分布式命名系统。它是互联网中用于解析域名的一种关键服务。</a></p>
<p>DNS查询过程涉及多个步骤，以下是DNS完整的查询过程：</p>
<ol>
<li><strong>本地缓存查询：</strong><ul>
<li>首先，计算机会检查本地缓存，查看之前解析过的域名是否存在于缓存中。如果存在，且尚未过期，就直接使用缓存中的IP地址，从而避免了向DNS服务器发送请求。</li>
</ul>
</li>
<li><strong>递归查询：</strong><ul>
<li>如果本地缓存中没有相应的记录，计算机将向本地DNS服务器发起递归查询。本地DNS服务器通常由Internet服务提供商（ISP）或其他网络服务提供商提供。</li>
</ul>
</li>
<li><strong>本地DNS服务器查询根域名服务器：</strong><ul>
<li>如果本地DNS服务器无法解析域名，它将向根域名服务器发送查询请求。根域名服务器是全球DNS体系结构的起始点，负责指导DNS查询进入正确的顶级域名服务器。</li>
</ul>
</li>
<li><strong>根域名服务器返回顶级域名服务器地址：</strong><ul>
<li>根域名服务器收到请求后，返回顶级域名服务器的地址。顶级域名服务器负责管理特定顶级域（如.com、.org）下的域名信息。</li>
</ul>
</li>
<li><strong>本地DNS服务器查询顶级域名服务器：</strong><ul>
<li>本地DNS服务器向顶级域名服务器发起查询请求，请求该域名对应的下一级域名服务器的地址。</li>
</ul>
</li>
<li><strong>顶级域名服务器返回权威域名服务器地址：</strong><ul>
<li>顶级域名服务器返回包含权威域名服务器地址的响应。权威域名服务器是负责管理特定域的具体域名解析信息的服务器。</li>
</ul>
</li>
<li><strong>本地DNS服务器查询权威域名服务器：</strong><ul>
<li>本地DNS服务器向权威域名服务器发起查询请求，请求解析特定域名的IP地址。</li>
</ul>
</li>
<li><strong>权威域名服务器返回解析结果：</strong><ul>
<li>权威域名服务器返回包含目标域名的IP地址的响应给本地DNS服务器。</li>
</ul>
</li>
<li><strong>本地DNS服务器缓存结果：</strong><ul>
<li>本地DNS服务器将从权威域名服务器获取的IP地址存储在缓存中，以备将来使用，并将解析结果返回给计算机。</li>
</ul>
</li>
<li><strong>计算机使用IP地址访问目标网站：</strong><ul>
<li>最后，计算机获得了域名对应的IP地址，并可以使用该IP地址与目标服务器建立连接，实现数据传输。</li>
</ul>
</li>
</ol>
<h2 id="如何理解CDN？说说实现原理？"><a href="#如何理解CDN？说说实现原理？" class="headerlink" title="如何理解CDN？说说实现原理？"></a>如何理解CDN？说说实现原理？</h2><p>CDN（Content Delivery Network）是一种用于提高网络性能、减少加载时间以及增强网站安全性的分布式服务。CDN的主要目标是通过在全球范围内部署多个服务器节点，将网站的静态资源（如图像、样式表、脚本等）缓存到这些节点上，从而使用户可以从离他们更近的服务器获取这些资源，提高访问速度和用户体验。</p>
<p>CDN的实现原理包括以下关键步骤：</p>
<ol>
<li><strong>内容缓存和分发：</strong><ul>
<li>CDN提供商将网站的静态内容（如图片、视频、CSS、JavaScript等）复制到位于全球各地的多个服务器节点上。这些节点通常分布在不同的地理位置，覆盖各个大洲和国家。</li>
</ul>
</li>
<li><strong>DNS解析优化：</strong><ul>
<li>当用户发起访问请求时，CDN通过DNS解析确定用户的地理位置，并将用户的请求引导到离用户最近的CDN服务器。这通过将域名映射到最近的CDN服务器IP地址来实现。</li>
</ul>
</li>
<li><strong>请求处理和内容提供：</strong><ul>
<li>用户的请求被发送到最近的CDN服务器，该服务器检查是否已缓存所请求的内容。如果缓存中存在，则直接返回缓存的内容；如果不存在，则向源服务器请求内容，并将内容缓存起来，供将来的请求使用。</li>
</ul>
</li>
<li><strong>动态内容优化：</strong><ul>
<li>对于动态内容（如个性化的用户数据、动态生成的页面等），CDN提供商可能使用一些技术，如边缘计算（Edge Computing）或者将请求转发到源服务器。这确保了即使是动态生成的内容也能在用户附近快速响应。</li>
</ul>
</li>
<li><strong>负载均衡：</strong><ul>
<li>CDN使用负载均衡算法来分配用户请求到不同的服务器节点，以确保每个节点都能平均处理请求负荷，提高整体的性能和可靠性。</li>
</ul>
</li>
<li><strong>安全性增强：</strong><ul>
<li>CDN通常提供安全功能，如DDoS攻击防护、SSL加密等，以增强网站的安全性。</li>
</ul>
</li>
<li><strong>实时监控和分析：</strong><ul>
<li>CDN提供商通常通过实时监控和分析来了解网络状况，根据流量负载和性能指标动态调整服务器节点的分发策略，以最优化内容传递。</li>
</ul>
</li>
</ol>
<h2 id="说说-HTTP1-0-1-1-2-0-的区别"><a href="#说说-HTTP1-0-1-1-2-0-的区别" class="headerlink" title="说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?"></a>说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</h2><ol>
<li><strong>HTTP 1.0：</strong><ul>
<li><strong>连接管理：</strong> 使用短连接（short-lived connections），每个请求&#x2F;响应都需要建立一个新的TCP连接。这导致了高延迟和性能低效。</li>
<li><strong>性能：</strong> 每个请求只能得到一个响应，不能复用连接，导致性能相对较差。</li>
<li><strong>无状态：</strong> HTTP 1.0是无状态的，每个请求都是独立的，服务器不会保留任何关于客户端状态的信息。</li>
</ul>
</li>
<li><strong>HTTP 1.1：</strong><ul>
<li><strong>持久连接：</strong> 引入了持久连接（persistent connections），允许在单个TCP连接上发送多个请求和响应，减少了连接建立的开销。</li>
<li><strong>管道化：</strong> 支持请求&#x2F;响应的管道化，可以在一个连接上同时发送多个请求，但由于实现的复杂性和一些潜在的问题，该特性并没有被广泛采用。</li>
<li><strong>分块传输编码：</strong> 支持分块传输编码（chunked transfer encoding），允许服务器逐块发送响应，而不需要等到整个响应生成完成。</li>
</ul>
</li>
<li><strong>HTTP 2.0：</strong><ul>
<li><strong>多路复用：</strong> 最显著的改变是引入了多路复用（multiplexing），允许在单个连接上同时发送多个请求和响应，解决了头阻塞问题，提高了性能。</li>
<li><strong>二进制协议：</strong> 使用二进制格式替代了文本格式，提高了解析的效率。</li>
<li><strong>头部压缩：</strong> 引入了头部压缩（header compression），减小了传输的开销。</li>
<li><strong>服务器推送：</strong> 支持服务器推送，服务器可以在客户端请求之前将额外的资源推送给客户端，提高性能。</li>
</ul>
</li>
</ol>
<h2 id="说说-HTTP-常见的状态码有哪些，适用场景？"><a href="#说说-HTTP-常见的状态码有哪些，适用场景？" class="headerlink" title="说说 HTTP 常见的状态码有哪些，适用场景？"></a>说说 HTTP 常见的状态码有哪些，适用场景？</h2><p>200 表示请求成功</p>
<p>301访问地址永久重定向</p>
<p>302 临时重定向</p>
<p>400-499 客户端错误</p>
<p>401 表示未授权</p>
<p>403 表示禁止访问,没有权限</p>
<p>404 表示请求地址错误,没有对应的资源文件</p>
<p>500 表示服务端错误</p>
<h2 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h2><ol>
<li><strong>用途：</strong><ul>
<li><strong>GET：</strong> 主要用于请求获取资源，参数通常附加在URL的末尾，通过查询字符串传递。GET请求应该是幂等的，即多次请求的结果应该是一致的，不应该有副作用。</li>
<li><strong>POST：</strong> 主要用于向服务器提交数据，通常通过请求体传递参数。POST请求可以用于更新服务器上的资源，可能有副作用，不一定是幂等的。</li>
</ul>
</li>
<li><strong>数据传输方式：</strong><ul>
<li><strong>GET：</strong> 数据通过URL的查询字符串传递，可见于URL中，有长度限制。适合传递少量的非敏感数据。</li>
<li><strong>POST：</strong> 数据传递在请求体中，对传输的数据类型没有限制，可以传递大量数据，更安全，因为数据不会出现在URL中。</li>
</ul>
</li>
<li><strong>安全性：</strong><ul>
<li><strong>GET：</strong> 因为数据在URL中可见，不适合传递敏感信息，例如密码等。GET请求更容易被缓存，被浏览器记录，不适合用于传输敏感信息。</li>
<li><strong>POST：</strong> 数据传递在请求体中，相对于GET更安全，适合用于传输敏感信息，如登录凭据。</li>
</ul>
</li>
<li><strong>可缓存性：</strong><ul>
<li><strong>GET：</strong> 请求结果容易被缓存，可以被浏览器添加到浏览器历史记录。</li>
<li><strong>POST：</strong> 请求结果不容易被缓存，不会被浏览器添加到浏览器历史记录。</li>
</ul>
</li>
<li><strong>幂等性：</strong><ul>
<li><strong>GET：</strong> 应该是幂等的，多次请求的结果应该是一致的。</li>
<li><strong>POST：</strong> 不要求幂等性，多次请求可能导致不同的结果。</li>
</ul>
</li>
</ol>
<h2 id="说说-HTTP-常见的请求头有哪些-作用？"><a href="#说说-HTTP-常见的请求头有哪些-作用？" class="headerlink" title="说说 HTTP 常见的请求头有哪些? 作用？"></a>说说 HTTP 常见的请求头有哪些? 作用？</h2><ol>
<li><strong>Host:</strong><ul>
<li><strong>作用：</strong> 指定服务器的域名和端口号，告诉服务器请求的目标是哪个主机。</li>
<li><strong>示例：</strong> <code>Host: www.example.com</code></li>
</ul>
</li>
<li><strong>User-Agent:</strong><ul>
<li><strong>作用：</strong> 标识客户端的类型和版本，帮助服务器了解请求的来源。</li>
<li><strong>示例：</strong> <code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</code></li>
</ul>
</li>
<li><strong>Accept:</strong><ul>
<li><strong>作用：</strong> 告诉服务器客户端能够处理哪些类型的响应数据，通常是指MIME类型。</li>
<li><strong>示例：</strong> <code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</code></li>
</ul>
</li>
<li><strong>Accept-Language:</strong><ul>
<li><strong>作用：</strong> 指定客户端能够接受的语言类型，用于服务器选择合适的语言返回响应。</li>
<li><strong>示例：</strong> <code>Accept-Language: en-US,en;q=0.5</code></li>
</ul>
</li>
<li><strong>Accept-Encoding:</strong><ul>
<li><strong>作用：</strong> 指定客户端支持的内容编码方式，服务器可以使用这些编码来压缩响应数据。</li>
<li><strong>示例：</strong> <code>Accept-Encoding: gzip, deflate</code></li>
</ul>
</li>
<li><strong>Connection:</strong><ul>
<li><strong>作用：</strong> 控制是否需要持久连接，或者在请求完成后关闭连接。</li>
<li><strong>示例：</strong> <code>Connection: keep-alive</code></li>
</ul>
</li>
<li><strong>Referer:</strong><ul>
<li><strong>作用：</strong> 表示请求的来源，即当前请求是从哪个URL过来的。</li>
<li><strong>示例：</strong> <code>Referer: http://www.example.com/page</code></li>
</ul>
</li>
<li><strong>Cookie:</strong><ul>
<li><strong>作用：</strong> 包含客户端的Cookie信息，用于在请求中传递会话信息等状态。</li>
<li><strong>示例：</strong> <code>Cookie: username=johndoe; sessionid=abc123</code></li>
</ul>
</li>
<li><strong>Authorization:</strong><ul>
<li><strong>作用：</strong> 包含了用于进行身份验证的凭证信息，例如用户名和密码。</li>
<li><strong>示例：</strong> <code>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</code></li>
</ul>
</li>
<li><strong>Content-Type:</strong><ul>
<li><strong>作用：</strong> 指定请求体的媒体类型，用于告诉服务器发送的数据的格式。</li>
<li><strong>示例：</strong> <code>Content-Type: application/json</code></li>
</ul>
</li>
</ol>
<h2 id="说说地址栏输入-URL-敲下回车后发生了什么？"><a href="#说说地址栏输入-URL-敲下回车后发生了什么？" class="headerlink" title="说说地址栏输入 URL 敲下回车后发生了什么？"></a>说说地址栏输入 URL 敲下回车后发生了什么？</h2><p>当在浏览器地址栏输入URL并按下回车时，发生的过程可以简要概括为以下几个步骤：</p>
<ol>
<li><strong>URL解析：</strong><ul>
<li>浏览器首先对输入的URL进行解析，提取出协议、主机名、端口号、路径和查询参数等信息。</li>
</ul>
</li>
<li><strong>DNS解析：</strong><ul>
<li>浏览器通过DNS（Domain Name System）解析获取服务器的IP地址，以便建立TCP连接。如果浏览器缓存中没有对应的IP地址，将发起DNS查询请求。</li>
</ul>
</li>
<li><strong>建立TCP连接：</strong><ul>
<li>浏览器通过使用HTTP或HTTPS等协议，与服务器建立TCP连接。对于HTTPS，还需要进行SSL&#x2F;TLS握手过程建立安全连接。</li>
</ul>
</li>
<li><strong>发起HTTP请求：</strong><ul>
<li>浏览器向服务器发送HTTP请求，包括请求方法（GET、POST等）、路径、请求头、可能的请求体等信息。</li>
</ul>
</li>
<li><strong>服务器处理请求：</strong><ul>
<li>服务器接收到请求后，根据路径和其他信息，处理相应的业务逻辑，可能涉及到数据库查询、动态页面生成等。</li>
</ul>
</li>
<li><strong>服务器发送HTTP响应：</strong><ul>
<li>服务器生成HTTP响应，包括状态码、响应头、响应体等，并将其发送回给浏览器。</li>
</ul>
</li>
<li><strong>浏览器接收响应：</strong><ul>
<li>浏览器接收到服务器的响应后，根据响应头中的信息判断如何处理响应，可能包括渲染HTML、执行JavaScript、加载资源等。</li>
</ul>
</li>
<li><strong>渲染页面：</strong><ul>
<li>如果响应是HTML，浏览器开始解析HTML文档，构建DOM树；同时，解析CSS创建样式规则，构建CSSOM树；最终，将DOM树和CSSOM树结合，生成渲染树，然后进行布局和绘制，最终将页面显示在用户界面上。</li>
</ul>
</li>
<li><strong>执行JavaScript：</strong><ul>
<li>如果HTML中包含了JavaScript，浏览器会执行相应的JavaScript代码，可能导致对DOM的修改、发起新的网络请求等操作。</li>
</ul>
</li>
<li><strong>加载资源：</strong><ul>
<li>页面可能包含引用的其他资源，如图片、样式表、脚本文件等，浏览器会根据需要加载这些资源。</li>
</ul>
</li>
</ol>
<p>整个过程中，浏览器和服务器之间的通信主要依赖于HTTP协议，而浏览器通过解析HTML、执行JavaScript等来呈现最终的用户界面。这一系列的步骤被称为“HTTP请求-响应周期”或“浏览器渲染流程”。</p>
<h2 id="说说TCP为什么需要三次握手和四次挥手？"><a href="#说说TCP为什么需要三次握手和四次挥手？" class="headerlink" title="说说TCP为什么需要三次握手和四次挥手？"></a>说说TCP为什么需要三次握手和四次挥手？</h2><p>TCP（Transmission Control Protocol）是一种面向连接的协议，为了确保可靠的数据传输，建立和终止连接时采用了三次握手和四次挥手的过程。</p>
<h3 id="三次握手（Three-Way-Handshake）："><a href="#三次握手（Three-Way-Handshake）：" class="headerlink" title="三次握手（Three-Way Handshake）："></a>三次握手（Three-Way Handshake）：</h3><ol>
<li><strong>第一次握手（SYN）：</strong><ul>
<li>客户端发送一个TCP报文，其中标志位SYN（同步序列编号）被置为1，同时选择一个初始序列号（ISN）。</li>
</ul>
</li>
<li><strong>第二次握手（SYN + ACK）：</strong><ul>
<li>服务器收到客户端的SYN报文后，会回复一个带有SYN和ACK标志位的报文，表示同意建立连接，并同时选择自己的初始序列号。</li>
</ul>
</li>
<li><strong>第三次握手（ACK）：</strong><ul>
<li>客户端收到服务器的SYN + ACK报文后，向服务器发送一个带有ACK标志位的报文，表示握手过程完成。</li>
</ul>
</li>
</ol>
<p><strong>原因：</strong></p>
<ul>
<li>第一次握手：建立连接时，客户端告诉服务器自己要发送数据了。</li>
<li>第二次握手：服务器收到客户端的请求，准备好并告诉客户端可以发送数据了。</li>
<li>第三次握手：客户端收到服务器的同意，此时连接建立，双方可以开始进行数据传输。</li>
</ul>
<h3 id="四次挥手（Four-Way-Handshake）："><a href="#四次挥手（Four-Way-Handshake）：" class="headerlink" title="四次挥手（Four-Way Handshake）："></a>四次挥手（Four-Way Handshake）：</h3><ol>
<li><strong>第一次挥手（FIN）：</strong><ul>
<li>客户端发送一个TCP报文，其中标志位FIN（终止连接）被置为1，表示客户端没有数据要发送了。</li>
</ul>
</li>
<li><strong>第二次挥手（ACK）：</strong><ul>
<li>服务器收到客户端的FIN报文后，向客户端发送一个带有ACK标志位的报文，表示已经收到了客户端的关闭请求。</li>
</ul>
</li>
<li><strong>第三次挥手（FIN）：</strong><ul>
<li>服务器关闭与客户端的连接，发送一个带有FIN标志位的报文，告知客户端服务器也准备好关闭连接。</li>
</ul>
</li>
<li><strong>第四次挥手（ACK）：</strong><ul>
<li>客户端收到服务器的FIN报文后，向服务器发送一个带有ACK标志位的报文，表示已经收到了服务器的关闭请求。</li>
</ul>
</li>
</ol>
<p><strong>原因：</strong></p>
<ul>
<li>第一次挥手：客户端没有数据要发送了，告诉服务器可以关闭连接。</li>
<li>第二次挥手：服务器收到客户端的关闭请求，告诉客户端自己也准备好关闭连接。</li>
<li>第三次挥手：服务器关闭连接，告知客户端可以安全关闭了。</li>
<li>第四次挥手：客户端收到服务器的关闭请求，向服务器发送确认，完成关闭过程。</li>
</ul>
<p>这样的设计可以确保在连接的建立和断开过程中，双方都能够明确地知道彼此的状态，从而确保数据的可靠传输和连接的正确关闭。</p>
<h2 id="说说对WebSocket的理解？应用场景？"><a href="#说说对WebSocket的理解？应用场景？" class="headerlink" title="说说对WebSocket的理解？应用场景？"></a>说说对WebSocket的理解？应用场景？</h2><p>WebSocket是一种在单个TCP连接上提供全双工通信的协议，它允许在客户端和服务器之间进行实时、双向的数据传输。WebSocket协议相对于传统的HTTP通信有更低的延迟和更小的开销，因为它避免了在每次通信时都建立新的连接。</p>
<h3 id="WebSocket的特点和工作原理："><a href="#WebSocket的特点和工作原理：" class="headerlink" title="WebSocket的特点和工作原理："></a>WebSocket的特点和工作原理：</h3><ol>
<li><strong>全双工通信：</strong> WebSocket允许客户端和服务器之间双向实时通信，可以同时发送和接收数据，而不需要等待对方的响应。</li>
<li><strong>持久连接：</strong> WebSocket连接一旦建立，可以保持持久性，不需要重复的握手和断开。</li>
<li><strong>低延迟：</strong> 相对于传统的HTTP轮询或长轮询，WebSocket可以实现更低的延迟，因为通信是即时的，而不需要等待定时轮询。</li>
<li><strong>轻量级：</strong> 与HTTP相比，WebSocket协议的头部开销较小，减少了通信的数据量。</li>
</ol>
<h3 id="WebSocket的工作过程："><a href="#WebSocket的工作过程：" class="headerlink" title="WebSocket的工作过程："></a>WebSocket的工作过程：</h3><ol>
<li><strong>握手阶段：</strong><ul>
<li>客户端发起WebSocket连接请求，请求中包含Upgrade头，服务器返回101状态码表示同意升级协议，之后WebSocket连接建立。</li>
</ul>
</li>
<li><strong>数据传输阶段：</strong><ul>
<li>客户端和服务器可以通过WebSocket连接进行双向的实时数据传输，可以同时发送和接收消息。</li>
</ul>
</li>
<li><strong>关闭阶段：</strong><ul>
<li>要关闭连接，一方发送一个带有关闭标志的数据帧，另一方接收到后也发送一个带有关闭标志的数据帧，连接就被关闭。</li>
</ul>
</li>
</ol>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol>
<li><strong>即时通讯：</strong> WebSocket适用于实时通讯应用，如在线聊天、消息推送等，因为它允许双方实时发送消息而无需不断建立新的连接。</li>
<li><strong>在线游戏：</strong> 在线游戏通常需要实时的双向通信，WebSocket可以提供低延迟和高效的数据传输。</li>
<li><strong>实时协作：</strong> 在协作应用中，多个用户可以实时地编辑和查看共享的文档或画布，WebSocket可以用于同步用户的操作。</li>
<li><strong>金融交易：</strong> 在金融领域，实时性是非常重要的，WebSocket可以用于实时更新股票价格、交易信息等。</li>
<li><strong>实时监控：</strong> WebSocket可以用于实时监控系统，及时推送监控数据和报警信息。</li>
</ol>
<p>总体而言，WebSocket适用于需要实时、双向通信的场景，它提供了更为高效和低延迟的解决方案，相对于传统的HTTP通信在某些应用场景中具有明显的优势。</p>
<h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h2 id="说说你对微信小程序的理解？优缺点？"><a href="#说说你对微信小程序的理解？优缺点？" class="headerlink" title="说说你对微信小程序的理解？优缺点？"></a>说说你对微信小程序的理解？优缺点？</h2><p>体积小，无需安装，直接在微信里面使用方便用户</p>
<h2 id="小程序里面怎么发请求？"><a href="#小程序里面怎么发请求？" class="headerlink" title="小程序里面怎么发请求？"></a>小程序里面怎么发请求？</h2><p>这个是最麻烦的，微信小程序原生有<code>wx.request</code>使用回调函数的方式发请求，不支持promise，更没有axios，所以写起来比较麻烦，</p>
<ul>
<li>我之前在原生开发的时候下载了一个第三方包，包名好像叫<code>wx_network</code>， <code>wechat_http</code>，有点忘记了，可以支持<code>promise</code>，支持写请求和响应拦截器等，好用</li>
<li>在uni-app里面开发的时候，使用的是<code>uni.request</code>，这个方法被<code>uni-app</code>自己封装为了 <code>promise</code>的版本，但是返回值是一个数组的形式， <code>const [err, res] = await uni.request(&#39;xxxx&#39;)</code>,也不是很好用</li>
<li>最后，我在上份工作里面，用的是<code>uview-ui</code>组件库， 这个框架除了给我们提供了组件以外，还给全局的<code>uni</code>绑定了一些 优化请求的方式， <code>uni.$u.http</code>。 我们就可以配置请求的基地址 ，请求响应拦截器。 后面的工作一直用的是它</li>
</ul>
<h2 id="小程序有跨域吗？"><a href="#小程序有跨域吗？" class="headerlink" title="小程序有跨域吗？"></a>小程序有跨域吗？</h2><p>没有，只有浏览器有跨域的说法，服务器和小程序都没有跨域，跨域是浏览器这个软件的安全策略</p>
<ul>
<li>小程序开发的时候： 在开发者工具勾选一个不校验<code>http</code>的选项就可以了、</li>
<li>上线以后怎么办： 小程序的后台网站，开发设置里面配置一下对应的域名，好像可以添加200个</li>
</ul>
<h2 id="小程序常见的组件通信方式"><a href="#小程序常见的组件通信方式" class="headerlink" title="小程序常见的组件通信方式"></a>小程序常见的组件通信方式</h2><ul>
<li>父子通信：类似于vue，父向子 <code>properties</code>，子向父通信 <code>triggerEvent</code></li>
<li>全局数据<code>getApp</code>： 我们一般在小程序里面，将多个组件都需要使用的数据，放到<code>app.js</code>里面，然后通过<code>getApp()</code> 去用</li>
</ul>
<h2 id="使用过哪些小程序原生的组件和Api"><a href="#使用过哪些小程序原生的组件和Api" class="headerlink" title="使用过哪些小程序原生的组件和Api"></a>使用过哪些小程序原生的组件和Api</h2><p>这个就很多了，我记不大清了，</p>
<ul>
<li>常用的组件比如 <code>view text rich-text navagator导航 swiper轮播图</code> 比较复杂的就是 <code>媒体组件 image 地图组件map等</code></li>
<li>常用的api就很多了，我自己用过<ul>
<li>印象比较深刻的就是：<code>微信登录 wx.login 微信支付 wx.requestPayment</code></li>
<li>其他比较简单的就是：<code>发请求 wx.request, 编程式导航wx.navigateTo, 获取基本信息getUserInfo</code> 其他的记不太清了，看文档直接用，比较简单</li>
</ul>
</li>
</ul>
<h2 id="uni-app开发的特点"><a href="#uni-app开发的特点" class="headerlink" title="uni-app开发的特点"></a>uni-app开发的特点</h2><ul>
<li>uni-app 可以编写一套代码，打包成14个平台，节约公司成本，快速搭建各个平台的产品。 我之前公司就用这个写过 微信小程序和 h5的项目，还比较好用，就是有些兼容性，有些细节需要注意</li>
<li>全部是vue的语法写小程序，上手无压力</li>
<li>注册时使用组件的时候，支持 easycom的模式。只要符合了基本的结构，不需要导入和注册，直接使用即可</li>
<li>技术选型是uni-app+uview-ui ； 原生小程序就是 原生语法+vantUI</li>
</ul>
<h2 id="说说微信小程序的生命周期函数有哪些？"><a href="#说说微信小程序的生命周期函数有哪些？" class="headerlink" title="说说微信小程序的生命周期函数有哪些？"></a>说说微信小程序的生命周期函数有哪些？</h2><p>首先小程序的生命周期有很多种，应用级别，页面界别和组件级别。开发uni-app的时候因为是vue的语法，所以还有vue的生命周期在里面。所以我们小程序 应用界别和页面级别的采用 小程序的生命周期。自定义组件 采用vue的生命周期</p>
<ul>
<li>应用级别(小程序的)，onLaunch —- App.vue文件里面</li>
<li>页面级别（小程序）,onLoad —– 定义在pages数组里面或者分包里面的 vue文件</li>
<li>组件级别（vue的）,created</li>
</ul>
<p><strong>整个小程序的生命周期：</strong></p>
<ol>
<li><strong>onLaunch：</strong> 小程序初始化时触发，全局只触发一次。</li>
<li><strong>onShow：</strong> 小程序启动或从后台进入前台时触发。</li>
</ol>
<p><strong>页面的生命周期：</strong></p>
<ol>
<li><strong>onLoad：</strong> 页面加载时触发，一个页面只会调用一次。</li>
<li><strong>onShow：</strong> 页面显示&#x2F;切入前台时触发。</li>
<li><strong>onReady：</strong> 页面初次渲染完成时触发，一个页面只会调用一次。</li>
</ol>
<p><strong>当从当前页面切换到其他页面：</strong></p>
<ol>
<li><strong>onHide：</strong> 当前页面隐藏&#x2F;切入后台时触发。</li>
</ol>
<p><strong>当从其他页面返回到当前页面：</strong></p>
<ol>
<li><strong>onShow：</strong> 当前页面重新显示&#x2F;切入前台时触发。</li>
</ol>
<p><strong>当关闭当前页面或跳转到其他页面时：</strong></p>
<ol>
<li><strong>onUnload：</strong> 页面卸载时触发。</li>
</ol>
<p><strong>当整个小程序被切入后台或被关闭时：</strong></p>
<ol>
<li><strong>onHide：</strong> 小程序从前台进入后台时触发。</li>
<li><strong>onUnload：</strong> 小程序销毁时触发。</li>
</ol>
<h2 id="说说微信小程序中路由跳转的方式有哪些？区别？"><a href="#说说微信小程序中路由跳转的方式有哪些？区别？" class="headerlink" title="说说微信小程序中路由跳转的方式有哪些？区别？"></a>说说微信小程序中路由跳转的方式有哪些？区别？</h2><ol>
<li><strong>wx.navigateTo:</strong><ul>
<li>通过该方式进行页面跳转，会保留当前页面，新页面入栈。</li>
<li>应用场景：一般用于不同业务逻辑的页面之间的跳转，保留当前页面的状态，可以通过返回按钮返回上一页。</li>
</ul>
</li>
<li><strong>wx.redirectTo:</strong><ul>
<li>通过该方式进行页面跳转，会关闭当前页面，新页面替换当前页面。</li>
<li>应用场景：用于替换当前页面，适用于一些不需要保留上一页状态的情况。</li>
</ul>
</li>
<li><strong>wx.reLaunch:</strong><ul>
<li>关闭所有页面，打开到应用内的某个页面。</li>
<li>应用场景：适用于一些重新登录、进入新的模块等需要清空页面栈的情况。</li>
</ul>
</li>
<li><strong>wx.switchTab:</strong><ul>
<li>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</li>
<li>应用场景：用于跳转到 tabBar 页面，比如从其他业务页面返回到首页。</li>
</ul>
</li>
<li><strong>wx.navigateBack:</strong><ul>
<li>关闭当前页面，返回上一页面或多级页面。</li>
<li>应用场景：用于返回上一页或多级页面，可以指定返回的层级。</li>
</ul>
</li>
</ol>
<h2 id="说说提高微信小程序的应用速度的手段有哪些？"><a href="#说说提高微信小程序的应用速度的手段有哪些？" class="headerlink" title="说说提高微信小程序的应用速度的手段有哪些？"></a>说说提高微信小程序的应用速度的手段有哪些？</h2><p>提高微信小程序应用速度的效果可以通过以下手段来实现：</p>
<ol>
<li><strong>优化图片：</strong><ul>
<li>压缩图片：使用适当的图片压缩工具，减小图片文件大小。</li>
<li>使用合适的图片格式：选择适合场景的图片格式，如JPEG、PNG等。</li>
<li>使用小程序提供的图片CDN服务，加速图片加载。</li>
</ul>
</li>
<li><strong>减少HTTP请求：</strong><ul>
<li>尽量减少页面请求的资源数，合并和精简CSS、JavaScript文件。</li>
<li>使用小程序的本地存储功能，减少对服务器的频繁请求。</li>
</ul>
</li>
<li><strong>合理使用缓存：</strong><ul>
<li>合理使用小程序的缓存机制，减少重复请求。</li>
<li>对于不常变化的数据，可以通过缓存在本地减少网络请求次数。</li>
</ul>
</li>
<li><strong>异步加载：</strong><ul>
<li>使用异步加载方式，减小首屏加载时间。</li>
<li>对于一些不是首屏必需的内容，可以使用异步加载方式，提高页面渲染速度。</li>
</ul>
</li>
<li><strong>避免使用全局样式：</strong><ul>
<li>尽量避免使用全局样式，减少对整体样式的重新计算和渲染。</li>
<li>使用局部样式，限定渲染范围，提高渲染效率。</li>
</ul>
</li>
<li><strong>使用分包加载：</strong><ul>
<li>对于大型小程序，可以使用分包加载机制，将不同功能的页面分割成不同的包，减小首次加载时的体积。</li>
</ul>
</li>
</ol>
<h2 id="小程序分包流程"><a href="#小程序分包流程" class="headerlink" title="小程序分包流程"></a>小程序分包流程</h2><h2 id="小程序实现导航栏自定义"><a href="#小程序实现导航栏自定义" class="headerlink" title="小程序实现导航栏自定义"></a>小程序实现导航栏自定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;navigationStyle&quot;</span>: <span class="string">&quot;custom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="说说微信小程序的登录流程？"><a href="#说说微信小程序的登录流程？" class="headerlink" title="说说微信小程序的登录流程？"></a>说说微信小程序的登录流程？</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static.vue-js.com/b60638c0-3428-11ec-a752-75723a64e8f5.png" style="zoom:50%;" />

<ul>
<li>通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据</li>
<li>由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息</li>
<li>通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到</li>
<li>微信服务器返回了 openid 及本次登录的会话密钥 session_key</li>
<li>后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走</li>
<li>session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输</li>
<li>然后生成 session并返回给小程序</li>
<li>小程序把 session 存到 storage 里面</li>
<li>下次请求时，先从 storage 里面读取，然后带给服务端</li>
<li>服务端对比 session 对应的记录，然后校验有效期</li>
</ul>
<h2 id="说说微信小程序的发布流程？"><a href="#说说微信小程序的发布流程？" class="headerlink" title="说说微信小程序的发布流程？"></a>说说微信小程序的发布流程？</h2><h2 id="说说微信小程序的支付流程？"><a href="#说说微信小程序的支付流程？" class="headerlink" title="说说微信小程序的支付流程？"></a>说说微信小程序的支付流程？</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://static.vue-js.com/76b66780-34a0-11ec-8e64-91fdec0f05a1.png" style="zoom:50%;" />

<ul>
<li>打开某小程序，点击直接下单</li>
<li>wx.login获取用户临时登录凭证code，发送到后端服务器换取openId</li>
<li>在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器</li>
<li>服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息</li>
<li>小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付</li>
<li>接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付</li>
<li>鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示</li>
<li>推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态</li>
</ul>
<p>调用支付接口的五个参数:</p>
<ol>
<li><strong>appId（小程序ID）：</strong> 这是你的微信小程序的唯一标识符，每个小程序都有一个独特的App ID。</li>
<li><strong>timeStamp（时间戳）：</strong> 一个从1970年1月1日00:00:00至今的秒数，即当前的时间戳。</li>
<li><strong>nonceStr（随机字符串）：</strong> 随机生成的字符串，用于防止重放攻击。</li>
<li><strong>package（数据包）：</strong> 统一下单接口返回的 prepay_id 参数值，具体内容格式由微信支付定义。</li>
<li><strong>signType（签名类型）：</strong> 签名算法，目前支持 HMAC-SHA256 和 MD5。</li>
</ol>
<h2 id="小程序和h5和pc端开发有什么不一样？"><a href="#小程序和h5和pc端开发有什么不一样？" class="headerlink" title="小程序和h5和pc端开发有什么不一样？"></a>小程序和h5和pc端开发有什么不一样？</h2><p>不一样的主要是交互方式上面，因为小程序屏幕比较小，很多pc电脑上的交互，手机上都用不了</p>
<ul>
<li><p>小程序和h5有 上拉刷新，下拉加载的操作</p>
</li>
<li><p>小程序和h5有 左滑 右滑的操作， 做一些收藏和删除的业务 （自己打开pdd，京东购物车去操作一遍）</p>
</li>
<li><p>小程序和h5有 针对与 iphoneX 那种 刘海屏，底部安全区域的单独设置等等. <strong>constant env 具体的我忘记了</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-in`Set`-bottom); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-in`Set`-bottom); <span class="comment">/* iOS 11.2 */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>说说你对版本管理的理解？常用的版本管理工具有哪些？</h2><p>版本管理是一种软件开发中重要的实践，用于追踪、管理和协调项目中的代码变更。版本管理有助于团队协作、追踪项目历史、恢复先前的状态，同时提供了一种备份和协同开发的机制。</p>
<p>分布式管理工具 git</p>
<p>集中式管理工具 svn</p>
<h2 id="说说你对Git的理解？"><a href="#说说你对Git的理解？" class="headerlink" title="说说你对Git的理解？"></a>说说你对Git的理解？</h2><h2 id="说说Git中-fork-clone-branch这三个概念，有什么区别"><a href="#说说Git中-fork-clone-branch这三个概念，有什么区别" class="headerlink" title="说说Git中 fork, clone,branch这三个概念，有什么区别?"></a>说说Git中 fork, clone,branch这三个概念，有什么区别?</h2><ol>
<li><strong>Fork：</strong><ul>
<li><strong>概念：</strong> Fork是在代码托管平台（如GitHub）上的一个操作，它创建了原始仓库的一个副本，这个副本在你的个人账户下。</li>
<li><strong>用途：</strong> 主要用于贡献代码或在独立的分支上进行实验性开发。你可以在你自己的Fork中进行修改，然后通过Pull Request（PR）请求将你的修改合并到原始仓库中。</li>
</ul>
</li>
<li><strong>Clone：</strong><ul>
<li><strong>概念：</strong> Clone是从一个现有的Git仓库中复制整个仓库到本地。</li>
<li><strong>用途：</strong> 用于获取代码的完整副本，以便在本地进行开发、测试和修改。Clone操作创建了一个连接到原始仓库的本地副本。</li>
</ul>
</li>
<li><strong>Branch：</strong><ul>
<li><strong>概念：</strong> Branch是指在一个Git仓库中创建的一个独立的分支，分支是仓库中的一个独立的开发路径。</li>
<li><strong>用途：</strong> 用于在项目中并行开发多个功能或修复不同的bug。每个分支都可以有不同的提交历史，但它们可以在需要时合并在一起。</li>
</ul>
</li>
</ol>
<p><strong>区别总结：</strong></p>
<ul>
<li><strong>Fork：</strong> 在代码托管平台上创建一个原始仓库的副本，通常用于贡献代码和提出修改请求。</li>
<li><strong>Clone：</strong> 从一个现有的Git仓库中复制整个仓库到本地，用于在本地进行开发和修改。</li>
<li><strong>Branch：</strong> 在一个Git仓库中创建的一个独立的开发路径，用于并行开发多个功能或修复不同的bug。</li>
</ul>
<h2 id="说说Git常用的命令有哪些？"><a href="#说说Git常用的命令有哪些？" class="headerlink" title="说说Git常用的命令有哪些？"></a>说说Git常用的命令有哪些？</h2><p>git branch 分支名  新建新分支</p>
<p>git checkout 分支名 切换到指定分支</p>
<p>git remote add 远程分支名 远程仓库地址 建立远程仓库关联</p>
<p>git merge 分支名 分支合并</p>
<p>git init 初始化git 仓库</p>
<p>git add . 提交到暂存区</p>
<p>git commit -m “提交日志”  提交到本地git 仓库 </p>
<p>git push 本地仓库推送到远程仓库</p>
<p>git pull 拉取远程仓库</p>
<p>git state 查看本地文件状态</p>
<p>git log 查看文件提交记录</p>
<h2 id="说说Git-中-HEAD、工作树和索引之间的区别？"><a href="#说说Git-中-HEAD、工作树和索引之间的区别？" class="headerlink" title="说说Git 中 HEAD、工作树和索引之间的区别？"></a>说说Git 中 HEAD、工作树和索引之间的区别？</h2><ol>
<li><strong>HEAD：</strong><ul>
<li><strong>概念：</strong> <code>HEAD</code>是指向当前所在分支的引用，或者指向某个具体的提交（commit）。</li>
<li><strong>作用：</strong> 在Git中，<code>HEAD</code>用于标识当前工作目录所在的提交版本，也可以用于切换分支、查看历史提交等操作。在HEAD所指向的提交上进行的修改将会成为新的提交。</li>
</ul>
</li>
<li><strong>工作树（Working Tree）：</strong><ul>
<li><strong>概念：</strong> 工作树是指包含项目实际文件的目录，也就是你在本地计算机上的项目副本。</li>
<li><strong>作用：</strong> 工作树中的文件可以进行编辑和修改，这些修改会在提交（commit）时被保存到Git仓库。工作树是开发者进行实际工作的地方，也是代码的可视化部分。</li>
</ul>
</li>
<li><strong>索引（Index）：</strong><ul>
<li><strong>概念：</strong> 索引是一个暂存区域，用于存储将要提交到Git仓库的修改。它是一个缓存区域，记录了工作树中所有文件的状态信息。</li>
<li><strong>作用：</strong> 在进行提交前，可以通过将文件的修改添加到索引中，形成一个预备提交的状态。这样可以选择性地提交文件的部分修改，而不是一次性提交所有修改。</li>
</ul>
</li>
</ol>
<p><strong>区别总结：</strong></p>
<ul>
<li><strong>HEAD：</strong> 表示当前所在分支的引用或者指向某个具体的提交，标识了当前工作目录所在的版本。</li>
<li><strong>工作树（Working Tree）：</strong> 是包含实际项目文件的目录，是开发者进行实际工作的地方，可以编辑和修改文件。</li>
<li><strong>索引（Index）：</strong> 是一个缓存区域，记录了将要提交到Git仓库的修改，可以选择性地添加和提交文件的部分修改。</li>
</ul>
<h2 id="说说对git-pull-和-git-fetch-的理解？有什么区别？"><a href="#说说对git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="说说对git pull 和 git fetch 的理解？有什么区别？"></a>说说对git pull 和 git fetch 的理解？有什么区别？</h2><ol>
<li><strong><code>git pull</code>：</strong><ul>
<li><strong>作用：</strong> <code>git pull</code> 是一条综合命令，它包含了从远程仓库获取更新（<code>git fetch</code>）和合并（<code>git merge</code>）两个步骤。</li>
<li><strong>使用场景：</strong> 当你希望获取远程仓库的更新并将它们合并到本地分支时，可以使用 <code>git pull</code>。例如，<code>git pull origin master</code> 将从远程的 <code>origin</code> 仓库的 <code>master</code> 分支获取更新并合并到当前本地分支。</li>
</ul>
</li>
<li><strong><code>git fetch</code>：</strong><ul>
<li><strong>作用：</strong> <code>git fetch</code> 用于从远程仓库获取更新，但它并不会自动合并这些更新到当前分支。</li>
<li><strong>使用场景：</strong> 当你只希望查看远程仓库的更新，而不进行合并操作时，可以使用 <code>git fetch</code>。它将远程仓库的变更下载到本地，但并不自动修改你的工作目录或当前分支。</li>
</ul>
</li>
</ol>
<p><strong>区别总结：</strong></p>
<ul>
<li><code>git pull</code> 从远程仓库获取更新并尝试自动合并到当前分支，是<code>git fetch</code> 和 <code>git merge</code> 的综合命令。</li>
<li><code>git fetch</code> 从远程仓库获取更新，但不会自动合并到当前分支。这使得你可以预览远程仓库的变更，然后决定是否进行合并。</li>
</ul>
<p>使用 <code>git fetch</code> 的一个常见场景是查看远程仓库的变更情况，然后再决定是否执行 <code>git merge</code> 或 <code>git rebase</code> 将变更合并到本地分支。这样可以避免意外的合并，给予开发者更大的控制权。</p>
<h2 id="说说你对git-stash-的理解？应用场景？"><a href="#说说你对git-stash-的理解？应用场景？" class="headerlink" title="说说你对git stash 的理解？应用场景？"></a>说说你对git stash 的理解？应用场景？</h2><p><code>git stash</code> 是一个用于保存当前工作目录和暂存区状态的命令。它允许开发者在切换分支或者处理其他任务之前，将未提交的修改暂时存储起来，以便后续恢复。</p>
<h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a><strong>应用场景：</strong></h4><ol>
<li><p><strong>临时切换分支：</strong></p>
<ul>
<li>当你正在某个分支上工作，但需要切换到其他分支进行紧急修复或测试时，可以使用 <code>git stash</code> 保存当前工作进度，切换分支，完成操作后再通过 <code>git stash apply</code> 恢复。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">egit stash          <span class="comment"># 保存当前工作进度</span></span><br><span class="line">git checkout &lt;branch&gt;  <span class="comment"># 切换到其他分支</span></span><br><span class="line"><span class="comment"># 进行紧急修复或测试</span></span><br><span class="line">git checkout &lt;original-branch&gt;  <span class="comment"># 切回原来的分支</span></span><br><span class="line">git stash apply    <span class="comment"># 恢复之前保存的工作进度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保存未提交的修改：</strong></p>
<ul>
<li>当你在进行一些修改，但突然需要切换到其他任务时，可以使用 <code>git stash</code> 将未提交的修改暂时存储，以免影响其他操作。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash          <span class="comment"># 保存未提交的修改</span></span><br><span class="line"><span class="comment"># 进行其他任务</span></span><br><span class="line">git stash apply    <span class="comment"># 恢复之前保存的修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免合并冲突：</strong></p>
<ul>
<li>在合并分支之前，如果当前分支有未提交的修改，可以使用 <code>git stash</code> 避免与合并引起的冲突。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash          <span class="comment"># 保存当前分支的修改</span></span><br><span class="line">git pull origin &lt;branch&gt;  <span class="comment"># 从远程拉取最新代码并合并</span></span><br><span class="line">git stash apply    <span class="comment"># 恢复之前保存的修改</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h4><ul>
<li><code>git stash</code> 不仅会保存工作目录中的修改，还会保存暂存区（Index）的状态。</li>
<li><code>git stash</code> 默认会保存所有未提交的修改，包括新添加的文件和未追踪的文件。</li>
<li>可以使用 <code>git stash save &quot;message&quot;</code> 添加一条描述信息，以便在恢复时更容易理解每个 stash 的目的。</li>
</ul>
<h2 id="说说你对git-rebase-和-git-merge的理解？区别？"><a href="#说说你对git-rebase-和-git-merge的理解？区别？" class="headerlink" title="说说你对git rebase 和 git merge的理解？区别？"></a>说说你对git rebase 和 git merge的理解？区别？</h2><ul>
<li><p><strong>Git Rebase：</strong></p>
<ul>
<li><code>git rebase</code> 是将一个分支的修改合并到另一个分支的过程。通过重新设置分支的基点，使得提交历史更为线性，避免了合并产生的额外的合并提交。通常用于保持提交历史的整洁。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Git Merge：</strong></p>
<ul>
<li><code>git merge</code> 是将一个分支的修改合并到另一个分支的过程。它会创建一个新的合并提交，将两个分支的修改合并在一起。这会在提交历史中产生一个新的合并节点。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-branch</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a><strong>区别：</strong></h4><ol>
<li><strong>提交历史的形状：</strong><ul>
<li><strong>Rebase：</strong> 通过 <code>git rebase</code> 合并的提交历史更加线性，没有合并节点，看起来更加整洁。</li>
<li><strong>Merge：</strong> 通过 <code>git merge</code> 合并的提交历史中会产生合并节点，形成分叉的结构。</li>
</ul>
</li>
<li><strong>合并方式：</strong><ul>
<li><strong>Rebase：</strong> 会将被合并分支的提交在目标分支的最新提交之后逐个应用，形成一系列新的提交。</li>
<li><strong>Merge：</strong> 会创建一个新的合并提交，将两个分支的修改合并在一起，并在提交历史中生成一个合并节点。</li>
</ul>
</li>
<li><strong>历史清晰性：</strong><ul>
<li><strong>Rebase：</strong> 通过 <code>git rebase</code> 可以保持提交历史的整洁和线性，但可能会导致冲突。</li>
<li><strong>Merge：</strong> 通过 <code>git merge</code> 可以保留原始分支的完整历史，但会在提交历史中产生合并节点。</li>
</ul>
</li>
<li><strong>冲突处理：</strong><ul>
<li><strong>Rebase：</strong> 如果在 <code>git rebase</code> 过程中发生冲突，需要逐个解决每个冲突。</li>
<li><strong>Merge：</strong> 如果在 <code>git merge</code> 过程中发生冲突，需要解决一次合并冲突，然后提交。</li>
</ul>
</li>
</ol>
<h4 id="选择使用场景："><a href="#选择使用场景：" class="headerlink" title="选择使用场景："></a><strong>选择使用场景：</strong></h4><ul>
<li><p><strong>Rebase：</strong></p>
<ul>
<li>用于个人分支，以保持整洁的提交历史。</li>
<li>不推荐对已经共享给其他开发者的分支进行 rebase。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature-branch</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Merge：</strong></p>
<ul>
<li>用于合并多个开发者共享的分支，以保留每个开发者的独立提交历史。</li>
<li>在进行合并时，可以使用 <code>--no-ff</code> 选项以保留合并提交。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-branch --no-ff</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="说说-git-发生冲突的场景？如何解决？"><a href="#说说-git-发生冲突的场景？如何解决？" class="headerlink" title="说说 git 发生冲突的场景？如何解决？"></a>说说 git 发生冲突的场景？如何解决？</h2><h2 id="说说你对git-reset-和-git-revert-的理解？区别？"><a href="#说说你对git-reset-和-git-revert-的理解？区别？" class="headerlink" title="说说你对git reset 和 git revert 的理解？区别？"></a>说说你对git reset 和 git revert 的理解？区别？</h2><ul>
<li><p><strong>Git Reset：</strong></p>
<ul>
<li><p><code>git re</code>Set&#96;&#96; 用于将当前分支的 HEAD 指针移动到指定的提交，并可选择是否更新工作目录和暂存区。它可以用于撤销提交、移动分支等操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Git Revert：</strong></p>
<ul>
<li><p><code>git revert</code> 用于创建新的提交，以撤销先前的提交。它不会移动分支，而是在提交历史中添加一个新的提交，该提交的变更是先前提交的逆操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a><strong>区别：</strong></h4><ol>
<li><strong>影响提交历史：</strong><ul>
<li><strong>Reset：</strong> 通过 <code>git reset</code> 可以修改提交历史，将 HEAD 指针移动到指定的提交，从而删除一些提交。这会改变提交历史，不建议对已共享的提交进行 reset 操作。</li>
<li><strong>Revert：</strong> 通过 <code>git revert</code> 创建一个新的提交，以保持提交历史的完整性。它不修改已有的提交，而是添加新的提交作为撤销操作的记录。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>Reset：</strong> 适用于本地仓库中的操作，特别是在分支上进行实验性的提交，但不建议在共享的分支上使用 reset。</li>
<li><strong>Revert：</strong> 适用于已经共享的分支，因为它不改变提交历史，而是添加新的提交来撤销之前的更改。</li>
</ul>
</li>
<li><strong>风险因素：</strong><ul>
<li><strong>Reset：</strong> 使用 <code>git reset</code> 可能会导致丢失提交，因为它会直接移动 HEAD 指针。</li>
<li><strong>Revert：</strong> 使用 <code>git revert</code> 通常比较安全，因为它不会改变原有的提交历史，而是创建新的提交来撤销变更。</li>
</ul>
</li>
</ol>
<h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><ul>
<li><p><strong>Reset：</strong></p>
<ul>
<li>用于本地分支上的实验性提交，当需要撤销一些提交时。</li>
<li>小组内的协作中，可以通过 re<code>Set</code> 撤销尚未共享的提交。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reSet HEAD~1  <span class="comment"># 撤销最后一次提交</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Revert：</strong></p>
<ul>
<li>用于共享的分支上，当需要撤销已经共享的提交时。</li>
<li>适用于已经推送到远程仓库的分支，以免影响其他开发者。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;  <span class="comment"># 撤销指定提交</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h4><ul>
<li>在使用 <code>git reset</code> 时，需要谨慎操作，因为它会修改提交历史，可能导致数据丢失。</li>
<li>在使用 <code>git revert</code> 时，需要处理可能发生的冲突，因为它会创建新的提交。</li>
</ul>
<h2 id="git分支规范"><a href="#git分支规范" class="headerlink" title="git分支规范"></a>git分支规范</h2><p>主分支 master&#x2F;main</p>
<p>测试分支 release</p>
<p>开发分支 dev</p>
<h2 id="git如何合并分支部分代码"><a href="#git如何合并分支部分代码" class="headerlink" title="git如何合并分支部分代码"></a>git如何合并分支部分代码</h2><p>在Git中，你可以使用 <code>git cherry-pick</code> 命令来合并某个提交或一系列提交到当前分支。这允许你选择性地合并分支中的部分代码，而不是整个分支。</p>
<p>以下是使用 <code>git cherry-pick</code> 的步骤：</p>
<ol>
<li><p><strong>查找提交 ID：</strong></p>
<ul>
<li>首先，使用 <code>git log</code> 命令查找要合并的提交的提交 ID。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>切换到目标分支：</strong></p>
<ul>
<li>切换到你想要将代码合并到的目标分支。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;target-branch&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行 cherry-pick：</strong></p>
<ul>
<li>使用 <code>git cherry-pick</code> 命令并提供要合并的提交 ID。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果要合并一系列连续的提交，可以使用 commit 范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;</span><br></pre></td></tr></table></figure>

<p>   这里 <code>^</code> 表示排除 <code>start-commit-id</code> 自身。</p>
<ol start="4">
<li><p><strong>处理冲突（如果有）：</strong></p>
<ul>
<li>如果合并过程中发生冲突，需要手动解决冲突，然后使用 <code>git add</code> 和 <code>git cherry-pick --continue</code> 完成合并。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted-file&gt;</span><br><span class="line">git cherry-pick --continue</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完成：</strong></p>
<ul>
<li>合并完成后，可以继续进行其他操作或者提交合并结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure></li>
</ol>
<p>请注意，<code>git cherry-pick</code> 可能会引入冲突，特别是当合并的提交依赖于目标分支的其他修改时。在使用 <code>git cherry-pick</code> 时，确保理解合并的影响，并在需要时手动解决冲突。</p>
<h2 id="如何切换新分支且不产生新记录"><a href="#如何切换新分支且不产生新记录" class="headerlink" title="如何切换新分支且不产生新记录"></a>如何切换新分支且不产生新记录</h2><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="说说你对-TypeScript-的理解？与-JavaScript-的区别？"><a href="#说说你对-TypeScript-的理解？与-JavaScript-的区别？" class="headerlink" title="说说你对 TypeScript 的理解？与 JavaScript 的区别？"></a>说说你对 TypeScript 的理解？与 JavaScript 的区别？</h2><p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>
<blockquote>
<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合 A 里面的的所有元素集合 B 里面都存在，那么我们可以理解集合 B 是集合 A 的超集，集合 A 为集合 B 的子集</p>
</blockquote>
<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>
<p>同时扩展了<code>JavaScript</code> 的语法，所以任何现有的<code>JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>
<p>为了保证兼容性，<code>TypeScript</code> 在编译阶段需要编译器编译成纯 <code>JavaScript</code> 来运行，是为大型应用之开发而设计的语言，如下：</p>
<p><code>ts</code> 文件如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello);</span><br></pre></td></tr></table></figure>

<p>编译文件后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello);</span><br></pre></td></tr></table></figure>

<h3 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h3><p><code>TypeScript</code> 的特性主要有如下：</p>
<ul>
<li><strong>类型批注和编译时类型检查</strong> ：在编译时批注变量类型</li>
<li><strong>类型推断</strong>：ts 中没有批注变量类型会自动推断变量的类型</li>
<li><strong>类型擦除</strong>：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>
<li><strong>接口</strong>：ts 中用接口来定义对象类型</li>
<li><strong>枚举</strong>：用于取值被限定在一定范围内的场景</li>
<li><strong>Mixin</strong>：可以接受任意类型的值</li>
<li><strong>泛型编程</strong>：写代码时使用一些以后才指定的类型</li>
<li><strong>名字空间</strong>：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>
<li><strong>元组</strong>：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>
<li>…</li>
</ul>
<h3 id="类型批注"><a href="#类型批注" class="headerlink" title="类型批注"></a>类型批注</h3><p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用 <code>JavaScript</code> 常规的动态类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Add</span>(<span class="params">left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于基本类型的批注是 <code>number</code>、<code>bool</code> 和 <code>string</code>，而弱或动态类型的结构则是 <code>any</code> 类型</p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>变量 <code>str</code> 被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>
<p>如果缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 <code>any</code> 类型</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口简单来说就是用来描述对象的类型 数据的类型有 <code>number</code>、<code>null</code>、<code>string</code> 等数据格式，对象的类型就是用接口来描述的</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><ul>
<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>
<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>
</ul>
<p>更多的区别如下图所示：</p>
<h2 id="说说-typescript-的数据类型有哪些？"><a href="#说说-typescript-的数据类型有哪些？" class="headerlink" title="说说 typescript 的数据类型有哪些？"></a>说说 typescript 的数据类型有哪些？</h2><p>typescript 的数据类型主要有如下：</p>
<p>boolean（布尔类型）<br>number（数字类型）<br>string（字符串类型）<br>array（数组类型）<br>tuple（元组类型）<br>enum（枚举类型）<br>any（任意类型）<br>null 和 undefined 类型<br>void 类型<br>never 类型<br>object 对象类型<br>#boolean<br>布尔类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">flag</span>:<span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// flag = 123; // 错误</span></span><br><span class="line">flag = <span class="literal">false</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>#number<br>数字类型，和javascript一样，typescript的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// num = &#x27;456&#x27;; // 错误</span></span><br><span class="line">num = <span class="number">456</span>;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>进制表示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span>; <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure>

<p>#string<br>字符串类型，和JavaScript一样，可以使用双引号（”）或单引号（’）表示字符串</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>:<span class="built_in">string</span> = <span class="string">&#x27;this is ts&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>作为超集，当然也可以使用模版字符串&#96;&#96;进行包裹，通过 ${} 嵌入变量</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span></span></span><br></pre></td></tr></table></figure>

<p>#array<br>数组类型，跟javascript一致，通过[]进行包裹，有两种写法：</p>
<p>方式一：元素类型后面接上 []</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="built_in">string</span>[] = [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;23&#x27;</span>];</span><br><span class="line">arr = [<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;56&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>方式二：使用数组泛型，Array&lt;元素类型&gt;：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>:<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr = [<span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;56&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>#tuple<br>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tupleArr</span>:[<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>];</span><br><span class="line">tupleArr = [<span class="number">12</span>, <span class="string">&#x27;34&#x27;</span>, <span class="literal">true</span>]; <span class="comment">//ok</span></span><br><span class="line">typleArr = [<span class="number">12</span>, <span class="string">&#x27;34&#x27;</span>] <span class="comment">// no ok</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>
<p>#enum<br>enum类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure>

<p>#any<br>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用any类型</p>
<p>使用any类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line">num = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">num = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>定义存储各种类型数据的数组时，示例代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arrayList</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">&#x27;fine&#x27;</span>];</span><br><span class="line">arrayList[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">#<span class="literal">null</span> 和 和 <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>在JavaScript 中 null表示 “什么都没有”，是一个只有一个值的特殊类型，表示一个空对象引用，而undefined表示一个没有设置值的变量</p>
<p>默认情况下null和undefined是所有类型的子类型， 就是说你可以把 null和 undefined赋值给 number类型的变量</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">num</span>:<span class="built_in">number</span> | <span class="literal">undefined</span>; <span class="comment">// 数值类型 或者 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 正确</span></span><br><span class="line">num = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>但是ts配置了–strictNullChecks标记，null和undefined只能赋值给void和它们各自</p>
<p>#void<br>用于标识方法返回值的类型，表示该方法没有返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello Runoob&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#never<br>never是其他类型 （包括null和 undefined）的子类型，可以赋值给任何类型，代表从不会出现的值</p>
<p>但是没有类型是 never 的子类型，这意味着声明 never 的变量只能被 never 类型所赋值。</p>
<p>never 类型一般用来指定那些总是会抛出异常、无限循环</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>:<span class="built_in">never</span>;</span><br><span class="line">a = <span class="number">123</span>; <span class="comment">// 错误的写法</span></span><br><span class="line"></span><br><span class="line">a = (<span class="function">() =&gt;</span> &#123; <span class="comment">// 正确的写法</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误&#x27;</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#object<br>对象类型，非原始类型，常见的形式通过{}进行包裹</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:<span class="built_in">object</span>;</span><br><span class="line">obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;Wang&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>#三、总结<br>和javascript基本一致，也分成：</p>
<p>基本类型<br>引用类型<br>在基础类型上，typescript增添了void、any、emum等原始类型</p>
<h2 id="说说你对-TypeScript-中枚举类型的理解？应用场景？"><a href="#说说你对-TypeScript-中枚举类型的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中枚举类型的理解？应用场景？"></a>说说你对 TypeScript 中枚举类型的理解？应用场景？</h2><p>一、是什么<br>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名&#123;</span><br><span class="line">    标识符①[=整型常数],</span><br><span class="line">    标识符②[=整型常数],</span><br><span class="line">    ...</span><br><span class="line">    标识符N[=整型常数],</span><br><span class="line">&#125;枚举变量;</span><br></pre></td></tr></table></figure>

<p>#二、使用<br>枚举的使用是通过enum关键字进行定义，形式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> xxx &#123; ... &#125;</span><br><span class="line">声明关键字为枚举类型的方式如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明d为枚举类型Direction</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Direction</span>;</span><br></pre></td></tr></table></figure>

<p>类型可以分成：</p>
<p>数字枚举</p>
<p>字符串枚举</p>
<p>异构枚举</p>
<p>#数字枚举<br>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从0开始依次累加:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,   <span class="comment">// 值默认为 0</span></span><br><span class="line">    <span class="title class_">Down</span>, <span class="comment">// 值默认为 1</span></span><br><span class="line">    <span class="title class_">Left</span>, <span class="comment">// 值默认为 2</span></span><br><span class="line">    <span class="title class_">Right</span> <span class="comment">// 值默认为 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Down</span> === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Left</span> === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Right</span> === <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">10</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>, <span class="title class_">Direction</span>.<span class="property">Down</span>, <span class="title class_">Direction</span>.<span class="property">Left</span>, <span class="title class_">Direction</span>.<span class="property">Right</span>); <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure>

<p>#字符串枚举<br>枚举类型的值其实也可以是字符串类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="string">&#x27;Right&#x27;</span>], <span class="title class_">Direction</span>.<span class="property">Up</span>); <span class="comment">// Right Up</span></span><br></pre></td></tr></table></figure>

<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line"> <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line"> <span class="title class_">Down</span>, <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line"> <span class="title class_">Left</span>, <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line"> <span class="title class_">Right</span> <span class="comment">// error TS1061: Enum member must have initializer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#异构枚举<br>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BooleanLikeHeterogeneousEnum</span> &#123;</span><br><span class="line">    <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下我们很少会使用异构枚举</p>
<p>#本质<br>现在一个枚举的案例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过编译后，javascript如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="number">0</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上述代码可以看到， Direction[Direction[“Up”] &#x3D; 0] &#x3D; “Up”可以分成</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="number">0</span></span><br><span class="line"><span class="title class_">Direction</span>[<span class="number">0</span>] = <span class="string">&quot;Up&quot;</span></span><br></pre></td></tr></table></figure>

<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span> === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>[<span class="number">0</span>]); <span class="comment">// Up</span></span><br></pre></td></tr></table></figure>

<p>并且多处定义的枚举是可以进行合并操作，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="string">&#x27;Up&#x27;</span>,</span><br><span class="line">    <span class="title class_">Down</span> = <span class="string">&#x27;Down&#x27;</span>,</span><br><span class="line">    <span class="title class_">Left</span> = <span class="string">&#x27;Left&#x27;</span>,</span><br><span class="line">    <span class="title class_">Right</span> = <span class="string">&#x27;Right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Center</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，js代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Center&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>可以看到，Direction对象属性回叠加</p>
<p>#三、应用场景<br>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Days</span> &#123;<span class="title class_">Sun</span>, <span class="title class_">Mon</span>, <span class="title class_">Tue</span>, <span class="title class_">Wed</span>, <span class="title class_">Thu</span>, <span class="title class_">Fri</span>, <span class="title class_">Sat</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sun&quot;</span>] === <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Mon&quot;</span>] === <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Tue&quot;</span>] === <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Days</span>[<span class="string">&quot;Sat&quot;</span>] === <span class="number">6</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<h2 id="说说你对-TypeScript-中接口的理解？应用场景？"><a href="#说说你对-TypeScript-中接口的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中接口的理解？应用场景？"></a>说说你对 TypeScript 中接口的理解？应用场景？</h2><p>一、是什么<br>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>
<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>
<p>typescript的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>
<p>#二、使用方式<br>接口定义如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> interface_name &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如有一个函数，这个函数接受一个 User 对象，然后返回这个 User 对象的 name 属性:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user</span>) =&gt; user.<span class="property">name</span></span><br></pre></td></tr></table></figure>

<p>可以看到，参数需要有一个user的name属性，可以通过接口描述user参数的结构</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user: User</span>) =&gt; user.<span class="property">name</span></span><br></pre></td></tr></table></figure>

<p>这些属性并不一定全部实现，上述传入的对象必须拥有name和age属性，否则typescript在编译阶段会报错，如下图：</p>
<p>如果不想要age属性的话，这时候可以采用可选属性，如下表示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候age属性则可以是number类型或者undefined类型</p>
<p>有些时候，我们想要一个属性变成只读属性，在typescript只需要使用readonly声明，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们修改属性的时候，就会出现警告，如下所示：</p>
<p>这是属性中有一个函数，可以如下表示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">isMale</span>: <span class="built_in">boolean</span></span><br><span class="line">    <span class="attr">say</span>: <span class="function">(<span class="params">words: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>
<p>类型推断</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserName</span> = (<span class="params">user: User</span>) =&gt; user.<span class="property">name</span></span><br><span class="line"><span class="title function_">getUserName</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;yellow&#x27;</span>&#125; <span class="keyword">as</span> <span class="title class_">User</span>)</span><br><span class="line">给接口添加字符串索引签名</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口还能实现继承，如下图：</p>
<p>也可以继承多个，父类通过逗号隔开，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mother</span> &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>,<span class="title class_">Mother</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#三、应用场景<br>例如在javascript中定义一个函数，用来获取用户的姓名和年龄：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserInfo = <span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="attr">name</span>: $&#123;user.<span class="property">name</span>&#125;, <span class="attr">age</span>: $&#123;user.<span class="property">age</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>
<p>&#x2F;&#x2F; 先定义一个接口</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserInfo = (<span class="attr">user</span>: <span class="title class_">IUser</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`name: <span class="subst">$&#123;user.name&#125;</span>, age: <span class="subst">$&#123;user.age&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的调用</span></span><br><span class="line"><span class="title function_">getUserInfo</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;koala&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>包括后面讲到类的时候也会应用到接口</p>
<h2 id="说说你对-TypeScript-中类的理解？应用场景？"><a href="#说说你对-TypeScript-中类的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中类的理解？应用场景？"></a>说说你对 TypeScript 中类的理解？应用场景？</h2><p>一、是什么<br>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>
<p>类是一种用户定义的引用数据类型，也称类类型</p>
<p>传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本</p>
<p>在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>
<p>但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类</p>
<p>TypeScript 的 class 支持面向对象的所有特性，比如 类、接口等</p>
<p>#二、使用方式<br>定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<p>字段 ： 字段是类里面声明的变量。字段表示对象的有关数据。<br>构造函数： 类实例化时调用，可以为类的对象分配内存。<br>方法： 方法为对象要执行的操作<br>如下例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="attr">engine</span>:<span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">engine:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">engine</span> = engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="title function_">disp</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发动机为 :   &quot;</span>+<span class="variable language_">this</span>.<span class="property">engine</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}<br>#继承<br>类的继承使用过extends的关键字</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params">distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Woof! Woof!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);</span><br><span class="line">dog.<span class="title function_">bark</span>();</span><br></pre></td></tr></table></figure>

<p>Dog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类</p>
<p>Dog类继承了Animal类，因此实例dog也能够使用Animal类move方法</p>
<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterClass</span> &#123;</span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;父类的 doPrint() 方法。&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrinter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PrinterClass</span> &#123;</span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">doPrint</span>() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;子类的 doPrint()方法。&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#修饰符<br>可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：</p>
<p>公共 public：可以自由的访问类程序里定义的成员<br>私有 private：只能够在该类的内部进行访问<br>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问<br>#私有修饰符<br>只能够在该类的内部进行访问，实例对象并不能够访问</p>
<p>并且继承该类的子类并不能访问，如下图所示：</p>
<p>#受保护修饰符<br>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>
<p>有一点不同的是 protected 成员在子类中仍然可以访问</p>
<p>除了上述修饰符之外，还有只读修饰符</p>
<p>#只读修饰符<br>通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>
<p>除了实例属性之外，同样存在静态属性</p>
<p>#静态属性<br>这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Square</span>.<span class="property">width</span>) <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure>

<p>上述的类都能发现一个特点就是，都能够被实例化，在 typescript中，还存在一种抽象类</p>
<p>#抽象类<br>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>
<p>abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">makeSound</span>(): <span class="built_in">void</span>;</span><br><span class="line">    <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;roaming the earch...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line"><span class="title function_">makeSound</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;miao miao&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>()</span><br><span class="line"></span><br><span class="line">cat.<span class="title function_">makeSound</span>() <span class="comment">// miao miao</span></span><br><span class="line">cat.<span class="title function_">move</span>() <span class="comment">// roaming the earch...</span></span><br></pre></td></tr></table></figure>

<p>#三、应用场景<br>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 React 工程中是很常用的，如下：</p>
<p>export default class Carousel extends React.Component&lt;Props, State&gt; {}<br>由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口</p>
<p>先声明一个类，这个类包含组件 props 所需的类型和初始值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props的类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">children</span>: <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;&gt; | <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">never</span>[] = []</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">speed</span>: <span class="built_in">number</span> = <span class="number">500</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">height</span>: <span class="built_in">number</span> = <span class="number">160</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">animation</span>: <span class="built_in">string</span> = <span class="string">&#x27;easeInOutQuad&#x27;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">isAuto</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">autoPlayInterval</span>: <span class="built_in">number</span> = <span class="number">4500</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">afterChange</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">beforeChange</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">selesctedColor</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">public</span> <span class="attr">showDots</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props 的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> defaultProps = <span class="keyword">new</span> <span class="title class_">Props</span>()</span><br></pre></td></tr></table></figure>

<p>Props 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>
<h2 id="说说你对-TypeScript-中函数的理解？与-JavaScript-函数的区别？"><a href="#说说你对-TypeScript-中函数的理解？与-JavaScript-函数的区别？" class="headerlink" title="说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"></a>说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h2><p>一、是什么<br>函数是JavaScript 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>
<p>在TypeScript 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，TypeScript 为 JavaScript 函数添加了额外的功能，丰富了更多的应用场景</p>
<p>函数类型在 TypeScript 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>
<p>#二、使用方式<br>跟javascript 定义函数十分相似，可以通过funciton 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt; a + b</span><br></pre></td></tr></table></figure>

<p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>
<p>当鼠标放置在第三行add函数名的时候，会出现完整的函数定义类型，通过: 的形式来定于参数类型，通过 &#x3D;&gt; 连接参数和返回值类型</p>
<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LongHand</span> = &#123;</span><br><span class="line">  (<span class="attr">a</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ShortHand</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">当存在函数重载时，只能使用方式一的形式</span><br></pre></td></tr></table></figure>

<p>#可选参数<br>当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt; a + (b ? b : <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以</p>
<p>#剩余类型<br>剩余参数与JavaScript的语法类似，需要用 … 来表示剩余参数</p>
<p>如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>) =&gt; rest.<span class="title function_">reduce</span>((<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b), a)</span><br></pre></td></tr></table></figure>

<p>#函数重载<br>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>
<p>关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>
<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并</p>
<p>例如我们有一个add函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上边是声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 因为我们在下边有具体函数的实现，所以这里并不需要添加 declare 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边是实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">arg1</span>: <span class="built_in">string</span> | <span class="built_in">number</span>, <span class="attr">arg2</span>: <span class="built_in">string</span> | <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、区别<br>从上面可以看到：</p>
<p>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型<br>typescript 在参数中，添加可选参数供使用者选择<br>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</p>
<h2 id="说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 中泛型的理解？应用场景？"></a>说说你对 TypeScript 中泛型的理解？应用场景？</h2><p>一、是什么<br>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>
<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型 在typescript中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<p>假设我们用一个函数，它可接受一个 number 参数并返回一个number 参数，如下写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnItem</span> (<span class="attr">para</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们打算接受一个 string 类型，然后再返回 string类型，则如下写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnItem</span> (<span class="attr">para</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>
<p>虽然可以使用 any类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>
<p>这种情况就可以使用泛型，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>
<p>#二、使用方式<br>泛型通过&lt;&gt;的形式进行表述，可以声明：</p>
<p>函数</p>
<p>接口</p>
<p>类</p>
<p>#函数声明<br>声明函数的形式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> returnItem&lt;T&gt;(<span class="attr">para</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> para</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 T 和 泛型 U：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap&lt;T, U&gt;(<span class="attr">tuple</span>: [T, U]): [U, T] &#123;</span><br><span class="line">    <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">swap</span>([<span class="number">7</span>, <span class="string">&#x27;seven&#x27;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br></pre></td></tr></table></figure>

<p>#接口声明<br>声明接口的形式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReturnItemFn</span>&lt;T&gt; &#123;</span><br><span class="line">    (<span class="attr">para</span>: T): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当我们想传入一个number作为参数的时候，就可以这样声明函数:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">returnItem</span>: <span class="title class_">ReturnItemFn</span>&lt;<span class="built_in">number</span>&gt; = <span class="function"><span class="params">para</span> =&gt;</span> para</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>#类声明<br>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>
<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">arr</span>: T[] = []</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">push</span>(<span class="params">item: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">pop</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stacn</span>&lt;<span class="built_in">number</span>&gt;()</span><br></pre></td></tr></table></figure>

<p>如果上述只能传递 string 和 number 类型，这时候就可以使用 <T extends xx> 的方式猜实现约束泛型，如下所示：</p>
<p>除了上述的形式，泛型更高级的使用如下：</p>
<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>
<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>
<p>#索引类型、约束类型<br>索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T <span class="keyword">extends</span> <span class="built_in">object</span>, U <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: U) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key] <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 object类型，是因为默认情况 object 指的是{}，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 T extends object</p>
<p>使用如下图所示：</p>
<p>#多类型约束<br>例如如下需要实现两个接口的类型约束：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FirstInterface</span> &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SecondInterface</span> &#123;</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以创建一个接口继承上述两个接口，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChildInterface</span> <span class="keyword">extends</span> <span class="title class_">FirstInterface</span>, <span class="title class_">SecondInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确使用如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&lt;T <span class="keyword">extends</span> <span class="title class_">ChildInterface</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">genericProperty</span>: T</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">genericProperty: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span> = genericProperty</span><br><span class="line">  &#125;</span><br><span class="line">  u<span class="string">`Set`</span>() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span>.<span class="title function_">doSomething</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">genericProperty</span>.<span class="title function_">doSomethingElse</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过泛型约束就可以达到多类型约束的目的</p>
<h2 id="说说你对-TypeScript-中高级类型的理解？有哪些？"><a href="#说说你对-TypeScript-中高级类型的理解？有哪些？" class="headerlink" title="说说你对 TypeScript 中高级类型的理解？有哪些？"></a>说说你对 TypeScript 中高级类型的理解？有哪些？</h2><p>一、是什么<br>除了string、number、boolean 这种基础类型外，在 typescript 类型声明中还存在一些高级的类型应用</p>
<p>这些高级类型，是typescript为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>
<p>#二、有哪些<br>常见的高级类型有如下：</p>
<p>交叉类型<br>联合类型<br>类型别名<br>类型索引<br>类型约束<br>映射类型<br>条件类型<br>#交叉类型<br>通过 &amp; 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>
<p>语法如下：</p>
<p>T &amp; U<br>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> extend&lt;T , U&gt;(<span class="attr">first</span>: T, <span class="attr">second</span>: U) : T &amp; U &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">result</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span> = &#123;&#125;</span></span><br><span class="line"><span class="language-xml">    for (let key in first) &#123;</span></span><br><span class="line"><span class="language-xml">        result[key] = first[key]</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    for (let key in second) &#123;</span></span><br><span class="line"><span class="language-xml">        if(!result.hasOwnProperty(key)) &#123;</span></span><br><span class="line"><span class="language-xml">            result[key] = second[key]</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">    return result</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>#联合类型<br>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>
<p>语法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T | U</span><br></pre></td></tr></table></figure>

<p>例如 number | string | boolean 的类型只能是这三个的一种，不能共存</p>
<p>如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatCommandline</span>(<span class="params">command: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> line = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> command === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    line = command.<span class="title function_">trim</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    line = command.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">trim</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#类型别名<br>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>
<p>可以使用 type SomeName &#x3D; someValidTypeAnnotation的语法来创建类型别名：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> some = <span class="built_in">boolean</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: some = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: some = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: some = <span class="number">123</span> <span class="comment">// 不能将类型“123”分配给类型“some”</span></span><br></pre></td></tr></table></figure>

<p>此外类型别名可以是泛型:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Container</span>&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用类型别名来在属性里引用自己：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tree</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    <span class="attr">left</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">    <span class="attr">right</span>: <span class="title class_">Tree</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>
<p>两者最大的区别在于，interface只能用于定义对象类型，而 type 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>
<p>#类型索引<br>keyof 类似于 Object.keys ，用于获取一个接口中 Key 的联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">text</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ButtonKeys</span> = keyof <span class="title class_">Button</span></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ButtonKeys</span> = <span class="string">&quot;type&quot;</span> | <span class="string">&quot;text&quot;</span></span><br></pre></td></tr></table></figure>

<p>#类型约束<br>通过关键字 extend 进行约束，不同于在 class 后使用 extends 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Ba</span><span class="string">`Set`</span>ype = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里表示 copy 的参数</span></span><br><span class="line"><span class="comment">// 只能是字符串、数字、布尔这几种基础类型</span></span><br><span class="line"><span class="keyword">function</span> copy&lt;T <span class="keyword">extends</span> <span class="title class_">Ba</span><span class="string">`Set`</span>ype&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 extends 和 keyof 进行约束。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getValue&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">getValue</span>(obj, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>#映射类型<br>通过 in 关键字做类型的映射，遍历已有接口的 key 或者是遍历联合类型，如下例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadOnlyObj</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Obj</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上述的结构，可以分成这些步骤：</p>
<p>keyof T：通过类型索引 keyof 的得到联合类型 ‘a’ | ‘b’<br>P in keyof T 等同于 p in ‘a’ | ‘b’，相当于执行了一次 forEach 的逻辑，遍历 ‘a’ | ‘b’<br>所以最终ReadOnlyObj的接口为下述：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyObj</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#条件类型<br>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>
<p>#三、总结<br>可以看到，如果只是掌握了 typeScript 的一些基础类型，可能很难游刃有余的去使用 typeScript，需要了解一些typescript的高阶用法</p>
<p>并且typescript在版本的迭代中新增了很多功能，需要不断学习与掌握</p>
<h2 id="说说你对-TypeScript-装饰器的理解？应用场景？"><a href="#说说你对-TypeScript-装饰器的理解？应用场景？" class="headerlink" title="说说你对 TypeScript 装饰器的理解？应用场景？"></a>说说你对 TypeScript 装饰器的理解？应用场景？</h2><p>一、是什么<br>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>
<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>
<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，@expression 的形式其实是Object.defineProperty的语法糖</p>
<p>expression求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>
<p>#二、使用方式<br>由于typescript是一个实验性特性，若要使用，需要在tsconfig.json文件启动，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typescript装饰器的使用和javascript基本一致</p>
<p>类的装饰器可以装饰：</p>
<p>类</p>
<p>方法&#x2F;属性</p>
<p>参数</p>
<p>访问器</p>
<p>#类装饰<br>例如声明一个函数 addAge 去给 Class 的属性 age 添加年龄.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">  constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@addAge</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age!: number;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>上述代码，实际等同于以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span> = <span class="title function_">addAge</span>(<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; ... &#125;);</span><br></pre></td></tr></table></figure>

<p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 constructor.prototype.age 就是在每一个实例化对象上面添加一个 age 属性</p>
<p>#方法&#x2F;属性装饰<br>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>
<p>target：对象的原型<br>propertyKey：方法的名称<br>descriptor：方法的属性描述符<br>可以看到，这三个属性实际就是Object.defineProperty的三个参数，如果是类的属性，则没有传递第三个参数</p>
<p>如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明装饰器修饰方法/属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">method</span>(<span class="params">target: any, propertyKey: string, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop &quot;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desc &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  descriptor.<span class="property">writable</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">property</span>(<span class="params">target: any, propertyKey: string</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;target&quot;</span>, target)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;propertyKey&quot;</span>, propertyKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> @property</span><br><span class="line"> <span class="attr">name</span>: string;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @method</span><br><span class="line"> <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;instance method&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @method</span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">run</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;static method&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xmz = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改实例方法say</span></span><br><span class="line">xmz.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;edit&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下图所示：</p>
<p>#参数装饰<br>接收3个参数，分别是：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">target ：当前对象的原型</span><br><span class="line">propertyKey ：参数的名称</span><br><span class="line">index：参数数组中的位置</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logParameter</span>(<span class="params">target: <span class="built_in">Object</span>, propertyName: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyName);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="meta">@logParameter</span> <span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;message&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> emp = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">emp.<span class="title function_">greet</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>输入如下图：</p>
<p>#访问器装饰<br>使用起来方式与方法装饰一致，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modification</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop &quot;</span> + propertyKey);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desc &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(descriptor) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"> <span class="attr">_name</span>: <span class="built_in">string</span>;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@modification</span></span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#装饰器工厂<br>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addAge</span>(<span class="params">age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">    constructor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addAge</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;huihui&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>#执行顺序<br>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;f(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): evaluated&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;g(): called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="meta">@f</span>()</span><br><span class="line">    <span class="meta">@g</span>()</span><br><span class="line">    <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="title function_">f</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): evaluated</span><br><span class="line"><span class="title function_">g</span>(): called</span><br><span class="line"><span class="title function_">f</span>(): called</span><br></pre></td></tr></table></figure>

<p>#三、应用场景<br>可以看到，使用装饰器存在两个显著的优点：</p>
<p>代码可读性变强了，装饰器命名相当于一个注释<br>在不改变原有代码情况下，对原来功能进行扩展<br>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>
<h2 id="说说对-TypeScript-中命名空间与模块的理解？区别？"><a href="#说说对-TypeScript-中命名空间与模块的理解？区别？" class="headerlink" title="说说对 TypeScript 中命名空间与模块的理解？区别？"></a>说说对 TypeScript 中命名空间与模块的理解？区别？</h2><p>一、模块<br>TypeScript 与ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块</p>
<p>相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的</p>
<p>例如我们在在一个 TypeScript 工程下建立一个文件 1.ts，声明一个变量a，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后在另一个文件同样声明一个变量a，这时候会出现错误信息</p>
<p>提示重复声明a变量，但是所处的空间是全局的</p>
<p>如果需要解决这个问题，则通过import或者export引入模块系统即可，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line">在typescript中，<span class="keyword">export</span>关键字可以导出变量或者类型，用法与es6模块一致，如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过import 引入模块，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, <span class="title class_">Person</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./export&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>#二、命名空间<br>命名空间一个最明确的目的就是解决重名问题</p>
<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>
<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>
<p>TypeScript 中命名空间使用 namespace 来定义，语法格式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">SomeNameSpaceName</span> &#123;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ISomeInterfaceName</span> &#123;      &#125;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SomeClassName</span> &#123;      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加 export 关键字</p>
<p>使用方式如下：</p>
<p>SomeNameSpaceName.SomeClassName<br>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Letter</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> z = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成js如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Letter</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Letter</span>) &#123;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title class_">Letter</span>.<span class="property">z</span> = <span class="number">26</span>;</span><br><span class="line">&#125;)(<span class="title class_">Letter</span> || (<span class="title class_">Letter</span> = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>#三、区别<br>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</p>
<p>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</p>
<p>在正常的TS项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</p>
<h2 id="说说如何在-React-项目中应用-TypeScript？"><a href="#说说如何在-React-项目中应用-TypeScript？" class="headerlink" title="说说如何在 React 项目中应用 TypeScript？"></a>说说如何在 React 项目中应用 TypeScript？</h2><h2 id="说说如何在Vue项目中应用TypeScript？"><a href="#说说如何在Vue项目中应用TypeScript？" class="headerlink" title="说说如何在Vue项目中应用TypeScript？"></a>说说如何在Vue项目中应用TypeScript？</h2><h1 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h1><h2 id="说说你对-Node-js-的理解？优缺点？应用场景？"><a href="#说说你对-Node-js-的理解？优缺点？应用场景？" class="headerlink" title="说说你对 Node.js 的理解？优缺点？应用场景？"></a>说说你对 Node.js 的理解？优缺点？应用场景？</h2><h2 id="说说-Node-js-有哪些全局对象？"><a href="#说说-Node-js-有哪些全局对象？" class="headerlink" title="说说 Node.js 有哪些全局对象？"></a>说说 Node.js 有哪些全局对象？</h2><h2 id="说说对-Node-中的-process-的理解？有哪些常用方法？"><a href="#说说对-Node-中的-process-的理解？有哪些常用方法？" class="headerlink" title="说说对 Node 中的 process 的理解？有哪些常用方法？"></a>说说对 Node 中的 process 的理解？有哪些常用方法？</h2><h2 id="说说对-Node-中的-fs模块的理解-有哪些常用方法"><a href="#说说对-Node-中的-fs模块的理解-有哪些常用方法" class="headerlink" title="说说对 Node 中的 fs模块的理解? 有哪些常用方法"></a>说说对 Node 中的 fs模块的理解? 有哪些常用方法</h2><h2 id="说说对-Node-中的-Buffer-的理解？应用场景？"><a href="#说说对-Node-中的-Buffer-的理解？应用场景？" class="headerlink" title="说说对 Node 中的 Buffer 的理解？应用场景？"></a>说说对 Node 中的 Buffer 的理解？应用场景？</h2><h2 id="说说对-Node-中的-Stream-的理解？应用场景？"><a href="#说说对-Node-中的-Stream-的理解？应用场景？" class="headerlink" title="说说对 Node 中的 Stream 的理解？应用场景？"></a>说说对 Node 中的 Stream 的理解？应用场景？</h2><h2 id="说说Node中的EventEmitter-如何实现一个EventEmitter"><a href="#说说Node中的EventEmitter-如何实现一个EventEmitter" class="headerlink" title="说说Node中的EventEmitter? 如何实现一个EventEmitter?"></a>说说Node中的EventEmitter? 如何实现一个EventEmitter?</h2><h2 id="说说对-Node-js-中的事件循环机制理解"><a href="#说说对-Node-js-中的事件循环机制理解" class="headerlink" title="说说对 Node.js 中的事件循环机制理解?"></a>说说对 Node.js 中的事件循环机制理解?</h2><h2 id="说说-Node-文件查找的优先级以及-Require-方法的文件查找策略"><a href="#说说-Node-文件查找的优先级以及-Require-方法的文件查找策略" class="headerlink" title="说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"></a>说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h2><h2 id="说说对中间件概念的理解，如何封装-node-中间件？"><a href="#说说对中间件概念的理解，如何封装-node-中间件？" class="headerlink" title="说说对中间件概念的理解，如何封装 node 中间件？"></a>说说对中间件概念的理解，如何封装 node 中间件？</h2><h2 id="如何实现jwt鉴权机制？说说你的思路"><a href="#如何实现jwt鉴权机制？说说你的思路" class="headerlink" title="如何实现jwt鉴权机制？说说你的思路"></a>如何实现jwt鉴权机制？说说你的思路</h2><h2 id="如何实现文件上传？说说你的思路"><a href="#如何实现文件上传？说说你的思路" class="headerlink" title="如何实现文件上传？说说你的思路"></a>如何实现文件上传？说说你的思路</h2><h2 id="如果让你来设计一个分页功能-你会怎么设计-前后端如何交互"><a href="#如果让你来设计一个分页功能-你会怎么设计-前后端如何交互" class="headerlink" title="如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"></a>如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h2><h2 id="Node性能如何进行监控以及优化？"><a href="#Node性能如何进行监控以及优化？" class="headerlink" title="Node性能如何进行监控以及优化？"></a>Node性能如何进行监控以及优化？</h2><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="1-项目中有封装过axios吗？主要是封装哪些方面"><a href="#1-项目中有封装过axios吗？主要是封装哪些方面" class="headerlink" title="1. 项目中有封装过axios吗？主要是封装哪些方面"></a>1. 项目中有封装过axios吗？主要是封装哪些方面</h2><p>有的，主要就是随着项目规模的增大，为了方便管理和维护我们的代码，提高代码质量，在项目中都会对axios进行一个二次封装</p>
<p>在封装的同时需要和后端进行协商好，请求参数，状态码和请求的超时时间</p>
<p>主要有以下的几个方面</p>
<p>设置接口请求前缀，利用node环境变量来判断，区分开发，测试，生产的不同环境，</p>
<p>在我们本地调试的时候，如果后端没有开启cors跨域，我们就需要在vue配置文件中进行配置devServer代理转发从而实现跨域请求</p>
<p>请求头：在请求头里面，有的一些业务必须要携带token或者是其他的参数才可以请求，就需要对请求的配置对象在请求数据时携带上token，这样就不用每次请求数据时，还要去手动加上token</p>
<p>状态码：根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p>
<p>请求拦截器：依据请求头的请求设定，来决定哪些请求是可以访问的</p>
<p>响应拦截器：这块就是根据后端返回的状态码执行不同的业务</p>
<p>封装请求方法，先把axios实例引入进来，在把不同的请求方法，用一个函数保存起来，最后对外暴露出去，然后在需要使用该请求方法的页面导入，直接调用即可</p>
<p>可以把所有的有相同业务逻辑的请求方法写在一个api文件夹里面，就比如说，要做权限的业务，就可以把所有的请求方法放在一个permission.js的文件里面，做薪资管理的就可以把所有的请求方法放在一个salary.js的文件里面，方便后期的统一管理和维护</p>
<h2 id="2-vue项目中跨域问题的解决"><a href="#2-vue项目中跨域问题的解决" class="headerlink" title="2. vue项目中跨域问题的解决"></a>2. vue项目中跨域问题的解决</h2><p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>
<p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p>
<p>所谓同源（即指在同一个域）具有以下三个相同点</p>
<ul>
<li>协议相同（protocol）</li>
<li>主机相同（host）</li>
<li>端口相同（port）</li>
</ul>
<p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p>
<blockquote>
<p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p>
</blockquote>
<h3 id="二、如何解决"><a href="#二、如何解决" class="headerlink" title="二、如何解决"></a>二、如何解决</h3><p>解决跨域的方法有很多，下面列举了三种：</p>
<ul>
<li>JSONP</li>
<li>CORS</li>
<li>Proxy</li>
</ul>
<p>而在<code>vue</code>项目中，我们主要针对<code>CORS</code>或<code>Proxy</code>这两种方案进行展开</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>
<p><code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p>
<p>只要后端实现了 <code>CORS</code>，就实现了跨域</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p>
<p><strong>方案一</strong></p>
<p>如果是通过<code>vue-cli</code>脚手架工具搭建项目，我们可以通过<code>webpack</code>为我们起一个本地服务器作为请求的代理对象</p>
<p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域</p>
<p>在<code>vue.config.js</code>文件，新增以下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">amodule.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8084</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">// vue项目启动时自动打开浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123; <span class="comment">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class="comment">//目标地址，一般是指后台服务器地址</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="comment">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&quot;&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>axios</code>发送请求中，配置请求的根路径</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二</strong></p>
<p>此外，还可通过服务端实现代理请求转发</p>
<p>以<code>express</code>框架为例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname + <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123; <span class="attr">target</span>: <span class="string">&#x27;http://localhost:4000&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">false</span></span><br><span class="line">                      &#125;));</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app</span><br></pre></td></tr></table></figure>

<p><strong>方案三</strong></p>
<p>通过配置<code>nginx</code>实现代理</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen    <span class="number">80</span>;</span><br><span class="line">    # server_name www.josephxia.com;</span><br><span class="line">    location / <span class="punctuation">&#123;</span></span><br><span class="line">        root  /var/www/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    location /api <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass  http<span class="punctuation">:</span><span class="comment">//127.0.0.1:3000;</span></span><br><span class="line">        proxy_redirect   off;</span><br><span class="line">        proxy_`Set`_header  Host       $host;</span><br><span class="line">        proxy_`Set`_header  X-Real-IP     $remote_addr;</span><br><span class="line">        proxy_`Set`_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-本地开发完后部署到服务器后404是什么原因"><a href="#3-本地开发完后部署到服务器后404是什么原因" class="headerlink" title="3. 本地开发完后部署到服务器后404是什么原因"></a>3. 本地开发完后部署到服务器后404是什么原因</h2><p>当我们进入到子路由时刷新页面，<code>web</code>容器没有相对应的页面此时会出现404</p>
<p>所以我们只需要配置将任意页面都重定向到 <code>index.html</code>，把路由交由前端处理</p>
<p>对<code>nginx</code>配置文件<code>.conf</code>修改，添加<code>try_files $uri $uri/ /index.html;</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location / <span class="punctuation">&#123;</span></span><br><span class="line">    index  /data/dist/index.html;</span><br><span class="line">    try_files $uri $uri/ /index.html;</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>修改完配置文件后记得配置的更新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 <code>index.html</code> 文件</p>
<h2 id="4-项目中的错误处理"><a href="#4-项目中的错误处理" class="headerlink" title="4. 项目中的错误处理"></a>4. 项目中的错误处理</h2></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/rabbit.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/rabbit.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">dleei</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/posts/7986f38c.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/posts/7986f38c.html')">前端常见面试题合集</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/posts/7986f38c.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=前端常见面试题合集&amp;url=http://example.com/posts/7986f38c.html&amp;pic=https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202311142355783.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>许可协议,转载请注明来自<a target="_blank" rel="noopener" href="https://github.com/dleei">dleei</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试经验<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/react.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e4f71320.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LyZcwuLWv2FArOumCxobpA.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">js常用简写技巧</div></div></a></div><div class="next-post pull-right"><a href="/posts/4.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202306231254825.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">js基础入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/rabbit.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">dleei</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/dleei" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/320440274" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://juejin.cn/user/2764604887281447" target="_blank" title="掘金"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-juejin"></use></svg></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问代磊的个人博客鸭~</div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue"><span class="toc-number">1.</span> <span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">对vue的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">前端路由原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFmvvm-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">什么是mvvm?优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">工厂函数与构造函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8vue2%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">在vue2中是如何监听数组的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-number">1.6.</span> <span class="toc-text">有没有了解虚拟列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue2%E4%B8%ADelement-ui%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5"><span class="toc-number">1.7.</span> <span class="toc-text">vue2中element-ui的自动按需导入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85-babel-plugin-import-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 安装 babel-plugin-import 插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE-babelrc-%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 配置 .babelrc 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%A8-main-js-%E4%B8%AD%E5%BC%95%E5%85%A5-Element-UI-%E6%A0%B7%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 在 main.js 中引入 Element UI 样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libraryName-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.4.</span> <span class="toc-text">libraryName 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.</span> <span class="toc-text">图片懒加载实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-cli%E5%9F%BA%E4%BA%8Ewebpack%E5%BA%95%E5%B1%82%E5%B0%81%E8%A3%85%E4%BA%86mode-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE-%E5%BC%80%E5%8F%91%E6%88%96%E6%98%AF%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83-%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E8%A6%86%E7%9B%96"><span class="toc-number">1.9.</span> <span class="toc-text">vue-cli基于webpack底层封装了mode,环境变量配置(开发或是生产环境),可以实现手动配置选项覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.10.</span> <span class="toc-text">css选择器优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.10.1.</span> <span class="toc-text">可继承的属性有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.3.</span> <span class="toc-text">盒子居中方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-flex%E5%B8%83%E5%B1%80"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">1.flex布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%84%B1%E6%A0%87-%E5%88%A9%E7%94%A8margin%E8%87%AA%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%B1%85%E4%B8%AD"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">2.脱标,利用margin自动实现居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%E4%BD%8D%E7%A7%BB%E5%92%8C%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">3.利用位移和定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.11.</span> <span class="toc-text">自定义指令的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-number">1.12.</span> <span class="toc-text">依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%B8%A4%E4%B8%AA%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.13.</span> <span class="toc-text">前端路由两个形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%8E%BB%E9%87%8D"><span class="toc-number">1.14.</span> <span class="toc-text">给你一个数组实现去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">computed和watch的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9SPA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.16.</span> <span class="toc-text">对SPA的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show%E5%92%8Cv-if%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-number">1.17.</span> <span class="toc-text">v-show和v-if怎么理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8A%E4%B8%80%E8%81%8Avue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.18.</span> <span class="toc-text">聊一聊vue的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D-%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%9C%A8created%E5%92%8Cmounted%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.0.1.</span> <span class="toc-text">题外话:数据请求在created和mounted的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.19.</span> <span class="toc-text">vue实例挂载的过程中发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E8%AE%BA"><span class="toc-number">1.19.1.</span> <span class="toc-text">三、结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEv-for%E5%92%8Cv-if%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="toc-number">1.20.</span> <span class="toc-text">为什么不建议v-for和v-if一起用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.21.</span> <span class="toc-text">为什么data属性是一个函数而不是对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.22.</span> <span class="toc-text">组件间的通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF"><span class="toc-number">1.22.1.</span> <span class="toc-text">父子组件之间的通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%90%91%E5%AD%90%E4%BC%A0%E5%80%BC"><span class="toc-number">1.22.1.1.</span> <span class="toc-text">父向子传值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%90%91%E7%88%B6%E4%BC%A0%E5%80%BC"><span class="toc-number">1.22.1.2.</span> <span class="toc-text">子向父传值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC"><span class="toc-number">1.22.2.</span> <span class="toc-text">非父子组件之间的传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E4%B9%8B%E9%97%B4"><span class="toc-number">1.22.3.</span> <span class="toc-text">兄弟之间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%BB%84%E4%BB%B6"><span class="toc-number">1.22.4.</span> <span class="toc-text">复杂组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">1.23.</span> <span class="toc-text">vue双向绑定的理解及原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-nextTick-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.24.</span> <span class="toc-text">谈谈你对 $nextTick 的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slot%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.25.</span> <span class="toc-text">slot的理解，应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD"><span class="toc-number">1.25.1.</span> <span class="toc-text">默认插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-number">1.25.2.</span> <span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="toc-number">1.25.3.</span> <span class="toc-text">作用域插槽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-observable-%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">vue.observable 你有了解过吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9vue%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.27.</span> <span class="toc-text">对vue中key的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%93%E5%AD%98%E5%BD%93%E5%89%8D%E7%BB%84%E4%BB%B6%E3%80%81%E7%BC%93%E5%AD%98%E5%90%8E%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0"><span class="toc-number">1.28.</span> <span class="toc-text">对keep-alive的理解，如何缓存当前组件、缓存后如何更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive%E5%8E%9F%E7%90%86"><span class="toc-number">1.28.1.</span> <span class="toc-text">keep alive原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.29.</span> <span class="toc-text">vue常用修饰符，应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%90%97%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.30.</span> <span class="toc-text">你有写过自定义指令吗？应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%AD%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.31.</span> <span class="toc-text">vue中的过滤器了解过吗？应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.32.</span> <span class="toc-text">什么是虚拟DOM？如何实现一个虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3diff%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">了解diff算法吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue2%E5%8F%8Avue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.34.</span> <span class="toc-text">vue2及vue3的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%A1%B9%E7%9B%AE%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E6%8A%A5404%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%91%A2%EF%BC%9F"><span class="toc-number">1.35.</span> <span class="toc-text">vue项目本地开发完成后部署到服务器后报404是什么原因呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">你是怎么处理vue项目中的错误的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.37.</span> <span class="toc-text">父子组件的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E6%95%B0%E7%BB%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.38.</span> <span class="toc-text">vue如何监听对象或者数组某个属性的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%9B%91%E5%90%AC"><span class="toc-number">1.38.1.</span> <span class="toc-text">对象属性的监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%91%E5%90%AC"><span class="toc-number">1.38.2.</span> <span class="toc-text">数组元素的监听</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-watch"><span class="toc-number">1.38.2.1.</span> <span class="toc-text">使用 $watch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Vue-Set"><span class="toc-number">1.38.2.2.</span> <span class="toc-text">使用 Vue.Set</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assets%E5%92%8Cstatic%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.39.</span> <span class="toc-text">assets和static的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VueRouter%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E9%82%A3%E4%BA%9B%E7%BB%84%E4%BB%B6"><span class="toc-number">1.40.</span> <span class="toc-text">VueRouter是什么, 有那些组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#router%E5%92%8Croute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.41.</span> <span class="toc-text">router和route的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%BC%80%E5%8F%91%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.42.</span> <span class="toc-text">路由开发的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VueRouter%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.43.</span> <span class="toc-text">VueRouter的使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%9C%89%E9%82%A3%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="toc-number">1.44.</span> <span class="toc-text">路由跳转有那些方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.45.</span> <span class="toc-text">编程式导航使用的方法以及常用的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F"><span class="toc-number">1.46.</span> <span class="toc-text">路由的传参方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C404"><span class="toc-number">1.47.</span> <span class="toc-text">路由重定向和404</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.48.</span> <span class="toc-text">路由配置项常用的属性及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-number">1.49.</span> <span class="toc-text">路由守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vuex%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.50.</span> <span class="toc-text">说说你对vuex的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%93%8D%E5%BA%94%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.51.</span> <span class="toc-text">数据不响应的情况有哪些,如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-use%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.52.</span> <span class="toc-text">vue.use的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mixin%E7%9A%84%E4%BD%9C%E7%94%A8-%E5%92%8C%E7%BB%84%E4%BB%B6%E5%86%B2%E7%AA%81%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.53.</span> <span class="toc-text">mixin的作用,和组件冲突的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mixin-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.53.1.</span> <span class="toc-text">mixin 的作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%92%8C-mixin-%E5%86%B2%E7%AA%81%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9A"><span class="toc-number">1.53.2.</span> <span class="toc-text">组件和 mixin 冲突的优先级：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0vue%E7%BB%84%E4%BB%B6"><span class="toc-number">1.54.</span> <span class="toc-text">如何强制更新vue组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3"><span class="toc-number">2.</span> <span class="toc-text">vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">vue3.0的设计目标是什么？做了哪些优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-0%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87%E4%B8%BB%E8%A6%81%E9%80%9A%E8%BF%87%E9%82%A3%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%E4%BD%93%E7%8E%B0%E7%9A%84"><span class="toc-number">2.2.</span> <span class="toc-text">vue3.0性能的提升主要通过那几个方面体现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Proxy-API-%E6%9B%BF%E4%BB%A3-defineProperty-API-%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0-%E6%89%80%E9%87%87%E7%94%A8%E7%9A%84-Composition-Api-%E4%B8%8E-Vue2-x-%E4%BD%BF%E7%94%A8%E7%9A%84-Options-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">2.4.1.</span> <span class="toc-text">1. 组织代码的方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A3%B0%E6%98%8E%EF%BC%9A"><span class="toc-number">2.4.2.</span> <span class="toc-text">2. 响应式数据的声明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%EF%BC%9A"><span class="toc-number">2.4.3.</span> <span class="toc-text">3. 生命周期钩子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%EF%BC%9A"><span class="toc-number">2.4.4.</span> <span class="toc-text">4. 代码重用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Typescript-%E6%94%AF%E6%8C%81%EF%BC%9A"><span class="toc-number">2.4.5.</span> <span class="toc-text">5. Typescript 支持：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue-3-0%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7%EF%BC%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">说说Vue 3.0中Treeshaking特性？举例说明一下？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.5.1.</span> <span class="toc-text">举例说明：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8Vue3-0-%E5%86%99%E8%BF%87%E7%BB%84%E4%BB%B6%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Modal%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3axios%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F%E6%9C%89%E7%9C%8B%E8%BF%87%E6%BA%90%E7%A0%81%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">你了解axios原理吗？有看过源码吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSR%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%9C%89%E5%81%9A%E8%BF%87%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%81%9A%E7%9A%84"><span class="toc-number">3.2.</span> <span class="toc-text">SSR解决了什么问题？有做过吗？如何做的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%8C%E8%8B%A5%E6%98%AF%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%BB%84%E4%BB%B6%E5%8F%8A%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">说说vue项目目录结构，若是大型项目如何划分组件及结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F%E6%8E%A7%E5%88%B6%E5%88%B0%E6%8C%89%E9%92%AE%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9D%83%E9%99%90%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">权限管理如何做？控制到按钮级别的权限如何做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.</span> <span class="toc-text">浏览器底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84"><span class="toc-number">3.6.</span> <span class="toc-text">浏览器是如何解析css选择器的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%95%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84"><span class="toc-number">3.7.</span> <span class="toc-text">浏览器是如何进行界面渲染的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF"><span class="toc-number">3.8.</span> <span class="toc-text">前端如何实现实时通讯?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">3.8.1.</span> <span class="toc-text">特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.8.2.</span> <span class="toc-text">工作原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">3.8.3.</span> <span class="toc-text">JavaScript 中的使用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">3.9.</span> <span class="toc-text">什么是浏览器同源策略?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">3.10.</span> <span class="toc-text">如何实现跨域获取数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-number">4.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">说说JavaScript中的数据类型？存储上的差别？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7%E7%A7%8D"><span class="toc-number">4.1.0.0.1.</span> <span class="toc-text">基本数据类型:7种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.0.0.2.</span> <span class="toc-text">引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">js数据类型的检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">数组的常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">JavaScript字符串的常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89%EF%BC%9A"><span class="toc-number">4.4.1.</span> <span class="toc-text">&#x3D;&#x3D;（相等操作符）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89%EF%BC%9A"><span class="toc-number">4.4.2.</span> <span class="toc-text">&#x3D;&#x3D;&#x3D;（严格相等操作符）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">4.4.3.</span> <span class="toc-text">如何选择使用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">深拷贝浅拷贝的区别？如何实现一个深拷贝？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.6.</span> <span class="toc-text">说说你对闭包的理解？闭包使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.7.</span> <span class="toc-text">说说你对作用域链的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">JavaScript原型，原型链 ? 有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">Javascript如何实现继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie-%E3%80%81localstorage-%E3%80%81-sessionstrorage-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">cookie 、localstorage 、 sessionstrorage 之间有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.11.</span> <span class="toc-text">谈谈this对象的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">JavaScript中执行上下文和执行栈是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4JavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.13.</span> <span class="toc-text">说说JavaScript中的事件模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E4%B8%8E-instanceof-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.14.</span> <span class="toc-text">typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">解释下什么是事件代理？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">说说new操作符具体干了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">ajax原理是什么？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind%E3%80%81call%E3%80%81apply-%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAbind"><span class="toc-number">4.18.</span> <span class="toc-text">bind、call、apply 区别？如何实现一个bind?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">说说你对正则表达式的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.20.</span> <span class="toc-text">说说你对事件循环的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.21.</span> <span class="toc-text">DOM常见的操作有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84BOM%E5%AF%B9%E8%B1%A1%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.22.</span> <span class="toc-text">说说你对BOM的理解，常见的BOM对象你了解哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%BD%A0%E5%AF%B9%E5%B0%BE%E9%80%92%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.23.</span> <span class="toc-text">举例说明你对尾递归的理解，有哪些应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-JavaScript-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">4.24.</span> <span class="toc-text">说说 JavaScript 中内存泄漏的几种情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.25.</span> <span class="toc-text">Javascript本地存储的方式有哪些？区别及应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">4.26.</span> <span class="toc-text">说说你对函数式编程的理解？优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98%EF%BC%9F%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.27.</span> <span class="toc-text">Javascript中如何实现函数缓存？函数缓存有哪些应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Javascript-%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.28.</span> <span class="toc-text">说说 Javascript 数字精度丢失的问题，如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.29.</span> <span class="toc-text">什么是防抖和节流？有什么区别？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E4%B8%AD%EF%BC%9F"><span class="toc-number">4.30.</span> <span class="toc-text">如何判断一个元素是否在可视区域中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A6%82%E4%BD%95%E5%81%9A%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%EF%BC%9F"><span class="toc-number">4.31.</span> <span class="toc-text">大文件上传如何做断点续传？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.31.1.</span> <span class="toc-text">一、是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">4.31.2.</span> <span class="toc-text">分片上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">4.31.3.</span> <span class="toc-text">断点续传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">4.32.</span> <span class="toc-text">如何实现上拉加载，下拉刷新？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.33.</span> <span class="toc-text">什么是单点登录？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%EF%BC%9F"><span class="toc-number">4.34.</span> <span class="toc-text">web常见的攻击方式有哪些？如何防御？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="toc-number">4.35.</span> <span class="toc-text">解释下什么是变量声明提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%BB%A5%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E4%BC%A0%E9%80%92%E7%9A%84"><span class="toc-number">4.36.</span> <span class="toc-text">js的参数是以什么方式进行传递的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">4.37.</span> <span class="toc-text">js的垃圾回收机制是怎么做的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%B9%B3%E6%97%B6%E9%83%BD%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">4.38.</span> <span class="toc-text">谈谈你平时都用了哪些方法进行性能优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%BB%A7%E6%89%BF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.39.</span> <span class="toc-text">谈谈你对继承的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">4.39.1.</span> <span class="toc-text">继承的主要类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.39.2.</span> <span class="toc-text">继承的实现方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">4.39.3.</span> <span class="toc-text">继承的优缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">4.40.</span> <span class="toc-text">如何判断是否为数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.41.</span> <span class="toc-text">Promise的静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.42.</span> <span class="toc-text">微任务&#x2F;宏任务是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await%E6%98%AF%E4%BB%80%E4%B9%88-%E7%9B%B8%E8%BE%83%E4%BA%8EPromise%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF"><span class="toc-number">4.43.</span> <span class="toc-text">async&#x2F;await是什么?相较于Promise有什么优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E5%86%99%E5%87%BA%E8%87%B3%E5%B0%91%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%8E%9F%E7%94%9Fjs%EF%BC%89"><span class="toc-number">4.44.</span> <span class="toc-text">请写出至少两种常见的数组排序的方法（原生js）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E5%86%99%E8%87%B3%E5%B0%91%E4%B8%89%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E5%8E%9F%E7%94%9Fjs%EF%BC%89"><span class="toc-number">4.45.</span> <span class="toc-text">请写至少三种数组去重的方法？（原生js）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E9%81%93lodash%E5%90%97%EF%BC%9F%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84API-%EF%BC%9F"><span class="toc-number">4.46.</span> <span class="toc-text">知道lodash吗？它有哪些常见的API  ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E6%97%B6%E9%83%BD%E6%98%AF%E7%94%A8%E9%82%A3%E4%BA%9B%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E7%9A%84%EF%BC%9Fbabel%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.47.</span> <span class="toc-text">平时都是用那些工具进行打包的？babel是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88Set-%E3%80%81-map-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.48.</span> <span class="toc-text">谈谈Set 、 map 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">4.48.1.</span> <span class="toc-text">Set（集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-number">4.48.2.</span> <span class="toc-text">Map（映射）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">4.48.3.</span> <span class="toc-text">使用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">4.49.</span> <span class="toc-text">图片懒加载是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.50.</span> <span class="toc-text">for in 和 for of 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slice%E5%92%8Caplice%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.51.</span> <span class="toc-text">slice和aplice的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#slice-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.51.1.</span> <span class="toc-text">slice 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splice-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.51.2.</span> <span class="toc-text">splice 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">4.51.3.</span> <span class="toc-text">区别总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#substr%E5%92%8Csubstring%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.52.</span> <span class="toc-text">substr和substring的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#substr-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.52.1.</span> <span class="toc-text">substr 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#substring-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.52.2.</span> <span class="toc-text">substring 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">4.52.3.</span> <span class="toc-text">区别总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E4%BF%AE%E6%94%B9%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">4.53.</span> <span class="toc-text">能修改原数组的方法有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.54.</span> <span class="toc-text">说一下你对事件委托的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.55.</span> <span class="toc-text">说一说事件的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B9%E5%BC%8F-%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%ADforEach"><span class="toc-number">4.56.</span> <span class="toc-text">中断循环的方式,如何中断forEach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.57.</span> <span class="toc-text">如何判断后台返回的数据是一个空对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.58.</span> <span class="toc-text">数组、对象解构如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85axios"><span class="toc-number">4.59.</span> <span class="toc-text">如何二次封装axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E8%81%94%E8%B0%83"><span class="toc-number">4.60.</span> <span class="toc-text">如何进行接口联调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.61.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">4.62.</span> <span class="toc-text">promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#promise-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.62.0.1.</span> <span class="toc-text">promise 是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise-%E7%9A%84API"><span class="toc-number">4.62.0.2.</span> <span class="toc-text">promise 的API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98-promise-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.63.</span> <span class="toc-text">如何改变 promise 的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-promises-A-%E8%A7%84%E8%8C%83"><span class="toc-number">4.64.</span> <span class="toc-text">链式调用: promises&#x2F;A+规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">手写系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-promise"><span class="toc-number">5.1.</span> <span class="toc-text">手写 promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%97%AD%E5%8C%85"><span class="toc-number">5.2.</span> <span class="toc-text">手写闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E9%80%92%E5%BD%92"><span class="toc-number">5.3.</span> <span class="toc-text">手写递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-number">6.</span> <span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">说说var、let、const之间的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-number">6.1.1.</span> <span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-number">6.1.2.</span> <span class="toc-text">let</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.3.</span> <span class="toc-text">区别:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-number">6.2.</span> <span class="toc-text">ES6中数组新增了哪些扩展?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-number">6.3.</span> <span class="toc-text">ES6中对象新增了哪些扩展?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E4%B8%AD%E5%87%BD%E6%95%B0%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-number">6.4.</span> <span class="toc-text">ES6中函数新增了哪些扩展?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84Set%E3%80%81Map%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3"><span class="toc-number">6.5.</span> <span class="toc-text">ES6中新增的Set、Map两种数据结构怎么理解?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%AD-Promise%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">你是怎么理解ES6中 Promise的？使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%AD-Generator%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">怎么理解ES6中 Generator的？使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%ADProxy%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.8.</span> <span class="toc-text">你是怎么理解ES6中Proxy的？使用场景?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%ADModule%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">你是怎么理解ES6中Module的？使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%AD-Decorator-%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">6.10.</span> <span class="toc-text">你是怎么理解ES6中 Decorator 的？使用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">6.11.</span> <span class="toc-text">ES6有哪些新特性？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#css"><span class="toc-number">7.</span> <span class="toc-text">css</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.1.</span> <span class="toc-text">说说你对盒子模型的理解?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">css选择器有哪些？优先级？哪些属性可以继承？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.3.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7"><span class="toc-number">7.4.</span> <span class="toc-text">可继承属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4em-px-rem-vh-vw%E5%8C%BA%E5%88%AB"><span class="toc-number">7.5.</span> <span class="toc-text">说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#em%EF%BC%9A"><span class="toc-number">7.5.1.</span> <span class="toc-text">em：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#px%EF%BC%9A"><span class="toc-number">7.5.2.</span> <span class="toc-text">px：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rem%EF%BC%9A"><span class="toc-number">7.5.3.</span> <span class="toc-text">rem：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vh%EF%BC%88%E8%A7%86%E7%AA%97%E9%AB%98%E5%BA%A6%E5%8D%95%E4%BD%8D%EF%BC%89%EF%BC%9A"><span class="toc-number">7.5.4.</span> <span class="toc-text">vh（视窗高度单位）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vw%EF%BC%88%E8%A7%86%E7%AA%97%E5%AE%BD%E5%BA%A6%E5%8D%95%E4%BD%8D%EF%BC%89%EF%BC%9A"><span class="toc-number">7.5.5.</span> <span class="toc-text">vw（视窗宽度单位）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-number">7.5.6.</span> <span class="toc-text">区别总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E3%80%81css%E5%83%8F%E7%B4%A0%E3%80%81%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E5%83%8F%E7%B4%A0%E3%80%81dpr%E3%80%81ppi-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">说说设备像素、css像素、设备独立像素、dpr、ppi 之间的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9BFC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">谈谈你对BFC的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">7.7.1.</span> <span class="toc-text">BFC的特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABFC%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">7.7.2.</span> <span class="toc-text">创建BFC的条件：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">7.7.3.</span> <span class="toc-text">BFC的应用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%91%A2%EF%BC%9F"><span class="toc-number">7.8.</span> <span class="toc-text">元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">7.8.1.</span> <span class="toc-text">元素水平垂直居中的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9A"><span class="toc-number">7.8.2.</span> <span class="toc-text">元素不定宽高的水平垂直居中：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%8C%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%9F%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E5%91%A2%EF%BC%9F"><span class="toc-number">7.9.</span> <span class="toc-text">如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%8C%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%9A"><span class="toc-number">7.9.1.</span> <span class="toc-text">两栏布局，右侧自适应：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%9A"><span class="toc-number">7.9.2.</span> <span class="toc-text">三栏布局，中间自适应：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4flexbox%EF%BC%88%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B%EF%BC%89-%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">7.10.</span> <span class="toc-text">说说flexbox（弹性盒布局模型）,以及适用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bgrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80"><span class="toc-number">7.11.</span> <span class="toc-text">介绍一下grid网格布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS3%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">7.12.</span> <span class="toc-text">CSS3新增了哪些新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css3%E5%8A%A8%E7%94%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.13.</span> <span class="toc-text">css3动画有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E8%B7%9F%E9%87%8D%E7%BB%98%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91%EF%BC%9F"><span class="toc-number">7.14.</span> <span class="toc-text">怎么理解回流跟重绘？什么场景下会触发？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%EF%BC%88Reflow%EF%BC%89%EF%BC%9A"><span class="toc-number">7.14.1.</span> <span class="toc-text">回流（Reflow）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%EF%BC%9A"><span class="toc-number">7.14.2.</span> <span class="toc-text">重绘（Repaint）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">7.14.3.</span> <span class="toc-text">优化建议：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">7.15.</span> <span class="toc-text">什么是响应式设计？响应式设计的基本原理是什么？如何做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8CCSS%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.16.</span> <span class="toc-text">如果要做优化，CSS提高性能的方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%EF%BC%8F%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E7%9C%81%E7%95%A5%E6%A0%B7%E5%BC%8F%EF%BC%9F"><span class="toc-number">7.17.</span> <span class="toc-text">如何实现单行／多行文本溢出的省略样式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8css%E5%AE%8C%E6%88%90%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C"><span class="toc-number">7.18.</span> <span class="toc-text">如何使用css完成视差滚动效果?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.19.</span> <span class="toc-text">CSS如何画一个三角形？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9Chrome%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px-%E7%9A%84%E6%96%87%E5%AD%97%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.20.</span> <span class="toc-text">让Chrome支持小于12px 的文字方式有哪些？区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9Css%E9%A2%84%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">7.21.</span> <span class="toc-text">说说对Css预编语言的理解？有哪些区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8css%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">7.22.</span> <span class="toc-text">在css中有哪些定位方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3z-index"><span class="toc-number">7.23.</span> <span class="toc-text">如何理解z-index?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%BB%E4%B8%80%E4%B8%AA0-5%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF"><span class="toc-number">7.24.</span> <span class="toc-text">如何画一个0.5像素的线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%8D%8A%E9%80%8F%E6%98%8E%E9%A2%9C%E8%89%B2%EF%BC%9A"><span class="toc-number">7.24.1.</span> <span class="toc-text">1. 使用半透明颜色：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8box-shadow%EF%BC%9A"><span class="toc-number">7.24.2.</span> <span class="toc-text">2. 使用box-shadow：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">7.25.</span> <span class="toc-text">如何清除浮动?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.26.</span> <span class="toc-text">你对媒体查询的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">7.27.</span> <span class="toc-text">标准盒模型和怪异盒模型有哪些区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.28.</span> <span class="toc-text">伪类和伪元素的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http"><span class="toc-number">8.</span> <span class="toc-text">http</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTP-HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">什么是HTTP? HTTP 和 HTTPS 的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4HTTPS%E6%AF%94HTTP%E5%AE%89%E5%85%A8-HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">为什么说HTTPS比HTTP安全? HTTPS是如何保证安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3UDP-%E5%92%8C-TCP-%E5%8C%BA%E5%88%AB-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.3.</span> <span class="toc-text">如何理解UDP 和 TCP? 区别? 应用场景?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.4.</span> <span class="toc-text">如何理解OSI七层模型?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3TCP-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.5.</span> <span class="toc-text">如何理解TCP&#x2F;IP协议?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E8%AF%B4DNS-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">8.6.</span> <span class="toc-text">DNS协议 是什么？说说DNS 完整的查询过程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3CDN%EF%BC%9F%E8%AF%B4%E8%AF%B4%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">如何理解CDN？说说实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-HTTP1-0-1-1-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.8.</span> <span class="toc-text">说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">8.9.</span> <span class="toc-text">说说 HTTP 常见的状态码有哪些，适用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.10.</span> <span class="toc-text">说一下 GET 和 POST 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%9C%89%E5%93%AA%E4%BA%9B-%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">8.11.</span> <span class="toc-text">说说 HTTP 常见的请求头有哪些? 作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-URL-%E6%95%B2%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">说说地址栏输入 URL 敲下回车后发生了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">8.13.</span> <span class="toc-text">说说TCP为什么需要三次握手和四次挥手？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88Three-Way-Handshake%EF%BC%89%EF%BC%9A"><span class="toc-number">8.13.1.</span> <span class="toc-text">三次握手（Three-Way Handshake）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88Four-Way-Handshake%EF%BC%89%EF%BC%9A"><span class="toc-number">8.13.2.</span> <span class="toc-text">四次挥手（Four-Way Handshake）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9WebSocket%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">8.14.</span> <span class="toc-text">说说对WebSocket的理解？应用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">8.14.1.</span> <span class="toc-text">WebSocket的特点和工作原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">8.14.2.</span> <span class="toc-text">WebSocket的工作过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">8.14.3.</span> <span class="toc-text">应用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">说说你对微信小程序的理解？优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%87%8C%E9%9D%A2%E6%80%8E%E4%B9%88%E5%8F%91%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">小程序里面怎么发请求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E8%B7%A8%E5%9F%9F%E5%90%97%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">小程序有跨域吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">小程序常见的组件通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%94%9F%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8CApi"><span class="toc-number">9.5.</span> <span class="toc-text">使用过哪些小程序原生的组件和Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uni-app%E5%BC%80%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">9.6.</span> <span class="toc-text">uni-app开发的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">说说微信小程序的生命周期函数有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">说说微信小程序中路由跳转的方式有哪些？区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%8F%90%E9%AB%98%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E9%80%9F%E5%BA%A6%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.9.</span> <span class="toc-text">说说提高微信小程序的应用速度的手段有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">9.10.</span> <span class="toc-text">小程序分包流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">9.11.</span> <span class="toc-text">小程序实现导航栏自定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">9.12.</span> <span class="toc-text">说说微信小程序的登录流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">9.13.</span> <span class="toc-text">说说微信小程序的发布流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">9.14.</span> <span class="toc-text">说说微信小程序的支付流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E5%92%8Cpc%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F"><span class="toc-number">9.15.</span> <span class="toc-text">小程序和h5和pc端开发有什么不一样？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git"><span class="toc-number">10.</span> <span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">说说你对版本管理的理解？常用的版本管理工具有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Git%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">说说你对Git的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Git%E4%B8%AD-fork-clone-branch%E8%BF%99%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">10.3.</span> <span class="toc-text">说说Git中 fork, clone,branch这三个概念，有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">说说Git常用的命令有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Git-%E4%B8%AD-HEAD%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A0%91%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">说说Git 中 HEAD、工作树和索引之间的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9git-pull-%E5%92%8C-git-fetch-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.6.</span> <span class="toc-text">说说对git pull 和 git fetch 的理解？有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9git-stash-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">10.7.</span> <span class="toc-text">说说你对git stash 的理解？应用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">10.7.0.1.</span> <span class="toc-text">应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">10.7.0.2.</span> <span class="toc-text">注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9git-rebase-%E5%92%8C-git-merge%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.8.</span> <span class="toc-text">说说你对git rebase 和 git merge的理解？区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">10.8.0.1.</span> <span class="toc-text">区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">10.8.0.2.</span> <span class="toc-text">选择使用场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-git-%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">10.9.</span> <span class="toc-text">说说 git 发生冲突的场景？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9git-reset-%E5%92%8C-git-revert-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.10.</span> <span class="toc-text">说说你对git reset 和 git revert 的理解？区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A-1"><span class="toc-number">10.10.0.1.</span> <span class="toc-text">区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">10.10.0.2.</span> <span class="toc-text">使用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-1"><span class="toc-number">10.10.0.3.</span> <span class="toc-text">注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83"><span class="toc-number">10.11.</span> <span class="toc-text">git分支规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81"><span class="toc-number">10.12.</span> <span class="toc-text">git如何合并分支部分代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E6%96%B0%E5%88%86%E6%94%AF%E4%B8%94%E4%B8%8D%E4%BA%A7%E7%94%9F%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-number">10.13.</span> <span class="toc-text">如何切换新分支且不产生新记录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript"><span class="toc-number">11.</span> <span class="toc-text">TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%B8%8E-JavaScript-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">说说你对 TypeScript 的理解？与 JavaScript 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%89%B9%E6%80%A7"><span class="toc-number">11.1.1.</span> <span class="toc-text">二、特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%89%B9%E6%B3%A8"><span class="toc-number">11.1.2.</span> <span class="toc-text">类型批注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">11.1.3.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.1.4.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.5.</span> <span class="toc-text">三、区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-typescript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">说说 typescript 的数据类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">说说你对 TypeScript 中枚举类型的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">说说你对 TypeScript 中接口的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">11.5.</span> <span class="toc-text">说说你对 TypeScript 中类的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%B8%8E-JavaScript-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.6.</span> <span class="toc-text">说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">说说你对 TypeScript 中泛型的理解？应用场景？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E4%B8%AD%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">说说你对 TypeScript 中高级类型的理解？有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-TypeScript-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">说说你对 TypeScript 装饰器的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-TypeScript-%E4%B8%AD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">说说对 TypeScript 中命名空间与模块的理解？区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E5%9C%A8-React-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BA%94%E7%94%A8-TypeScript%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">说说如何在 React 项目中应用 TypeScript？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BA%94%E7%94%A8TypeScript%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">说说如何在Vue项目中应用TypeScript？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node-js"><span class="toc-number">13.</span> <span class="toc-text">node.js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-Node-js-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">说说你对 Node.js 的理解？优缺点？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Node-js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">说说 Node.js 有哪些全局对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-Node-%E4%B8%AD%E7%9A%84-process-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">13.3.</span> <span class="toc-text">说说对 Node 中的 process 的理解？有哪些常用方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-Node-%E4%B8%AD%E7%9A%84-fs%E6%A8%A1%E5%9D%97%E7%9A%84%E7%90%86%E8%A7%A3-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">说说对 Node 中的 fs模块的理解? 有哪些常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-Node-%E4%B8%AD%E7%9A%84-Buffer-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">13.5.</span> <span class="toc-text">说说对 Node 中的 Buffer 的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-Node-%E4%B8%AD%E7%9A%84-Stream-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">13.6.</span> <span class="toc-text">说说对 Node 中的 Stream 的理解？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Node%E4%B8%AD%E7%9A%84EventEmitter-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAEventEmitter"><span class="toc-number">13.7.</span> <span class="toc-text">说说Node中的EventEmitter? 如何实现一个EventEmitter?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9-Node-js-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3"><span class="toc-number">13.8.</span> <span class="toc-text">说说对 Node.js 中的事件循环机制理解?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Node-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%A5%E5%8F%8A-Require-%E6%96%B9%E6%B3%95%E7%9A%84%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5"><span class="toc-number">13.9.</span> <span class="toc-text">说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85-node-%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%9F"><span class="toc-number">13.10.</span> <span class="toc-text">说说对中间件概念的理解，如何封装 node 中间件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0jwt%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">13.11.</span> <span class="toc-text">如何实现jwt鉴权机制？说说你的思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">13.12.</span> <span class="toc-text">如何实现文件上传？说说你的思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD-%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92"><span class="toc-number">13.13.</span> <span class="toc-text">如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">13.14.</span> <span class="toc-text">Node性能如何进行监控以及优化？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE"><span class="toc-number">14.</span> <span class="toc-text">项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E5%B0%81%E8%A3%85%E8%BF%87axios%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%98%AF%E5%B0%81%E8%A3%85%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-number">14.1.</span> <span class="toc-text">1. 项目中有封装过axios吗？主要是封装哪些方面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">14.2.</span> <span class="toc-text">2. vue项目中跨域问题的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">14.2.1.</span> <span class="toc-text">二、如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS"><span class="toc-number">14.2.2.</span> <span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy"><span class="toc-number">14.2.3.</span> <span class="toc-text">Proxy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E5%AE%8C%E5%90%8E%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E404%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0"><span class="toc-number">14.3.</span> <span class="toc-text">3. 本地开发完后部署到服务器后404是什么原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">14.4.</span> <span class="toc-text">4. 项目中的错误处理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/28504.html" title="react入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/react.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="react入门"/></a><div class="content"><a class="title" href="/posts/28504.html" title="react入门">react入门</a><time datetime="2024-07-28T07:31:47.000Z" title="发表于 2024-07-28 15:31:47">2024-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2.html" title="手摸手教你重装系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/6bf7970e00c493119d0455d7681018605cdca4fc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手摸手教你重装系统"/></a><div class="content"><a class="title" href="/posts/2.html" title="手摸手教你重装系统">手摸手教你重装系统</a><time datetime="2024-07-25T18:19:40.000Z" title="发表于 2024-07-26 02:19:40">2024-07-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/37361.html" title="面试高频的事件循环"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308092229349.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试高频的事件循环"/></a><div class="content"><a class="title" href="/posts/37361.html" title="面试高频的事件循环">面试高频的事件循环</a><time datetime="2023-08-08T16:00:00.000Z" title="发表于 2023-08-09 00:00:00">2023-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/26620.html" title="ajax入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308072317029.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ajax入门"/></a><div class="content"><a class="title" href="/posts/26620.html" title="ajax入门">ajax入门</a><time datetime="2023-08-06T16:00:00.000Z" title="发表于 2023-08-07 00:00:00">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/62006.html" title="js里的垃圾回收机制"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hehuan2023/pic/typora/202308022317555.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js里的垃圾回收机制"/></a><div class="content"><a class="title" href="/posts/62006.html" title="js里的垃圾回收机制">js里的垃圾回收机制</a><time datetime="2023-08-01T16:00:00.000Z" title="发表于 2023-08-02 00:00:00">2023-08-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="dleei" target="_blank">dleei</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>7</sup></a><a href="/tags/ajax/" style="font-size: 0.88rem;">ajax<sup>1</sup></a><a href="/tags/alist/" style="font-size: 0.88rem;">alist<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>2</sup></a><a href="/tags/css%E5%B8%83%E5%B1%80/" style="font-size: 0.88rem;">css布局<sup>1</sup></a><a href="/tags/git/" style="font-size: 0.88rem;">git<sup>2</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>1</sup></a><a href="/tags/http/" style="font-size: 0.88rem;">http<sup>1</sup></a><a href="/tags/react/" style="font-size: 0.88rem;">react<sup>1</sup></a><a href="/tags/vue/" style="font-size: 0.88rem;">vue<sup>3</sup></a><a href="/tags/web-api/" style="font-size: 0.88rem;">web api<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 0.88rem;">日常<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>1</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F-windows/" style="font-size: 0.88rem;">系统 windows<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/" style="font-size: 0.88rem;">面试经验<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/2962056580&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2021 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "";
        img.alt = "";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script async src="https://at.alicdn.com/t/c/font_4134468_iy1cksqbqs.js?spm=a313x.manage_type_myprojects.i1.10.71fe3a81a8VKf6&amp;file=font_4134468_iy1cksqbqs.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>